./analysis/20250920/npm-licenses.json:  "@csstools/css-tokenizer@3.0.4": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@csstools/css-tokenizer",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@csstools/css-tokenizer/LICENSE.md"
./analysis/20250920/npm-licenses.json:  "@typescript-eslint/visitor-keys@7.18.0": {
./analysis/20250920/npm-licenses.json:  "@typescript-eslint/visitor-keys@8.44.0": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "eslint-visitor-keys@3.4.3": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/eslint/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/eslint-visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "eslint-visitor-keys@4.2.1": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "js-tokens@4.0.0": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/lydell/js-tokens",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/js-tokens",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/js-tokens/LICENSE"
./analysis/20250920/npm-licenses.json:  "js-tokens@9.0.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/lydell/js-tokens",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/ast-v8-to-istanbul/node_modules/js-tokens",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/ast-v8-to-istanbul/node_modules/js-tokens/LICENSE"
./analysis/20250920/npm-licenses.json:  "keyv@4.5.4": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/jaredwray/keyv",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/keyv",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/keyv/README.md"
./analysis/20250920/npm-licenses.json:  "object-keys@1.1.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/ljharb/object-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/object-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/object-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "own-keys@1.0.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/ljharb/own-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/own-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/own-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "path-key@3.1.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/sindresorhus/path-key",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/path-key",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/path-key/license"
./backend/src/utils/auth.rs://! - JWT-based authentication with refresh tokens
./backend/src/utils/auth.rs://! - API key management for service-to-service communication
./backend/src/utils/auth.rs:    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
./backend/src/utils/auth.rs:use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
./backend/src/utils/auth.rs:    pub refresh_token: Option<String>,
./backend/src/utils/auth.rs:    pub key_id: String,
./backend/src/utils/auth.rs:    pub key_hash: String,
./backend/src/utils/auth.rs:    /// JWT encoding key
./backend/src/utils/auth.rs:    encoding_key: EncodingKey,
./backend/src/utils/auth.rs:    /// JWT decoding key
./backend/src/utils/auth.rs:    decoding_key: DecodingKey,
./backend/src/utils/auth.rs:    /// API keys
./backend/src/utils/auth.rs:    api_keys: Arc<RwLock<HashMap<String, ApiKey>>>,
./backend/src/utils/auth.rs:    /// Refresh token timeout
./backend/src/utils/auth.rs:        jwt_secret: &str,
./backend/src/utils/auth.rs:        let encoding_key = EncodingKey::from_secret(jwt_secret.as_ref());
./backend/src/utils/auth.rs:        let decoding_key = DecodingKey::from_secret(jwt_secret.as_ref());
./backend/src/utils/auth.rs:            encoding_key,
./backend/src/utils/auth.rs:            decoding_key,
./backend/src/utils/auth.rs:            api_keys: Arc::new(RwLock::new(HashMap::new())),
./backend/src/utils/auth.rs:    /// Hash an API key using Argon2id with OWASP-recommended parameters
./backend/src/utils/auth.rs:    fn hash_api_key(api_key: &str) -> HiveResult<String> {
./backend/src/utils/auth.rs:        let password_hash = argon2
./backend/src/utils/auth.rs:            .hash_password(api_key.as_bytes(), &salt)
./backend/src/utils/auth.rs:                reason: format!("Failed to hash API key: {e}"),
./backend/src/utils/auth.rs:        Ok(password_hash)
./backend/src/utils/auth.rs:    /// Verify an API key against a hash using Argon2id
./backend/src/utils/auth.rs:    fn verify_api_key(api_key: &str, hash: &str) -> HiveResult<bool> {
./backend/src/utils/auth.rs:            reason: format!("Invalid password hash format: {e}"),
./backend/src/utils/auth.rs:            .verify_password(api_key.as_bytes(), &parsed_hash)
./backend/src/utils/auth.rs:            refresh_token: Some(Uuid::new_v4().to_string()),
./backend/src/utils/auth.rs:        // Generate JWT token
./backend/src/utils/auth.rs:        let token = encode(&Header::default(), &claims, &self.encoding_key).map_err(|e| {
./backend/src/utils/auth.rs:        Ok((token, session_id))
./backend/src/utils/auth.rs:    /// Validate JWT token and return claims
./backend/src/utils/auth.rs:    pub async fn validate_token(&self, token: &str) -> HiveResult<Claims> {
./backend/src/utils/auth.rs:        let token_data = decode::<Claims>(token, &self.decoding_key, &validation).map_err(|e| {
./backend/src/utils/auth.rs:                reason: format!("Invalid JWT token: {e}"),
./backend/src/utils/auth.rs:        let claims = token_data.claims;
./backend/src/utils/auth.rs:    /// Refresh JWT token
./backend/src/utils/auth.rs:    pub async fn refresh_token(&self, refresh_token: &str) -> HiveResult<String> {
./backend/src/utils/auth.rs:        // Find session by refresh token
./backend/src/utils/auth.rs:            .find(|s| s.refresh_token.as_ref() == Some(&refresh_token.to_string()))
./backend/src/utils/auth.rs:                reason: "Invalid refresh token".to_string(),
./backend/src/utils/auth.rs:        // Generate new JWT token
./backend/src/utils/auth.rs:        let token = encode(&Header::default(), &claims, &self.encoding_key).map_err(|e| {
./backend/src/utils/auth.rs:        Ok(token)
./backend/src/utils/auth.rs:    /// Create API key for service authentication
./backend/src/utils/auth.rs:    pub async fn create_api_key(
./backend/src/utils/auth.rs:        let key_id = Uuid::new_v4().to_string();
./backend/src/utils/auth.rs:        let api_key = Uuid::new_v4().to_string();
./backend/src/utils/auth.rs:        let key_hash = Self::hash_api_key(&api_key)?;
./backend/src/utils/auth.rs:        let api_key_obj = ApiKey {
./backend/src/utils/auth.rs:            key_id: key_id.clone(),
./backend/src/utils/auth.rs:            key_hash,
./backend/src/utils/auth.rs:        let mut api_keys = self.api_keys.write().await;
./backend/src/utils/auth.rs:        api_keys.insert(key_id.clone(), api_key_obj);
./backend/src/utils/auth.rs:        Ok((key_id, api_key))
./backend/src/utils/auth.rs:    /// Validate API key
./backend/src/utils/auth.rs:    pub async fn validate_api_key(&self, api_key: &str) -> HiveResult<HashSet<Permission>> {
./backend/src/utils/auth.rs:        let mut api_keys = self.api_keys.write().await;
./backend/src/utils/auth.rs:        for (_, key_obj) in api_keys.iter_mut() {
./backend/src/utils/auth.rs:            if Self::verify_api_key(api_key, &key_obj.key_hash)? {
./backend/src/utils/auth.rs:                if let Some(expires_at) = key_obj.expires_at {
./backend/src/utils/auth.rs:                            reason: "API key expired".to_string(),
./backend/src/utils/auth.rs:                key_obj.last_used = Some(Utc::now());
./backend/src/utils/auth.rs:                key_obj.usage_count += 1;
./backend/src/utils/auth.rs:                return Ok(key_obj.permissions.clone());
./backend/src/utils/auth.rs:            reason: "Invalid API key".to_string(),
./backend/src/utils/auth.rs:            let Some(token) = auth_header else {
./backend/src/utils/auth.rs:                // Check for API key
./backend/src/utils/auth.rs:                if let Some(api_key) = req.headers().get("X-API-Key").and_then(|h| h.to_str().ok())
./backend/src/utils/auth.rs:                    match auth_manager.validate_api_key(api_key).await {
./backend/src/utils/auth.rs:            // Validate JWT token
./backend/src/utils/auth.rs:            match auth_manager.validate_token(token).await {
./backend/src/utils/auth.rs:        let (token, session_id) = auth_manager
./backend/src/utils/auth.rs:        assert!(!token.is_empty());
./backend/src/utils/auth.rs:        // Test token validation
./backend/src/utils/auth.rs:        let claims = auth_manager.validate_token(&token).await?;
./backend/src/utils/auth.rs:        // Create API key
./backend/src/utils/auth.rs:        let (key_id, api_key) = auth_manager
./backend/src/utils/auth.rs:            .create_api_key(
./backend/src/utils/auth.rs:        assert!(!key_id.is_empty());
./backend/src/utils/auth.rs:        assert!(!api_key.is_empty());
./backend/src/utils/auth.rs:        // Validate API key
./backend/src/utils/auth.rs:        let validated_permissions = auth_manager.validate_api_key(&api_key).await?;
./backend/src/utils/auth.rs:        let hash = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        // Verify the password against the hash
./backend/src/utils/auth.rs:        let is_valid = AuthManager::verify_api_key(api_key, &hash)?;
./backend/src/utils/auth.rs:        // Verify that wrong password fails
./backend/src/utils/auth.rs:        let is_valid_wrong = AuthManager::verify_api_key("wrong_password", &hash)?;
./backend/src/utils/auth.rs:        // Hash the same password multiple times
./backend/src/utils/auth.rs:        let hash1 = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        let hash2 = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        let is_valid1 = AuthManager::verify_api_key(api_key, &hash1)?;
./backend/src/utils/auth.rs:        let is_valid2 = AuthManager::verify_api_key(api_key, &hash2)?;
./backend/src/utils/structured_logging.rs:    pub fn with_data(mut self, key: &str, value: &str) -> Self {
./backend/src/utils/structured_logging.rs:            .insert(key.to_string(), value.to_string());
./backend/src/utils/error_handling.rs:    pub fn get_string(value: &Value, key: &str) -> HiveResult<String> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid string field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_number(value: &Value, key: &str) -> HiveResult<f64> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid number field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_boolean(value: &Value, key: &str) -> HiveResult<bool> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid boolean field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_array<'a>(value: &'a Value, key: &str) -> HiveResult<Vec<&'a Value>> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid array field: {}", key),
./backend/src/utils/error_handling.rs:        key: &str,
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid object field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_optional_string(value: &Value, key: &str) -> Option<String> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:    pub fn get_optional_number(value: &Value, key: &str) -> Option<f64> {
./backend/src/utils/error_handling.rs:        value.get(key).and_then(|v| v.as_f64())
./backend/src/utils/error_handling.rs:    pub fn get_optional_boolean(value: &Value, key: &str) -> Option<bool> {
./backend/src/utils/error_handling.rs:        value.get(key).and_then(|v| v.as_bool())
./backend/src/utils/validate_centralized_error_handling.rs:    // Test that key error types exist and can be created
./backend/src/utils/error.rs:    #[error("Cache error: {operation}, key: {key}, reason: {reason}")]
./backend/src/utils/error.rs:        key: String,
./backend/src/utils/error.rs:    #[error("Cache miss: {key}")]
./backend/src/utils/error.rs:    CacheMiss { key: String },
./backend/src/utils/error.rs:    #[error("Environment configuration missing: {envname}, required_key: {requiredkey}")]
./backend/src/utils/error.rs:        requiredkey: String,
./backend/src/utils/error.rs:    #[error("Secret management failed: {secretname}, operation: {operation}")]
./backend/src/utils/error.rs:        secretname: String,
./backend/src/utils/error.rs:        "Configuration override conflict: {overridekey}, source1: {source1}, source2: {source2}"
./backend/src/utils/error.rs:        overridekey: String,
./backend/src/utils/error.rs:    pub fn with_info(mut self, key: &str, value: &str) -> Self {
./backend/src/utils/error.rs:            .insert(key.to_string(), value.to_string());
./backend/src/utils/error_recovery.rs:        let key = format!("{}:{}", context.component, context.operation);
./backend/src/utils/error_recovery.rs:        history.entry(key).or_insert_with(Vec::new).push(result);
./backend/src/utils/error_recovery.rs:        let key = format!("{}:{}", context.component, context.operation);
./backend/src/utils/error_recovery.rs:        if let Some(results) = history.get(&key) {
./backend/src/utils/error_recovery.rs:    fn safe_get(&self, key: &str) -> HiveResult<&serde_json::Value>;
./backend/src/utils/error_recovery.rs:    fn safe_get_str(&self, key: &str) -> HiveResult<&str>;
./backend/src/utils/error_recovery.rs:    fn safe_get_u64(&self, key: &str) -> HiveResult<u64>;
./backend/src/utils/error_recovery.rs:    fn safe_get_f64(&self, key: &str) -> HiveResult<f64>;
./backend/src/utils/error_recovery.rs:    fn safe_get_bool(&self, key: &str) -> HiveResult<bool>;
./backend/src/utils/error_recovery.rs:    fn safe_get(&self, key: &str) -> HiveResult<&serde_json::Value> {
./backend/src/utils/error_recovery.rs:        self.get(key).ok_or_else(|| HiveError::ValidationError {
./backend/src/utils/error_recovery.rs:            field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_str(&self, key: &str) -> HiveResult<&str> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_u64(&self, key: &str) -> HiveResult<u64> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_f64(&self, key: &str) -> HiveResult<f64> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_bool(&self, key: &str) -> HiveResult<bool> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/config.rs:        for (key, value) in override_config.component_health_scores {
./backend/src/utils/config.rs:            merged_health_scores.insert(key, value);
./backend/src/utils/config.rs:        for (key, value) in override_config.component_issues {
./backend/src/utils/config.rs:            merged_issues.insert(key, value);
./backend/src/utils/config.rs:        for (key, value) in override_config.component_recommendations {
./backend/src/utils/config.rs:            merged_recommendations.insert(key, value);
./backend/src/agents/collaborative_learning.rs:            &problem_data.keywords,
./backend/src/agents/collaborative_learning.rs:                format!("Collaborative solution for: {}", problem_data.keywords.join(", ")),
./backend/src/agents/collaborative_learning.rs:                problem_data.keywords.clone(),
./backend/src/agents/collaborative_learning.rs:        problem_keywords: &[String],
./backend/src/agents/collaborative_learning.rs:            for keyword in problem_keywords {
./backend/src/agents/collaborative_learning.rs:                if knowledge.content.to_lowercase().contains(&keyword.to_lowercase()) {
./backend/src/agents/collaborative_learning.rs:                    if tag.to_lowercase().contains(&keyword.to_lowercase()) {
./backend/src/agents/collaborative_learning.rs:        assert!(system.knowledge_base.contains_key(&knowledge_id));
./backend/src/agents/collaborative_learning.rs:        assert!(system.active_sessions.contains_key(&session_id));
./backend/src/agents/self_healing_swarm.rs:                    if !self.active_recoveries.contains_key(agent_id) {
./backend/src/agents/self_healing_swarm.rs:                    if self.active_recoveries.contains_key(agent_id) {
./backend/src/agents/self_healing_swarm.rs:        let strategy_key = format!("{:?}", strategy);
./backend/src/agents/self_healing_swarm.rs:            .get(&strategy_key)
./backend/src/agents/self_healing_swarm.rs:        self.learned_thresholds.insert(strategy_key, new_confidence);
./backend/src/agents/self_healing_swarm.rs:                let pattern_key =
./backend/src/agents/self_healing_swarm.rs:                    .get(&pattern_key)
./backend/src/agents/self_healing_swarm.rs:                self.learned_thresholds.insert(pattern_key, new_confidence);
./backend/src/agents/agent.rs:                let tokens: Vec<String> = insight
./backend/src/agents/agent.rs:                let sentiment = nlp_processor.analyze_sentiment(&tokens);
./backend/src/agents/agent.rs:                let pattern_key = format!(
./backend/src/agents/agent.rs:                    .get(&pattern_key)
./backend/src/agents/agent.rs:                    .insert(pattern_key, new_strength.clamp(-1.0, 1.0));
./backend/src/agents/skill_evolution.rs:            let agent_id = *agent_entry.key();
./backend/src/agents/skill_evolution.rs:                    .keys()
./backend/src/agents/simple_verification.rs:    KeywordPresence { keywords: Vec<String> },
./backend/src/agents/simple_verification.rs:                RuleType::KeywordPresence { keywords } => {
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_presence(
./backend/src/agents/simple_verification.rs:                        keywords,
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_absence(
./backend/src/agents/simple_verification.rs:                RuleType::KeywordPresence { keywords } => {
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_presence(
./backend/src/agents/simple_verification.rs:                        keywords,
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_absence(
./backend/src/agents/simple_verification.rs:                    tokens: output.split_whitespace().map(str::to_string).collect(),
./backend/src/agents/simple_verification.rs:                    keywords: Vec::new(),
./backend/src/agents/simple_verification.rs:                tokens: goal.split_whitespace().map(str::to_string).collect(),
./backend/src/agents/simple_verification.rs:                keywords: Vec::new(),
./backend/src/agents/simple_verification.rs:        let tokens: Vec<String> = output.split_whitespace().map(str::to_string).collect();
./backend/src/agents/simple_verification.rs:        let sentiment = self.nlp_processor.analyze_sentiment(&tokens);
./backend/src/agents/simple_verification.rs:    fn check_keyword_presence(
./backend/src/agents/simple_verification.rs:        keywords: &[String],
./backend/src/agents/simple_verification.rs:        let mut found_keywords = 0;
./backend/src/agents/simple_verification.rs:        for keyword in keywords {
./backend/src/agents/simple_verification.rs:            if output_lower.contains(&keyword.to_lowercase()) {
./backend/src/agents/simple_verification.rs:                found_keywords += 1;
./backend/src/agents/simple_verification.rs:        let score = f64::from(found_keywords) / keywords.len() as f64;
./backend/src/agents/simple_verification.rs:            let missing_keywords: Vec<String> = keywords
./backend/src/agents/simple_verification.rs:                .filter(|keyword| !output_lower.contains(&keyword.to_lowercase()))
./backend/src/agents/simple_verification.rs:                description: format!("Missing required keywords: {}", missing_keywords.join(", ")),
./backend/src/agents/simple_verification.rs:                suggestion: Some("Include all required keywords in the output".to_string()),
./backend/src/agents/simple_verification.rs:    fn check_keyword_absence(
./backend/src/agents/simple_verification.rs:        let tier_key = format!("{:?}", result.verification_tier);
./backend/src/agents/simple_verification.rs:        *metrics.tier_usage.entry(tier_key).or_insert(0) += 1;
./backend/src/agents/multimodal_agent.rs:            if text.keywords.iter().any(|k| k.contains("quality")) && data.quality_score < 0.6 {
./backend/src/agents/multimodal_agent.rs:        if input.to_lowercase().contains("password") && input.contains("=") {
./backend/src/agents/multimodal_agent.rs:                description: "Hardcoded password detected".to_string(),
./backend/src/agents/multimodal_agent.rs:            // Text quality based on sentiment and keyword richness
./backend/src/agents/multimodal_agent.rs:                              (text.keywords.len() as f64 / 10.0).min(1.0) * 0.3;
./backend/src/agents/multimodal_agent.rs:            let text_complexity = (text.keywords.len() as f64 / 20.0).min(1.0);
./backend/src/agents/multimodal_agent.rs:            let modality_key = format!("{:?}", modality);
./backend/src/agents/multimodal_agent.rs:            *self.performance_metrics.analyses_by_modality.entry(modality_key.clone()).or_insert(0) += 1;
./backend/src/agents/multimodal_agent.rs:            let current_avg = self.performance_metrics.avg_processing_time.get(&modality_key).copied().unwrap_or(0.0);
./backend/src/agents/multimodal_agent.rs:            let count = self.performance_metrics.analyses_by_modality[&modality_key] as f64;
./backend/src/agents/multimodal_agent.rs:            self.performance_metrics.avg_processing_time.insert(modality_key, new_avg);
./backend/src/agents/verification_engine.rs:        self.strategies.keys().cloned().collect()
./backend/src/agents/verification_engine.rs:        let goal_tokens: Vec<String> = original_goal.split_whitespace()
./backend/src/agents/verification_engine.rs:        let result_tokens: Vec<String> = result_output.split_whitespace()
./backend/src/agents/verification_engine.rs:        let goal_sentiment = self.nlp_processor.analyze_sentiment(&goal_tokens);
./backend/src/agents/verification_engine.rs:        let result_sentiment = self.nlp_processor.analyze_sentiment(&result_tokens);
./backend/src/agents/verification_engine.rs:        // Calculate keyword overlap
./backend/src/agents/verification_engine.rs:        let goal_keywords: std::collections::HashSet<_> = goal_tokens.iter().collect();
./backend/src/agents/verification_engine.rs:        let result_keywords: std::collections::HashSet<_> = result_tokens.iter().collect();
./backend/src/agents/verification_engine.rs:        let intersection_size = goal_keywords.intersection(&result_keywords).count();
./backend/src/agents/verification_engine.rs:        let union_size = goal_keywords.union(&result_keywords).count();
./backend/src/agents/verification_engine.rs:        let keyword_overlap = if union_size > 0 {
./backend/src/agents/verification_engine.rs:        let alignment_score = (sentiment_alignment * 0.4) + (keyword_overlap * 0.6);
./backend/src/agents/verification_engine.rs:        debug!("Goal alignment analysis: sentiment={:.3}, keywords={:.3}, total={:.3}",
./backend/src/agents/verification_engine.rs:               sentiment_alignment, keyword_overlap, alignment_score);
./backend/src/agents/memory.rs:            learned_strategy: Some("focus on key patterns".to_string()),
./backend/src/agents/adaptive_verification.rs:            .flat_map(|outcome| outcome.rule_thresholds_used.keys())
./backend/src/agents/adaptive_verification.rs:            .filter(|outcome| outcome.rule_thresholds_used.contains_key(rule_id))
./backend/src/agents/agent_evolution.rs:        let species_key = self.determine_species(&genome);
./backend/src/agents/agent_evolution.rs:            .entry(species_key)
./backend/src/agents/agent_evolution.rs:            let species_key = self.determine_species(genome);
./backend/src/agents/agent_evolution.rs:            let species_size = self.species_registry.get(&species_key).map_or(1, |v| v.len());
./backend/src/agents/agent_evolution.rs:        assert!(system.genomes.contains_key(&agent.id));
./backend/src/agents/verification_strategies.rs:        let tokens: Vec<String> = original_goal.split_whitespace()
./backend/src/agents/verification_strategies.rs:        // Extract key verbs (action words)
./backend/src/agents/verification_strategies.rs:        let actions: Vec<String> = tokens.iter()
./backend/src/agents/verification_strategies.rs:            .filter(|token| action_words.contains(&token.as_str()))
./backend/src/agents/verification_strategies.rs:        // Extract key nouns (target objects)
./backend/src/agents/verification_strategies.rs:        let targets: Vec<String> = tokens.iter()
./backend/src/agents/verification_strategies.rs:            .filter(|token| target_indicators.contains(&token.as_str()))
./backend/src/communication/protocols.rs:    pub fn with_metadata(mut self, key: String, value: serde_json::Value) -> Self {
./backend/src/communication/protocols.rs:        self.metadata.insert(key, value);
./backend/src/communication/patterns.rs:    pub async fn get_connection(&self, key: &str) -> CommunicationResult<CommunicationChannel> {
./backend/src/communication/patterns.rs:        if let Some(channel) = connections.get(key) {
./backend/src/communication/patterns.rs:            reason: format!("Connection not found for key: {}", key),
./backend/src/communication/patterns.rs:    pub async fn add_connection(&self, key: String, channel: CommunicationChannel) {
./backend/src/communication/patterns.rs:        connections.insert(key, channel);
./backend/src/communication/patterns.rs:    pub async fn remove_connection(&self, key: &str) {
./backend/src/communication/patterns.rs:        connections.remove(key);
./backend/src/communication/mcp.rs:            "keywords": text.split_whitespace().take(5).collect::<Vec<_>>(),
./backend/src/neural/nlp.rs:    pub keywords: Vec<String>,
./backend/src/neural/nlp.rs:        let tokens = self.tokenize(text);
./backend/src/neural/nlp.rs:        let semantic_vector = self.generate_semantic_vector(&tokens).await;
./backend/src/neural/nlp.rs:        let sentiment = self.analyze_sentiment(&tokens);
./backend/src/neural/nlp.rs:        let keywords = self.extract_keywords(text, 5).await;
./backend/src/neural/nlp.rs:        let patterns = self.identify_patterns(&tokens).await;
./backend/src/neural/nlp.rs:            tokens,
./backend/src/neural/nlp.rs:            keywords,
./backend/src/neural/nlp.rs:        self.update_vocabulary(&processed_input.tokens, success)
./backend/src/neural/nlp.rs:        self.update_vocabulary(&processed_output.tokens, success)
./backend/src/neural/nlp.rs:                    pattern.keywords.join(" "),
./backend/src/neural/nlp.rs:                    pattern.keywords.join(" ")
./backend/src/neural/nlp.rs:    fn tokenize(&self, text: &str) -> Vec<String> {
./backend/src/neural/nlp.rs:    async fn generate_semantic_vector(&self, tokens: &[String]) -> SemanticVector {
./backend/src/neural/nlp.rs:        for (i, token) in tokens.iter().enumerate() {
./backend/src/neural/nlp.rs:            let weight = vocabulary.get(token).copied().unwrap_or(0.1);
./backend/src/neural/nlp.rs:            let index = (token.len() + i) % dimensions.len();
./backend/src/neural/nlp.rs:    pub fn analyze_sentiment(&self, tokens: &[String]) -> f64 {
./backend/src/neural/nlp.rs:        let positive_count = tokens
./backend/src/neural/nlp.rs:            .filter(|token| positive_words.contains(&token.as_str()))
./backend/src/neural/nlp.rs:        let negative_count = tokens
./backend/src/neural/nlp.rs:            .filter(|token| negative_words.contains(&token.as_str()))
./backend/src/neural/nlp.rs:    pub async fn extract_keywords(&self, text: &str, limit: usize) -> Vec<String> {
./backend/src/neural/nlp.rs:        let tokens: Vec<String> = text
./backend/src/neural/nlp.rs:        let mut keyword_scores: Vec<(String, f64)> = tokens
./backend/src/neural/nlp.rs:            .map(|token| {
./backend/src/neural/nlp.rs:                let score = vocabulary.get(token).copied().unwrap_or(0.1);
./backend/src/neural/nlp.rs:                (token.clone(), score)
./backend/src/neural/nlp.rs:        keyword_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
./backend/src/neural/nlp.rs:        keyword_scores
./backend/src/neural/nlp.rs:    async fn identify_patterns(&self, tokens: &[String]) -> Vec<Uuid> {
./backend/src/neural/nlp.rs:                .keywords
./backend/src/neural/nlp.rs:                .filter(|keyword| tokens.contains(keyword))
./backend/src/neural/nlp.rs:            if matches as f64 / pattern.keywords.len() as f64 > 0.5 {
./backend/src/neural/nlp.rs:    async fn update_vocabulary(&self, tokens: &[String], success: bool) {
./backend/src/neural/nlp.rs:        for token in tokens {
./backend/src/neural/nlp.rs:            let current_score = vocabulary.get(token).copied().unwrap_or(0.5);
./backend/src/neural/nlp.rs:            vocabulary.insert(token.clone(), new_score);
./backend/src/neural/nlp.rs:            keywords: input.keywords.clone(),
./backend/src/neural/nlp.rs:        let key = input.keywords.join("_");
./backend/src/neural/nlp.rs:        patterns.insert(key, pattern);
./backend/src/neural/nlp.rs:            keywords: input.keywords.clone(),
./backend/src/neural/nlp.rs:        let key = input.keywords.join("_");
./backend/src/neural/nlp.rs:        patterns.insert(key, pattern);
./backend/src/neural/nlp.rs:                input.keywords.join(" "),
./backend/src/neural/nlp.rs:                output.keywords.join(" ")
./backend/src/neural/nlp.rs:            .keywords
./backend/src/neural/nlp.rs:            .filter(|keyword| processed.keywords.contains(keyword))
./backend/src/neural/nlp.rs:        matches as f64 / pattern.keywords.len() as f64 > 0.3
./backend/src/neural/nlp.rs:        let tokens = self.tokenize(text);
./backend/src/neural/nlp.rs:        self.generate_semantic_vector(&tokens).await
./backend/src/neural/nlp.rs:    pub tokens: Vec<String>,
./backend/src/neural/nlp.rs:    pub keywords: Vec<String>,
./backend/src/neural/adaptive_learning.rs:        features.push(processed_text.tokens.len() as f64);
./backend/src/neural/adaptive_learning.rs:        features.push(processed_text.keywords.len() as f64);
./backend/src/core/hive/metrics_collection/events.rs:                .max_by_key(|(_, &count)| count)
./backend/src/core/hive/metrics_collection/collector.rs:    /// and alerting purposes. Uses string keys for flexibility.
./backend/src/core/hive/metrics_collection/collector.rs:        let event_key = format!("agent_{}", event_type);
./backend/src/core/hive/metrics_collection/collector.rs:            *counters.entry(event_key).or_insert(0) += 1;
./backend/src/core/hive/task_management_legacy/analytics.rs:        // Extract key metrics
./backend/src/core/hive/agent_management/lifecycle.rs:                let agent_id = *entry.key();
./backend/src/core/hive/agent_management/metrics.rs:        let metrics_key = CacheKey::AgentMetrics(agent_id);
./backend/src/core/hive/agent_management/metrics.rs:        if let Err(e) = self.cache_manager.invalidate_key(&metrics_key).await {
./backend/src/core/hive/agent_management/metrics.rs:            .map(|entry| (*entry.key(), entry.value().performance_score))
./backend/src/core/hive/agent_management/registry.rs:        let cache_key = CacheKey::Agent(agent_id);
./backend/src/core/hive/agent_management/registry.rs:        if let Err(e) = self.cache_manager.set_cached(cache_key, cache_entry).await {
./backend/src/core/hive/agent_management/registry.rs:        let cache_key = CacheKey::Agent(agent_id);
./backend/src/core/hive/agent_management/registry.rs:        if let Some(agent) = self.cache_manager.get_cached(&cache_key).await {
./backend/src/core/hive/agent_management/registry.rs:            if let Err(e) = self.cache_manager.set_cached(cache_key, cache_entry).await {
./backend/src/core/hive/agent_management/registry.rs:            .map(|entry| (*entry.key(), entry.value().clone()))
./backend/src/core/hive/agent_management/registry.rs:        self.agents.contains_key(&agent_id)
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("work_stealing_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("learning_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("swarm_coordination_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("metrics_collection_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("resource_monitoring_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("work_stealing_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("learning_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("swarm_coordination_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("metrics_collection_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("resource_monitoring_interval_ms"));
./backend/src/core/hive/task_management/task_executor.rs:            .keys()
./backend/src/core/hive/task_management/mod.rs:// Re-export key components
./backend/src/core/auto_scaling.rs:                candidates.sort_by_key(|(_, agent)| agent.memory.experiences.len());
./backend/src/core/auto_scaling.rs:                candidates.sort_by_key(|(_, agent)| agent.capabilities.len());
./backend/src/core/swarm_intelligence.rs:            let type_key = std::mem::discriminant(&agent.agent_type);
./backend/src/core/swarm_intelligence.rs:            if !agent_types_used.contains(&type_key) || selected.len() < 3 {
./backend/src/core/swarm_intelligence.rs:                agent_types_used.insert(type_key);
./backend/src/init.rs:    // Load encryption key from secure sources
./backend/src/init.rs:    let encryption_key = PersistenceManager::load_encryption_key();
./backend/src/init.rs:    let encryption_enabled = encryption_key.is_some();
./backend/src/init.rs:        info!("🔐 Encryption enabled with secure key management");
./backend/src/init.rs:        encryption_key,
./backend/src/tasks/work_stealing_queue.rs:            let agent_id = *entry.key();
./backend/src/tasks/work_stealing_queue.rs:            let agent_id = *entry.key();
./backend/src/tasks/task.rs:    pub fn with_context(mut self, key: String, value: String) -> Self {
./backend/src/tasks/task.rs:        self.context.insert(key, value);
./backend/src/infrastructure/cached_query.rs:/// Cache key types for different data entities
./backend/src/infrastructure/cached_query.rs:    /// Custom key for flexible caching
./backend/src/infrastructure/cached_query.rs:            CacheKey::SystemStatus(key) => write!(f, "system_status:{}", key),
./backend/src/infrastructure/cached_query.rs:            CacheKey::PerformanceMetrics(key) => write!(f, "performance_metrics:{}", key),
./backend/src/infrastructure/cached_query.rs:            CacheKey::Custom(key) => write!(f, "custom:{}", key),
./backend/src/infrastructure/cached_query.rs:        key: CacheKey,
./backend/src/infrastructure/cached_query.rs:        if let Some(cached_value) = self.get_cached(&key).await {
./backend/src/infrastructure/cached_query.rs:            debug!("Cache hit for key: {}", key);
./backend/src/infrastructure/cached_query.rs:        debug!("Cache miss for key: {}, executing query", key);
./backend/src/infrastructure/cached_query.rs:        self.set_cached(key.clone(), cache_entry).await?;
./backend/src/infrastructure/cached_query.rs:    pub async fn get_cached<T>(&self, key: &CacheKey) -> Option<T>
./backend/src/infrastructure/cached_query.rs:        let cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        if let Some(value) = self.cache_manager.get(&cache_key).await {
./backend/src/infrastructure/cached_query.rs:                if !self.is_entry_valid(&entry, key).await {
./backend/src/infrastructure/cached_query.rs:                    self.invalidate_key(key).await;
./backend/src/infrastructure/cached_query.rs:    pub async fn set_cached<T>(&self, key: CacheKey, entry: CacheEntry<T>) -> HiveResult<()>
./backend/src/infrastructure/cached_query.rs:        let cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        self.cache_manager.set(cache_key, cache_value).await?;
./backend/src/infrastructure/cached_query.rs:            tracker.insert(key, entry.version);
./backend/src/infrastructure/cached_query.rs:    /// Invalidate a specific cache key
./backend/src/infrastructure/cached_query.rs:    pub async fn invalidate_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cached_query.rs:        let _cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        debug!("Invalidating cache key: {}", key);
./backend/src/infrastructure/cached_query.rs:            tracker.remove(key);
./backend/src/infrastructure/cached_query.rs:        // Get all keys that depend on this dependency
./backend/src/infrastructure/cached_query.rs:        let keys_to_invalidate: Vec<CacheKey> = {
./backend/src/infrastructure/cached_query.rs:            tracker.keys().cloned().collect()
./backend/src/infrastructure/cached_query.rs:        for key in keys_to_invalidate {
./backend/src/infrastructure/cached_query.rs:            if let Some(cached_value) = self.cache_manager.get(&key.to_string()).await {
./backend/src/infrastructure/cached_query.rs:                                    self.invalidate_key(&key).await;
./backend/src/infrastructure/cached_query.rs:    /// Bulk invalidate multiple keys
./backend/src/infrastructure/cached_query.rs:    pub async fn invalidate_keys(&self, keys: &[CacheKey]) {
./backend/src/infrastructure/cached_query.rs:        for key in keys {
./backend/src/infrastructure/cached_query.rs:            self.invalidate_key(key).await;
./backend/src/infrastructure/cached_query.rs:    pub async fn warm_cache<F, Fut, T>(&self, keys: Vec<CacheKey>, fetcher: F) -> HiveResult<()>
./backend/src/infrastructure/cached_query.rs:        info!("Starting cache warming for {} keys", keys.len());
./backend/src/infrastructure/cached_query.rs:        for key in keys {
./backend/src/infrastructure/cached_query.rs:            let _key_clone = key.clone();
./backend/src/infrastructure/cached_query.rs:            debug!("Would prefetch data for key: {}", key);
./backend/src/infrastructure/cached_query.rs:    async fn is_entry_valid<T>(&self, entry: &CacheEntry<T>, key: &CacheKey) -> bool {
./backend/src/infrastructure/cached_query.rs:                if let Some(current_version) = tracker.get(key) {
./backend/src/infrastructure/cached_query.rs:                    if !tracker.contains_key(dep) {
./backend/src/infrastructure/cached_query.rs:        query_key: String,
./backend/src/infrastructure/cached_query.rs:            if let Some(execution) = deduplication.get(&query_key) {
./backend/src/infrastructure/cached_query.rs:            query_key: query_key.clone(),
./backend/src/infrastructure/cached_query.rs:            deduplication.insert(query_key.clone(), execution.clone());
./backend/src/infrastructure/cached_query.rs:            analyzer.record_execution(&query_key, execution_time);
./backend/src/infrastructure/cached_query.rs:        let query_key_clone = query_key.clone();
./backend/src/infrastructure/cached_query.rs:            deduplication.remove(&query_key_clone);
./backend/src/infrastructure/cached_query.rs:    ($cache_manager:expr, $key:expr, $dependencies:expr, $query:block) => {
./backend/src/infrastructure/cached_query.rs:        $cache_manager.execute_cached_query($key, $dependencies, || async move $query).await
./backend/src/infrastructure/cached_query.rs:    ($cache_manager:expr, $query_key:expr, $query:block) => {
./backend/src/infrastructure/cached_query.rs:        $cache_manager.execute_deduplicated_query($query_key, || async move $query).await
./backend/src/infrastructure/cached_query.rs:        let result1 = cached_query!(cache_manager, key.clone(), dependencies.clone(), {
./backend/src/infrastructure/cached_query.rs:        let result2 = cached_query!(cache_manager, key, dependencies, {
./backend/src/infrastructure/cached_query.rs:        let _ = cached_query!(cache_manager, key.clone(), dependencies.clone(), {
./backend/src/infrastructure/cached_query.rs:        // Invalidate the key
./backend/src/infrastructure/cached_query.rs:        cache_manager.invalidate_key(&key).await;
./backend/src/infrastructure/cached_query.rs:        let result = cached_query!(cache_manager, key, dependencies, {
./backend/src/infrastructure/cache_warming.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_warming.rs:    pub related_keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:    startup_keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:    pub total_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub warmed_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub failed_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_warming.rs:                startup_keys: Vec::new(),
./backend/src/infrastructure/cache_warming.rs:    /// Record access pattern for a cache key
./backend/src/infrastructure/cache_warming.rs:    pub async fn record_access(&self, key: &CacheKey, context: Option<HashMap<String, String>>) {
./backend/src/infrastructure/cache_warming.rs:            .entry(key.clone())
./backend/src/infrastructure/cache_warming.rs:                key: key.clone(),
./backend/src/infrastructure/cache_warming.rs:                related_keys: Vec::new(),
./backend/src/infrastructure/cache_warming.rs:            candidates.insert(key.clone());
./backend/src/infrastructure/cache_warming.rs:            self.trigger_prefetching(key, context.unwrap_or_default())
./backend/src/infrastructure/cache_warming.rs:        for key in candidates {
./backend/src/infrastructure/cache_warming.rs:            match self.warm_key(&key).await {
./backend/src/infrastructure/cache_warming.rs:                    warn!("Failed to warm cache key {}: {}", key, e);
./backend/src/infrastructure/cache_warming.rs:        info!("Cache warming completed, warmed {} keys", warmed_count);
./backend/src/infrastructure/cache_warming.rs:            match self.prefetch_key(&item.key, item.context).await {
./backend/src/infrastructure/cache_warming.rs:                    warn!("Failed to prefetch cache key {}: {}", item.key, e);
./backend/src/infrastructure/cache_warming.rs:    pub async fn add_warming_candidate(&self, key: CacheKey) {
./backend/src/infrastructure/cache_warming.rs:        candidates.insert(key);
./backend/src/infrastructure/cache_warming.rs:    /// Configure startup warming keys
./backend/src/infrastructure/cache_warming.rs:        keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:        startup_data.startup_keys = keys;
./backend/src/infrastructure/cache_warming.rs:        if startup_data.startup_keys.is_empty() {
./backend/src/infrastructure/cache_warming.rs:            "Starting startup cache warming for {} keys",
./backend/src/infrastructure/cache_warming.rs:            startup_data.startup_keys.len()
./backend/src/infrastructure/cache_warming.rs:            total_keys: startup_data.startup_keys.len(),
./backend/src/infrastructure/cache_warming.rs:            warmed_keys: 0,
./backend/src/infrastructure/cache_warming.rs:            failed_keys: 0,
./backend/src/infrastructure/cache_warming.rs:        // Group keys by priority
./backend/src/infrastructure/cache_warming.rs:        let mut keys_by_priority: HashMap<WarmingPriority, Vec<CacheKey>> = HashMap::new();
./backend/src/infrastructure/cache_warming.rs:        for key in &startup_data.startup_keys {
./backend/src/infrastructure/cache_warming.rs:            let priority = self.determine_key_priority(key).await;
./backend/src/infrastructure/cache_warming.rs:            keys_by_priority
./backend/src/infrastructure/cache_warming.rs:                .push(key.clone());
./backend/src/infrastructure/cache_warming.rs:        // Warm keys in priority order
./backend/src/infrastructure/cache_warming.rs:            if let Some(keys) = keys_by_priority.get(priority) {
./backend/src/infrastructure/cache_warming.rs:                info!("Warming {} keys with {:?} priority", keys.len(), priority);
./backend/src/infrastructure/cache_warming.rs:                for key in keys {
./backend/src/infrastructure/cache_warming.rs:                    match self.warm_key_with_fetcher(key, fetcher.clone()).await {
./backend/src/infrastructure/cache_warming.rs:                            progress.warmed_keys += 1;
./backend/src/infrastructure/cache_warming.rs:                            progress.failed_keys += 1;
./backend/src/infrastructure/cache_warming.rs:                            warn!("Failed to warm startup key {}: {}", key, e);
./backend/src/infrastructure/cache_warming.rs:            progress.warmed_keys, progress.failed_keys
./backend/src/infrastructure/cache_warming.rs:    /// Determine priority for a cache key
./backend/src/infrastructure/cache_warming.rs:    async fn determine_key_priority(&self, key: &CacheKey) -> WarmingPriority {
./backend/src/infrastructure/cache_warming.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/cache_warming.rs:    /// Warm key with custom fetcher
./backend/src/infrastructure/cache_warming.rs:    async fn warm_key_with_fetcher<F, Fut>(&self, key: &CacheKey, fetcher: F) -> HiveResult<()>
./backend/src/infrastructure/cache_warming.rs:            .get_cached::<serde_json::Value>(key)
./backend/src/infrastructure/cache_warming.rs:        let data = fetcher(key.clone()).await?;
./backend/src/infrastructure/cache_warming.rs:        let dependencies = vec![]; // Could be determined based on key relationships
./backend/src/infrastructure/cache_warming.rs:            .set_cached(key.clone(), cache_entry)
./backend/src/infrastructure/cache_warming.rs:        debug!("Successfully warmed cache key: {}", key);
./backend/src/infrastructure/cache_warming.rs:                    key: CacheKey::Custom(recommendation.key.clone()),
./backend/src/infrastructure/cache_warming.rs:                "startup_keys_count": startup_data.startup_keys.len(),
./backend/src/infrastructure/cache_warming.rs:    pub async fn remove_warming_candidate(&self, key: &CacheKey) {
./backend/src/infrastructure/cache_warming.rs:        candidates.remove(key);
./backend/src/infrastructure/cache_warming.rs:        // Find top accessed keys
./backend/src/infrastructure/cache_warming.rs:        let top_keys = top_patterns
./backend/src/infrastructure/cache_warming.rs:                    "key": p.key.to_string(),
./backend/src/infrastructure/cache_warming.rs:            "top_accessed_keys": top_keys,
./backend/src/infrastructure/cache_warming.rs:    async fn warm_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_warming.rs:            .get_cached::<serde_json::Value>(key)
./backend/src/infrastructure/cache_warming.rs:        debug!("Would warm cache key: {}", key);
./backend/src/infrastructure/cache_warming.rs:        candidates.remove(key);
./backend/src/infrastructure/cache_warming.rs:    async fn prefetch_key(
./backend/src/infrastructure/cache_warming.rs:        key: &CacheKey,
./backend/src/infrastructure/cache_warming.rs:        // Similar to warm_key, we can't actually prefetch without fetchers
./backend/src/infrastructure/cache_warming.rs:            "Would prefetch cache key: {} with context {:?}",
./backend/src/infrastructure/cache_warming.rs:            key, context
./backend/src/infrastructure/cache_warming.rs:    async fn trigger_prefetching(&self, key: &CacheKey, context: HashMap<String, String>) {
./backend/src/infrastructure/cache_warming.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/cache_warming.rs:                        key: key.clone(),
./backend/src/infrastructure/cache_warming.rs:            // Find keys with high access frequency
./backend/src/infrastructure/cache_warming.rs:            let mut high_frequency_keys: Vec<_> = patterns
./backend/src/infrastructure/cache_warming.rs:                .map(|p| p.key.clone())
./backend/src/infrastructure/cache_warming.rs:            high_frequency_keys.sort_by(|a, b| {
./backend/src/infrastructure/cache_warming.rs:            Ok(high_frequency_keys.into_iter().take(50).collect())
./backend/src/infrastructure/cache_warming.rs:        /// Predict keys that will be accessed soon
./backend/src/infrastructure/cache_warming.rs:            let mut predicted_keys: Vec<_> = patterns
./backend/src/infrastructure/cache_warming.rs:                .map(|p| p.key.clone())
./backend/src/infrastructure/cache_warming.rs:            predicted_keys.sort_by(|a, b| {
./backend/src/infrastructure/cache_warming.rs:            Ok(predicted_keys)
./backend/src/infrastructure/cache_warming.rs:        engine.record_access(&key1, None).await;
./backend/src/infrastructure/cache_warming.rs:        engine.record_access(&key2, None).await;
./backend/src/infrastructure/cache_warming.rs:        assert!(patterns.contains_key(&key1));
./backend/src/infrastructure/cache_warming.rs:        assert!(patterns.contains_key(&key2));
./backend/src/infrastructure/security_middleware.rs:            if let Some(token) = auth_str.strip_prefix("Bearer ") {
./backend/src/infrastructure/security_middleware.rs:                match auth_manager.validate_token(token).await {
./backend/src/infrastructure/security_middleware.rs:    // Try API key authentication
./backend/src/infrastructure/security_middleware.rs:    if let Some(api_key_header) = headers.get("x-api-key") {
./backend/src/infrastructure/security_middleware.rs:        if let Ok(api_key) = api_key_header.to_str() {
./backend/src/infrastructure/security_middleware.rs:            match auth_manager.validate_api_key(api_key).await {
./backend/src/infrastructure/security_middleware.rs:                    // Check if API key has required permission
./backend/src/infrastructure/security_middleware.rs:                            // Create pseudo-claims for API key
./backend/src/infrastructure/security_middleware.rs:                                sub: "api_key".to_string(),
./backend/src/infrastructure/security_middleware.rs:                                session_id: "api_key_session".to_string(),
./backend/src/infrastructure/security_middleware.rs:                    // API key is valid and no specific permission required
./backend/src/infrastructure/security_middleware.rs:                        sub: "api_key".to_string(),
./backend/src/infrastructure/security_middleware.rs:                        session_id: "api_key_session".to_string(),
./backend/src/infrastructure/cpu_optimizer.rs:                    .min_by_key(|(_, w)| w.active_tasks)
./backend/src/infrastructure/cache_invalidation.rs:    /// Pattern to match cache keys (supports regex)
./backend/src/infrastructure/cache_invalidation.rs:    pub key_pattern: String,
./backend/src/infrastructure/cache_invalidation.rs:    /// Forward dependencies: key -> dependent keys
./backend/src/infrastructure/cache_invalidation.rs:    /// Reverse dependencies: key -> keys that depend on it
./backend/src/infrastructure/cache_invalidation.rs:    pub fn add_dependency(&mut self, key: CacheKey, depends_on: CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        // Forward: key depends on depends_on
./backend/src/infrastructure/cache_invalidation.rs:            .entry(key.clone())
./backend/src/infrastructure/cache_invalidation.rs:        // Reverse: depends_on is depended on by key
./backend/src/infrastructure/cache_invalidation.rs:            .insert(key);
./backend/src/infrastructure/cache_invalidation.rs:    pub fn remove_dependency(&mut self, key: &CacheKey, depends_on: &CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        if let Some(deps) = self.forward_deps.get_mut(key) {
./backend/src/infrastructure/cache_invalidation.rs:            rev_deps.remove(key);
./backend/src/infrastructure/cache_invalidation.rs:    /// Get all keys that depend on the given key
./backend/src/infrastructure/cache_invalidation.rs:    pub fn get_dependents(&self, key: &CacheKey) -> HashSet<CacheKey> {
./backend/src/infrastructure/cache_invalidation.rs:        self.reverse_deps.get(key).cloned().unwrap_or_default()
./backend/src/infrastructure/cache_invalidation.rs:    /// Get all keys that the given key depends on
./backend/src/infrastructure/cache_invalidation.rs:    pub fn get_dependencies(&self, key: &CacheKey) -> HashSet<CacheKey> {
./backend/src/infrastructure/cache_invalidation.rs:        self.forward_deps.get(key).cloned().unwrap_or_default()
./backend/src/infrastructure/cache_invalidation.rs:    /// Last invalidation times for keys
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate a single cache key
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:        debug!("Invalidating cache key: {}", key);
./backend/src/infrastructure/cache_invalidation.rs:        // Invalidate the key itself
./backend/src/infrastructure/cache_invalidation.rs:        self.cache_manager.invalidate_key(key).await;
./backend/src/infrastructure/cache_invalidation.rs:        self.handle_cascade_invalidation(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate multiple keys with batching
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_keys(&self, keys: &[CacheKey]) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_keys_batched(keys, *batch_size).await
./backend/src/infrastructure/cache_invalidation.rs:                for key in keys {
./backend/src/infrastructure/cache_invalidation.rs:                    self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate keys based on a pattern
./backend/src/infrastructure/cache_invalidation.rs:        // For now, just invalidate keys that contain the pattern
./backend/src/infrastructure/cache_invalidation.rs:        let keys_to_check: Vec<CacheKey> = {
./backend/src/infrastructure/cache_invalidation.rs:        for key in keys_to_check {
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys matching pattern: {}",
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn add_dependency(&self, key: CacheKey, depends_on: CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key, depends_on);
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn remove_dependency(&self, key: &CacheKey, depends_on: &CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        graph.remove_dependency(key, depends_on);
./backend/src/infrastructure/cache_invalidation.rs:        // Invalidate keys that exceed threshold in current window
./backend/src/infrastructure/cache_invalidation.rs:        let keys_to_check: Vec<CacheKey> = state.invalidation_counts.keys().cloned().collect();
./backend/src/infrastructure/cache_invalidation.rs:        for key in keys_to_check {
./backend/src/infrastructure/cache_invalidation.rs:            if let Some(counts) = state.invalidation_counts.get(&key) {
./backend/src/infrastructure/cache_invalidation.rs:                    self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:                    // Reset the window for this key
./backend/src/infrastructure/cache_invalidation.rs:                    state.invalidation_counts.remove(&key);
./backend/src/infrastructure/cache_invalidation.rs:                    state.last_invalidation_times.insert(key, now);
./backend/src/infrastructure/cache_invalidation.rs:        // Get all cache keys (this would need to be implemented in the cache manager)
./backend/src/infrastructure/cache_invalidation.rs:        let all_keys: Vec<CacheKey> = vec![]; // Placeholder - would need cache manager method
./backend/src/infrastructure/cache_invalidation.rs:        for key in all_keys {
./backend/src/infrastructure/cache_invalidation.rs:            let age = if let Some(last_invalidation) = state.age_distribution.get(&key) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:                state.age_distribution.insert(key, Duration::from_secs(0));
./backend/src/infrastructure/cache_invalidation.rs:        // Get all cache keys (this would need to be implemented in the cache manager)
./backend/src/infrastructure/cache_invalidation.rs:        let all_keys: Vec<CacheKey> = vec![]; // Placeholder - would need cache manager method
./backend/src/infrastructure/cache_invalidation.rs:        for key in all_keys {
./backend/src/infrastructure/cache_invalidation.rs:            if regex.is_match(&key.to_string()) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys matching regex pattern: {}",
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_by_access_pattern(&self, key: &CacheKey) -> HiveResult<bool> {
./backend/src/infrastructure/cache_invalidation.rs:            // Check if key matches the pattern
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(&rule.base_rule.key_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                        self.check_access_pattern_condition(key, condition).await;
./backend/src/infrastructure/cache_invalidation.rs:                        self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:        _key: &CacheKey,
./backend/src/infrastructure/cache_invalidation.rs:        for (key, size) in cache_sizes {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys exceeding size threshold: {} bytes",
./backend/src/infrastructure/cache_invalidation.rs:            key_pattern: "temp_*".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:            key_pattern: "stale_*".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                .invalidate_by_pattern(&recommendation.key_pattern)
./backend/src/infrastructure/cache_invalidation.rs:                "Applied recommendation: {} - invalidated {} keys",
./backend/src/infrastructure/cache_invalidation.rs:            let keys = pending_invalidations.drain().collect();
./backend/src/infrastructure/cache_invalidation.rs:            keys
./backend/src/infrastructure/cache_invalidation.rs:            for key in &pending {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    async fn handle_cascade_invalidation(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:        let dependents = graph.get_dependents(key);
./backend/src/infrastructure/cache_invalidation.rs:                "Invalidating {} dependent keys for: {}",
./backend/src/infrastructure/cache_invalidation.rs:                dependents_count, key
./backend/src/infrastructure/cache_invalidation.rs:                self.cache_manager.invalidate_key(dependent).await;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate keys in batches
./backend/src/infrastructure/cache_invalidation.rs:    async fn invalidate_keys_batched(
./backend/src/infrastructure/cache_invalidation.rs:        keys: &[CacheKey],
./backend/src/infrastructure/cache_invalidation.rs:        for chunk in keys.chunks(batch_size) {
./backend/src/infrastructure/cache_invalidation.rs:            for key in chunk {
./backend/src/infrastructure/cache_invalidation.rs:                pending.insert(key.clone());
./backend/src/infrastructure/cache_invalidation.rs:    /// Check if a key should be invalidated based on rules
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn should_invalidate(&self, key: &CacheKey) -> bool {
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(&rule.key_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                    if key.to_string().contains(dep_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn get_dependency_info(&self, key: &CacheKey) -> DependencyInfo {
./backend/src/infrastructure/cache_invalidation.rs:            key: key.clone(),
./backend/src/infrastructure/cache_invalidation.rs:            depends_on: graph.get_dependencies(key).into_iter().collect(),
./backend/src/infrastructure/cache_invalidation.rs:            depended_by: graph.get_dependents(key).into_iter().collect(),
./backend/src/infrastructure/cache_invalidation.rs:/// Dependency information for a cache key
./backend/src/infrastructure/cache_invalidation.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_invalidation.rs:    pub key_pattern: String,
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![CacheKey::Agent(agent_id), CacheKey::AgentMetrics(agent_id)];
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:        // This would need to be implemented to get all agent keys
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "agent".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "agent_metrics".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![CacheKey::Task(task_id), CacheKey::TaskMetrics(task_id)];
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "task".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "task_metrics".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:        let key1 = CacheKey::Agent(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        let key2 = CacheKey::Task(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        let key3 = CacheKey::AgentMetrics(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        // key1 depends on key2
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key1.clone(), key2.clone());
./backend/src/infrastructure/cache_invalidation.rs:        // key3 depends on key1
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key3.clone(), key1.clone());
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependencies(&key1).contains(&key2));
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependents(&key1).contains(&key3));
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependents(&key2).contains(&key1));
./backend/src/infrastructure/cache_invalidation.rs:        let dep_key = CacheKey::Custom("dep_key".to_string());
./backend/src/infrastructure/cache_invalidation.rs:            .add_dependency(key.clone(), dep_key.clone())
./backend/src/infrastructure/cache_invalidation.rs:        invalidation_manager.invalidate_key(&dep_key).await?;
./backend/src/infrastructure/cache_invalidation.rs:        // Check that dependent key was also invalidated
./backend/src/infrastructure/connection_pool.rs:    pub async fn get(&self, key: &str) -> Option<CachedResponse> {
./backend/src/infrastructure/connection_pool.rs:        if let Some(response) = cache.get(key) {
./backend/src/infrastructure/connection_pool.rs:                cache.remove(key);
./backend/src/infrastructure/connection_pool.rs:    pub async fn set(&self, key: String, data: Vec<u8>, content_type: String) {
./backend/src/infrastructure/connection_pool.rs:            if let Some(oldest_key) = cache.keys().next().cloned() {
./backend/src/infrastructure/connection_pool.rs:                cache.remove(&oldest_key);
./backend/src/infrastructure/connection_pool.rs:        cache.insert(key, response);
./backend/src/infrastructure/connection_pool.rs:        cache.set(key.clone(), data.clone(), content_type.clone()).await;
./backend/src/infrastructure/connection_pool.rs:        let cached = cache.get(&key).await
./backend/src/infrastructure/throughput_optimizer.rs:    pub async fn cache_data(&self, key: String, data: Vec<u8>) -> HiveResult<()> {
./backend/src/infrastructure/throughput_optimizer.rs:        self.intelligent_cache.set(key, data).await
./backend/src/infrastructure/throughput_optimizer.rs:    pub async fn get_cached_data(&self, key: &str) -> Option<Vec<u8>> {
./backend/src/infrastructure/throughput_optimizer.rs:        self.intelligent_cache.get(key).await
./backend/src/infrastructure/performance_optimizer.rs:    pub async fn get(&self, key: &str) -> Option<Vec<u8>> {
./backend/src/infrastructure/performance_optimizer.rs:        if let Some(entry) = cache.get_mut(key) {
./backend/src/infrastructure/performance_optimizer.rs:            cache.remove(key);
./backend/src/infrastructure/performance_optimizer.rs:    pub async fn put(&self, key: String, data: Vec<u8>) -> HiveResult<()> {
./backend/src/infrastructure/performance_optimizer.rs:        cache.insert(key, entry);
./backend/src/infrastructure/performance_optimizer.rs:        entries.sort_by_key(|(_, entry)| entry.last_accessed);
./backend/src/infrastructure/performance_optimizer.rs:        let mut keys_to_remove = Vec::new();
./backend/src/infrastructure/performance_optimizer.rs:        for (key, entry) in entries {
./backend/src/infrastructure/performance_optimizer.rs:            keys_to_remove.push(key.clone());
./backend/src/infrastructure/performance_optimizer.rs:        for key in keys_to_remove {
./backend/src/infrastructure/performance_optimizer.rs:            cache.remove(&key);
./backend/src/infrastructure/performance_optimizer.rs:        let mut keys_to_remove = Vec::new();
./backend/src/infrastructure/performance_optimizer.rs:        for (key, entry) in cache_guard.iter() {
./backend/src/infrastructure/performance_optimizer.rs:                keys_to_remove.push(key.clone());
./backend/src/infrastructure/performance_optimizer.rs:        for key in keys_to_remove {
./backend/src/infrastructure/performance_optimizer.rs:            cache_guard.remove(&key);
./backend/src/infrastructure/performance_optimizer.rs:        assert!(cache.get(&key).await.is_none());
./backend/src/infrastructure/performance_optimizer.rs:        match cache.put(key.clone(), data.clone()).await {
./backend/src/infrastructure/performance_optimizer.rs:        let Some(cached_data) = cache.get(&key).await else {
./backend/src/infrastructure/cache.rs:    pub async fn insert(&self, key: K, value: V) {
./backend/src/infrastructure/cache.rs:        self.insert_with_ttl(key, value, self.default_ttl).await;
./backend/src/infrastructure/cache.rs:    pub async fn insert_with_ttl(&self, key: K, value: V, ttl: Duration) {
./backend/src/infrastructure/cache.rs:        let size_bytes = self.calculate_entry_size(&key, &value);
./backend/src/infrastructure/cache.rs:        data.insert(key, entry);
./backend/src/infrastructure/cache.rs:    pub async fn get(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/cache.rs:        if let Some(entry) = data.get_mut(key) {
./backend/src/infrastructure/cache.rs:                data.remove(key);
./backend/src/infrastructure/cache.rs:    pub async fn remove(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/cache.rs:        data.remove(key).map(|entry| entry.value)
./backend/src/infrastructure/cache.rs:            if let Some((key, entry)) = eviction_candidate {
./backend/src/infrastructure/cache.rs:                entries_to_evict.push((key, entry.size_bytes));
./backend/src/infrastructure/cache.rs:        for (key, _size) in entries_to_evict {
./backend/src/infrastructure/cache.rs:            if let Some(entry) = data.remove(&key) {
./backend/src/infrastructure/cache.rs:                .min_by_key(|(_, entry)| entry.last_accessed)
./backend/src/infrastructure/cache.rs:                .min_by_key(|(_, entry)| entry.access_count)
./backend/src/infrastructure/cache.rs:                    .min_by_key(|(_, entry)| {
./backend/src/infrastructure/cache.rs:    fn calculate_entry_size(&self, key: &K, value: &V) -> usize {
./backend/src/infrastructure/cache.rs:        let key_size = std::mem::size_of_val(key);
./backend/src/infrastructure/cache.rs:        key_size + value_size + 128 // Overhead for HashMap entry
./backend/src/infrastructure/telemetry.rs:            let type_key = format!("{event_type:?}");
./backend/src/infrastructure/telemetry.rs:            *metrics.events_by_type.entry(type_key).or_insert(0) += 1;
./backend/src/infrastructure/telemetry.rs:            let severity_key = format!("{severity:?}");
./backend/src/infrastructure/telemetry.rs:            *metrics.events_by_severity.entry(severity_key).or_insert(0) += 1;
./backend/src/infrastructure/telemetry.rs:    ($collector:expr, $source:expr, $($key:expr => $value:expr),*) => {
./backend/src/infrastructure/telemetry.rs:            serde_json::json!({ $($key: $value),* }),
./backend/src/infrastructure/monitoring_legacy.rs:    pub key_findings: Vec<String>,
./backend/src/infrastructure/monitoring_legacy.rs:                    let _active_agents: Vec<Uuid> = health_map.keys().copied().collect();
./backend/src/infrastructure/monitoring_legacy.rs:                // Generate trend data for key metrics
./backend/src/infrastructure/monitoring_legacy.rs:            let latency_key = format!("MONITORING_{}_LATENCY", component.to_uppercase());
./backend/src/infrastructure/monitoring_legacy.rs:            let latency = std::env::var(&latency_key)
./backend/src/infrastructure/monitoring_legacy.rs:            let throughput_key = format!("MONITORING_{}_THROUGHPUT", component.to_uppercase());
./backend/src/infrastructure/monitoring_legacy.rs:            let throughput = std::env::var(&throughput_key)
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:    pub async fn setup_grafana_integration(&self, endpoint: &str, api_key: &str) -> HiveResult<()> {
./backend/src/infrastructure/monitoring_legacy.rs:                config.insert("api_key".to_string(), api_key.to_string());
./backend/src/infrastructure/monitoring_legacy.rs:        password: &str,
./backend/src/infrastructure/monitoring_legacy.rs:                config.insert("password".to_string(), password.to_string());
./backend/src/infrastructure/persistence.rs:    pub encryption_key: Option<String>,
./backend/src/infrastructure/persistence.rs:    encryption_key: Option<[u8; 32]>,
./backend/src/infrastructure/persistence.rs:    /// Load encryption key from environment or secure storage
./backend/src/infrastructure/persistence.rs:    pub fn load_encryption_key() -> Option<String> {
./backend/src/infrastructure/persistence.rs:        std::env::var("HIVE_ENCRYPTION_KEY").ok()
./backend/src/infrastructure/persistence.rs:        let encryption_key = config.encryption_key.as_ref().map(|s| {
./backend/src/infrastructure/persistence.rs:            let mut key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            key[..len].copy_from_slice(&bytes[..len]);
./backend/src/infrastructure/persistence.rs:            key
./backend/src/infrastructure/persistence.rs:            encryption_key,
./backend/src/infrastructure/persistence.rs:                id TEXT PRIMARY KEY,
./backend/src/infrastructure/persistence.rs:            let oldest_key = snapshots.keys().next().cloned();
./backend/src/infrastructure/persistence.rs:            if let Some(key) = oldest_key {
./backend/src/infrastructure/persistence.rs:                snapshots.remove(&key);
./backend/src/infrastructure/persistence.rs:            let oldest_key = snapshots.keys().next().cloned();
./backend/src/infrastructure/persistence.rs:            if let Some(key) = oldest_key {
./backend/src/infrastructure/persistence.rs:                snapshots.remove(&key);
./backend/src/infrastructure/persistence.rs:        let keys_to_remove: Vec<String> = snapshots.keys().take(to_remove).cloned().collect();
./backend/src/infrastructure/persistence.rs:        for key in &keys_to_remove {
./backend/src/infrastructure/persistence.rs:            snapshots.remove(key);
./backend/src/infrastructure/persistence.rs:        Ok(keys_to_remove.len())
./backend/src/infrastructure/persistence.rs:            encryption_key: None,
./backend/src/infrastructure/intelligent_cache.rs:    pub query_key: String,
./backend/src/infrastructure/intelligent_cache.rs:    pub query_key: String,
./backend/src/infrastructure/intelligent_cache.rs:    /// Classify based on key patterns
./backend/src/infrastructure/intelligent_cache.rs:    /// Sequential access patterns (what comes after this key)
./backend/src/infrastructure/intelligent_cache.rs:    fn record_access(&mut self, previous_key: Option<&str>) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(prev_key) = previous_key {
./backend/src/infrastructure/intelligent_cache.rs:                .entry(prev_key.to_string())
./backend/src/infrastructure/intelligent_cache.rs:    /// Check if this key is in a burst access pattern
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, count)| (key.clone(), *count as f64 / total_sequential as f64))
./backend/src/infrastructure/intelligent_cache.rs:    last_accessed_key: Arc<RwLock<Option<K>>>,
./backend/src/infrastructure/intelligent_cache.rs:            last_accessed_key: Arc::new(RwLock::new(None)),
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/intelligent_cache.rs:        // Get the previous key for sequential pattern tracking
./backend/src/infrastructure/intelligent_cache.rs:        let previous_key = {
./backend/src/infrastructure/intelligent_cache.rs:            let mut last_key = self.last_accessed_key.write().await;
./backend/src/infrastructure/intelligent_cache.rs:            let prev = last_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:            *last_key = Some(key.clone());
./backend/src/infrastructure/intelligent_cache.rs:        self.record_access(key, previous_key.as_ref()).await;
./backend/src/infrastructure/intelligent_cache.rs:        let result = self.cache.get(key).await;
./backend/src/infrastructure/intelligent_cache.rs:                if prefetch_queue.contains(&key.to_string()) {
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set(&self, key: K, value: V) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:            self.calculate_adaptive_ttl(&key).await
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.insert_with_ttl(key.clone(), value, ttl).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set_with_ttl(&self, key: K, value: V, ttl: Duration) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.insert_with_ttl(key, value, ttl).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn remove(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/intelligent_cache.rs:            patterns.remove(key);
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.remove(key).await
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn prefetch<F, Fut>(&self, key: K, loader: F) -> HiveResult<()>
./backend/src/infrastructure/intelligent_cache.rs:        if self.cache.get(&key).await.is_some() {
./backend/src/infrastructure/intelligent_cache.rs:                self.set(key.clone(), value).await?;
./backend/src/infrastructure/intelligent_cache.rs:                    queue.push_back(key.to_string());
./backend/src/infrastructure/intelligent_cache.rs:                debug!("Successfully prefetched data for key");
./backend/src/infrastructure/intelligent_cache.rs:    /// Record access pattern for a key
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_access(&self, key: &K, previous_key: Option<&K>) {
./backend/src/infrastructure/intelligent_cache.rs:            .entry(key.clone())
./backend/src/infrastructure/intelligent_cache.rs:        pattern.record_access(previous_key.map(|k| k.as_ref()));
./backend/src/infrastructure/intelligent_cache.rs:            self.trigger_predictive_prefetching(key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn trigger_predictive_prefetching(&self, key: &K) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:            for (next_key, probability) in sequential_predictions.into_iter().take(3) {
./backend/src/infrastructure/intelligent_cache.rs:                        key.to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                        next_key,
./backend/src/infrastructure/intelligent_cache.rs:                    queue.push_back(next_key.clone());
./backend/src/infrastructure/intelligent_cache.rs:                    "Burst access detected for key: {}, triggering aggressive prefetching",
./backend/src/infrastructure/intelligent_cache.rs:                    key.to_string()
./backend/src/infrastructure/intelligent_cache.rs:                self.trigger_burst_prefetching(key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn trigger_burst_prefetching(&self, key: &K) {
./backend/src/infrastructure/intelligent_cache.rs:        // Find other keys with similar access patterns
./backend/src/infrastructure/intelligent_cache.rs:        let similar_keys: Vec<String> = patterns
./backend/src/infrastructure/intelligent_cache.rs:                k.as_ref() != key.as_ref() && p.access_frequency > 0.1 && p.is_in_burst()
./backend/src/infrastructure/intelligent_cache.rs:        for similar_key in similar_keys {
./backend/src/infrastructure/intelligent_cache.rs:            debug!("Burst prefetching similar key: {}", similar_key);
./backend/src/infrastructure/intelligent_cache.rs:            queue.push_back(similar_key);
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate adaptive TTL for a key
./backend/src/infrastructure/intelligent_cache.rs:    async fn calculate_adaptive_ttl(&self, key: &K) -> Duration {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:    /// Get keys that should be prefetched
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, _)| key.clone())
./backend/src/infrastructure/intelligent_cache.rs:    /// Get TTL adaptation statistics for all keys
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, pattern)| (key.clone(), pattern.get_ttl_stats()))
./backend/src/infrastructure/intelligent_cache.rs:        for (key, pattern) in &*patterns {
./backend/src/infrastructure/intelligent_cache.rs:                key: key.clone(),
./backend/src/infrastructure/intelligent_cache.rs:                sequential_keys: sequential_predictions
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate predicted benefit of prefetching a key
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                match loader_clone(key_clone).await {
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                match loader_clone(key_clone).await {
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                let _ = loader_clone(key_clone).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub key: String,
./backend/src/infrastructure/intelligent_cache.rs:    pub key: K,
./backend/src/infrastructure/intelligent_cache.rs:    pub sequential_keys: Vec<String>,
./backend/src/infrastructure/intelligent_cache.rs:                let task_id = format!("warm_{}", request.key);
./backend/src/infrastructure/intelligent_cache.rs:                                "Successfully warmed cache for key: {} in {:.4}s",
./backend/src/infrastructure/intelligent_cache.rs:                                request.key,
./backend/src/infrastructure/intelligent_cache.rs:                            tracing::warn!("Failed to warm cache for key: {}: {}", request.key, e);
./backend/src/infrastructure/intelligent_cache.rs:        for (key, records) in &analyzer.patterns {
./backend/src/infrastructure/intelligent_cache.rs:                        recommendations.push(key.clone());
./backend/src/infrastructure/intelligent_cache.rs:    pub fn record_access(&mut self, key: &str, access_type: AccessType) {
./backend/src/infrastructure/intelligent_cache.rs:            frequency_score: self.calculate_frequency_score(key),
./backend/src/infrastructure/intelligent_cache.rs:            .entry(key.to_string())
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get_mut(key) {
./backend/src/infrastructure/intelligent_cache.rs:        self.update_prediction_model(key);
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate frequency score for a key
./backend/src/infrastructure/intelligent_cache.rs:    fn calculate_frequency_score(&self, key: &str) -> f64 {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:    /// Update prediction model for a key
./backend/src/infrastructure/intelligent_cache.rs:    fn update_prediction_model(&mut self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:                self.prediction_model.insert(key.to_string(), model);
./backend/src/infrastructure/intelligent_cache.rs:    /// Predict if key will be accessed soon
./backend/src/infrastructure/intelligent_cache.rs:    pub fn predict_access(&self, key: &str) -> Option<f64> {
./backend/src/infrastructure/intelligent_cache.rs:            .get(key)
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l1_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l2_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            let _ = self.l1_cache.set(key.to_string(), value.clone()).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set(&self, key: String, value: serde_json::Value) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:        self.l1_cache.set(key.clone(), value.clone()).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.l2_cache.set(key, value).await?;
./backend/src/infrastructure/intelligent_cache.rs:        let query_key = request.query_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:            .entry(query_key)
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get_with_warming(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l1_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            self.record_cache_hit(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l2_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            let _ = self.l1_cache.set(key.to_string(), value.clone()).await;
./backend/src/infrastructure/intelligent_cache.rs:            self.record_cache_hit(key).await;
./backend/src/infrastructure/intelligent_cache.rs:            self.analyze_and_trigger_warming(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        self.record_cache_miss(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        key: String,
./backend/src/infrastructure/intelligent_cache.rs:        self.l1_cache.set(key.clone(), value.clone()).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.l2_cache.set(key.clone(), value).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.analyze_and_trigger_warming(&key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_cache_hit(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        analyzer.record_access(key, AccessType::Read);
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_cache_miss(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        analyzer.record_access(key, AccessType::Read);
./backend/src/infrastructure/intelligent_cache.rs:    async fn analyze_and_trigger_warming(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        if recommendations.contains(&key.to_string()) {
./backend/src/infrastructure/intelligent_cache.rs:            // Create warming request for this key
./backend/src/infrastructure/intelligent_cache.rs:                key: key.to_string(),
./backend/src/infrastructure/intelligent_cache.rs:            .set("key1".to_string(), serde_json::json!({"value": 42}))
./backend/src/infrastructure/intelligent_cache.rs:        let value = cache_manager.get("key1").await;
./backend/src/infrastructure/intelligent_cache.rs:            .prefetch("prefetch_key".to_string(), || async {
./backend/src/infrastructure/intelligent_cache.rs:        let value = cache.get(&"prefetch_key".to_string()).await;
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                    "name": format!("User {}", key),
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                    "name": format!("Product {}", key),
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                Ok(serde_json::json!({"data": format!("Generic data for {}", key)}))
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/intelligent_cache.rs:            let query_key_clone = query_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user1".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user2".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user3".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:            let (query_type, key) = &workload[idx];
./backend/src/infrastructure/intelligent_cache.rs:            workload.push((query_type.clone(), key.clone()));
./backend/src/infrastructure/intelligent_cache.rs:        for (query_type, key) in workload {
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/streaming.rs:    pub fn with_metadata(mut self, key: String, value: String) -> Self {
./backend/src/infrastructure/streaming.rs:        self.metadata.insert(key, value);
./backend/src/infrastructure/monitoring/health_monitor.rs:        let agent_ids: Vec<Uuid> = self.agent_health.read().await.keys().cloned().collect();
./backend/src/infrastructure/monitoring/mod.rs:// Re-export key components
./backend/src/infrastructure/cache_optimization.rs:            let key = CacheKey::Custom(format!("benchmark_key_{}", operations % 1000));
./backend/src/infrastructure/cache_optimization.rs:                if let Err(e) = self.cache_manager.set_cached(key, cache_entry).await {
./backend/src/infrastructure/cache_optimization.rs:                    .get_cached::<serde_json::Value>(&key)
./backend/src/infrastructure/network_optimizer.rs:        let key = format!("{}:{}", host, port);
./backend/src/infrastructure/network_optimizer.rs:            if let Some(pool) = pools.get_mut(&key) {
./backend/src/infrastructure/network_optimizer.rs:        let key = format!("{}:{}", connection.host, connection.port);
./backend/src/infrastructure/network_optimizer.rs:        let pool = pools.entry(key).or_insert_with(Vec::new);
./backend/src/infrastructure/network_optimizer.rs:    tokens: Arc<Mutex<u64>>,
./backend/src/infrastructure/network_optimizer.rs:            tokens: Arc::new(Mutex::new(config.rate_limit_bytes_per_sec)),
./backend/src/infrastructure/network_optimizer.rs:        let mut tokens = self.tokens.lock().await;
./backend/src/infrastructure/network_optimizer.rs:        // Refill tokens based on elapsed time
./backend/src/infrastructure/network_optimizer.rs:        let tokens_to_add = (elapsed.as_secs_f64() * self.config.rate_limit_bytes_per_sec as f64) as u64;
./backend/src/infrastructure/network_optimizer.rs:        *tokens = (*tokens + tokens_to_add).min(self.config.rate_limit_bytes_per_sec);
./backend/src/infrastructure/network_optimizer.rs:        if *tokens >= requested_bytes as u64 {
./backend/src/infrastructure/network_optimizer.rs:            *tokens -= requested_bytes as u64;
./backend/src/infrastructure/performance_integration.rs:    pub async fn get_cached(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/performance_integration.rs:        self.cache_manager.get(key).await
./backend/src/infrastructure/performance_integration.rs:    pub async fn set_cached(&self, key: String, value: serde_json::Value) -> HiveResult<()> {
./backend/src/infrastructure/performance_integration.rs:        self.cache_manager.set(key, value).await
./backend/src/infrastructure/performance_integration.rs:    pub async fn get_or_load<F, Fut>(&self, key: &str, loader: F) -> HiveResult<serde_json::Value>
./backend/src/infrastructure/performance_integration.rs:        if let Some(cached) = self.get_cached(key).await {
./backend/src/infrastructure/performance_integration.rs:        self.set_cached(key.to_string(), value.clone()).await?;
./backend/src/infrastructure/performance_integration.rs:            .get_or_load("new_key", || async {
./backend/src/infrastructure/intelligent_alerting.rs:            let alert_key = format!(
./backend/src/infrastructure/intelligent_alerting.rs:            if let Some(last_sent) = suppression.suppressed_alerts.get(&alert_key) {
./backend/src/infrastructure/intelligent_alerting.rs:            suppression.suppressed_alerts.insert(alert_key, now);
./backend/src/infrastructure/intelligent_alerting.rs:            .max_by_key(|(_, count)| *count)
./backend/performance_benchmark.rs:        let key = format!("key_{}", i);
./backend/performance_benchmark.rs:            map.insert(key, data);
./backend/bench_runner.rs:            for (key, value) in &result.custom_metrics {
./backend/bench_runner.rs:                println!("     {}: {:.2}", key, value);
./backend/benches/performance_optimizations.rs:                let key = format!("key_{}", i);
./backend/benches/performance_optimizations.rs:                cache.set(key.clone(), value.clone()).await.unwrap();
./backend/benches/performance_optimizations.rs:                    let _ = cache.get(&key).await;
./backend/benches/performance_optimizations.rs:                    .set_with_intelligence(key, value)
./backend/benches/performance_optimizations.rs:                if cache_manager.get_with_warming(&key).await.is_some() {
./backend/benches/performance_optimizations.rs:                let key = format!("hot_key_{}", i % 10); // High frequency keys
./backend/benches/performance_optimizations.rs:                    let _ = cache_manager.get_with_warming(&key).await;
./backend/simple_perf_benchmark.rs:                let key = format!("thread_{}_item_{}", i, j);
./backend/simple_perf_benchmark.rs:                map.insert(key, data);
./backend/simple_perf_benchmark.rs:        if map.contains_key(&i) {
./frontend/e2e/dashboard.spec.ts:    const metricsChanged = Object.keys(initialMetrics).some(
./frontend/e2e/dashboard.spec.ts:      key => initialMetrics[key] !== updatedMetrics[key],
./frontend/src/utils/logger.ts:    if (context && Object.keys(context).length > 0) {
./frontend/src/hooks/useErrorRecovery.ts:          retryableErrors.some(keyword => message.includes(keyword)) ||
./frontend/src/hooks/useErrorRecovery.ts:        const isNonRetryable = nonRetryableErrors.some(keyword => message.includes(keyword))
./frontend/scripts/agent-map.js:      Object.keys(agentMap.agents).length > 0
./frontend/scripts/agent-map.js:        ? totalConnections / Object.keys(agentMap.agents).length
./frontend/scripts/agent-map.js:    console.log(`   Total Agents: ${Object.keys(agentMap.agents).length}`)
./frontend/scripts/agent-behavior-decisions.js:    const agents = Object.keys(decisionPatterns.agent_decision_profiles)
./frontend/scripts/agent-behavior-communication.js:    commPatterns.patterns.isolated_agents = Object.keys(commPatterns.interaction_frequency).filter(
./frontend/.next/static/chunks/626-de7b3eb28f5154c0.js:"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[626],{508:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("user",[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]])},1473:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("brain",[["path",{d:"M12 18V5",key:"adv99a"}],["path",{d:"M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4",key:"1e3is1"}],["path",{d:"M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5",key:"1gqd8o"}],["path",{d:"M17.997 5.125a4 4 0 0 1 2.526 5.77",key:"iwvgf7"}],["path",{d:"M18 18a4 4 0 0 0 2-7.464",key:"efp6ie"}],["path",{d:"M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517",key:"1gq6am"}],["path",{d:"M6 18a4 4 0 0 1-2-7.464",key:"k1g0md"}],["path",{d:"M6.003 5.125a4 4 0 0 0-2.526 5.77",key:"q97ue3"}]])},1524:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("trending-up",[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]])},1847:(e,t,a)=>{a.d(t,{A:()=>k});var h=a(2115);let d=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,a)=>a?a.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},r=function(){for(var e=arguments.length,t=Array(e),a=0;a<e;a++)t[a]=arguments[a];return t.filter((e,t,a)=>!!e&&""!==e.trim()&&a.indexOf(e)===t).join(" ").trim()};var y={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let l=(0,h.forwardRef)((e,t)=>{let{color:a="currentColor",size:d=24,strokeWidth:l=2,absoluteStrokeWidth:k,className:p="",children:c,iconNode:i,...n}=e;return(0,h.createElement)("svg",{ref:t,...y,width:d,height:d,stroke:a,strokeWidth:k?24*Number(l)/Number(d):l,className:r("lucide",p),...!c&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(n)&&{"aria-hidden":"true"},...n},[...i.map(e=>{let[t,a]=e;return(0,h.createElement)(t,a)}),...Array.isArray(c)?c:[c]])}),k=(e,t)=>{let a=(0,h.forwardRef)((a,y)=>{let{className:k,...p}=a;return(0,h.createElement)(l,{ref:y,iconNode:t,className:r("lucide-".concat(d(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()),"lucide-".concat(e),k),...p})});return a.displayName=d(e),a}},2056:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]])},2529:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("circle-check-big",[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]])},3166:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("wifi",[["path",{d:"M12 20h.01",key:"zekei9"}],["path",{d:"M2 8.82a15 15 0 0 1 20 0",key:"dnpr2z"}],["path",{d:"M5 12.859a10 10 0 0 1 14 0",key:"1x1e6c"}],["path",{d:"M8.5 16.429a5 5 0 0 1 7 0",key:"1bycff"}]])},3738:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("wifi-off",[["path",{d:"M12 20h.01",key:"zekei9"}],["path",{d:"M8.5 16.429a5 5 0 0 1 7 0",key:"1bycff"}],["path",{d:"M5 12.859a10 10 0 0 1 5.17-2.69",key:"1dl1wf"}],["path",{d:"M19 12.859a10 10 0 0 0-2.007-1.523",key:"4k23kn"}],["path",{d:"M2 8.82a15 15 0 0 1 4.177-2.643",key:"1grhjp"}],["path",{d:"M22 8.82a15 15 0 0 0-11.288-3.764",key:"z3jwby"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]])},4172:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("server",[["rect",{width:"20",height:"8",x:"2",y:"2",rx:"2",ry:"2",key:"ngkwjq"}],["rect",{width:"20",height:"8",x:"2",y:"14",rx:"2",ry:"2",key:"iecqi9"}],["line",{x1:"6",x2:"6.01",y1:"6",y2:"6",key:"16zg32"}],["line",{x1:"6",x2:"6.01",y1:"18",y2:"18",key:"nzw8ys"}]])},5707:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("cpu",[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]])},5870:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("settings",[["path",{d:"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",key:"1i5ecw"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]])},5959:(e,t,a)=>{a.d(t,{v:()=>y});var h=a(2115);let d=e=>{let t,a=new Set,h=(e,h)=>{let d="function"==typeof e?e(t):e;if(!Object.is(d,t)){let e=t;t=(null!=h?h:"object"!=typeof d||null===d)?d:Object.assign({},t,d),a.forEach(a=>a(t,e))}},d=()=>t,r={setState:h,getState:d,getInitialState:()=>y,subscribe:e=>(a.add(e),()=>a.delete(e))},y=t=e(h,d,r);return r},r=e=>{let t=(e=>e?d(e):d)(e),a=e=>(function(e,t=e=>e){let a=h.useSyncExternalStore(e.subscribe,h.useCallback(()=>t(e.getState()),[e,t]),h.useCallback(()=>t(e.getInitialState()),[e,t]));return h.useDebugValue(a),a})(t,e);return Object.assign(a,t),a},y=e=>e?r(e):r},5993:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("house",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"1d0kgt"}]])},6132:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("circle-alert",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]])},6154:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]])},6191:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]])},6927:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("bug",[["path",{d:"m8 2 1.88 1.88",key:"fmnt4t"}],["path",{d:"M14.12 3.88 16 2",key:"qol33r"}],["path",{d:"M9 7.13v-1a3.003 3.003 0 1 1 6 0v1",key:"d7y7pr"}],["path",{d:"M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",key:"xs1cw7"}],["path",{d:"M12 20v-9",key:"1qisl0"}],["path",{d:"M6.53 9C4.6 8.8 3 7.1 3 5",key:"32zzws"}],["path",{d:"M6 13H2",key:"82j7cp"}],["path",{d:"M3 21c0-2.1 1.7-3.9 3.8-4",key:"4p0ekp"}],["path",{d:"M20.97 5c0 2.1-1.6 3.8-3.5 4",key:"18gb23"}],["path",{d:"M22 13h-4",key:"1jl80f"}],["path",{d:"M17.2 17c2.1.1 3.8 1.9 3.8 4",key:"k3fwyw"}]])},6983:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("clock",[["path",{d:"M12 6v6l4 2",key:"mmk7yg"}],["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}]])},7586:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("message-square",[["path",{d:"M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",key:"18887p"}]])},8874:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("circle-x",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m15 9-6 6",key:"1uzhvr"}],["path",{d:"m9 9 6 6",key:"z0biqf"}]])},9559:(e,t,a)=>{a.d(t,{A:()=>h});let h=(0,a(1847).A)("refresh-cw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]])}}]);
./frontend/.next/static/chunks/app/layout-872f4a9beba56eda.js:(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[177],{1847:(e,t,r)=>{"use strict";r.d(t,{A:()=>h});var a=r(2115);let l=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,r)=>r?r.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},s=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return t.filter((e,t,r)=>!!e&&""!==e.trim()&&r.indexOf(e)===t).join(" ").trim()};var o={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let n=(0,a.forwardRef)((e,t)=>{let{color:r="currentColor",size:l=24,strokeWidth:n=2,absoluteStrokeWidth:h,className:i="",children:d,iconNode:c,...p}=e;return(0,a.createElement)("svg",{ref:t,...o,width:l,height:l,stroke:r,strokeWidth:h?24*Number(n)/Number(l):n,className:s("lucide",i),...!d&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(p)&&{"aria-hidden":"true"},...p},[...c.map(e=>{let[t,r]=e;return(0,a.createElement)(t,r)}),...Array.isArray(d)?d:[d]])}),h=(e,t)=>{let r=(0,a.forwardRef)((r,o)=>{let{className:h,...i}=r;return(0,a.createElement)(n,{ref:o,iconNode:t,className:s("lucide-".concat(l(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()),"lucide-".concat(e),h),...i})});return r.displayName=l(e),r}},2056:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]])},3673:()=>{},5048:(e,t,r)=>{"use strict";r.d(t,{ClientErrorBoundary:()=>n});var a=r(5155),l=r(2115),s=r(7088),o=r(8812);function n(e){let{children:t}=e,[r,n]=(0,l.useState)(!1);return((0,l.useEffect)(()=>{n(!0),(0,o.NZ)()},[]),r)?(0,a.jsx)(s.tH,{showDetails:!1,onError:(e,t)=>{console.error("Root layout error:",e,t)},children:t}):(0,a.jsx)(a.Fragment,{children:t})}},5993:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("house",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"1d0kgt"}]])},6570:(e,t,r)=>{Promise.resolve().then(r.t.bind(r,8963,23)),Promise.resolve().then(r.t.bind(r,3673,23)),Promise.resolve().then(r.bind(r,5048))},6927:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("bug",[["path",{d:"m8 2 1.88 1.88",key:"fmnt4t"}],["path",{d:"M14.12 3.88 16 2",key:"qol33r"}],["path",{d:"M9 7.13v-1a3.003 3.003 0 1 1 6 0v1",key:"d7y7pr"}],["path",{d:"M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",key:"xs1cw7"}],["path",{d:"M12 20v-9",key:"1qisl0"}],["path",{d:"M6.53 9C4.6 8.8 3 7.1 3 5",key:"32zzws"}],["path",{d:"M6 13H2",key:"82j7cp"}],["path",{d:"M3 21c0-2.1 1.7-3.9 3.8-4",key:"4p0ekp"}],["path",{d:"M20.97 5c0 2.1-1.6 3.8-3.5 4",key:"18gb23"}],["path",{d:"M22 13h-4",key:"1jl80f"}],["path",{d:"M17.2 17c2.1.1 3.8 1.9 3.8 4",key:"k3fwyw"}]])},8963:e=>{e.exports={style:{fontFamily:"'Inter', 'Inter Fallback'",fontStyle:"normal"},className:"__className_f367f3"}},9559:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("refresh-cw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]])}},e=>{e.O(0,[300,458,441,255,358],()=>e(e.s=6570)),_N_E=e.O()}]);
./frontend/.next/prerender-manifest.json:          "key": "next-action"
./frontend/.next/prerender-manifest.json:          "key": "content-type",
./frontend/.next/prerender-manifest.json:        "x-next-revalidate-tag-token"
./frontend/.next/prerender-manifest.json:          "key": "next-action"
./frontend/.next/prerender-manifest.json:          "key": "content-type",
./frontend/.next/prerender-manifest.json:        "x-next-revalidate-tag-token"
./frontend/.next/server/chunks/611.js:          `}}),(0,d.jsx)("script",{"data-partytown":"",dangerouslySetInnerHTML:{__html:a()}}),(f.worker||[]).map((a,c)=>{let{strategy:d,src:f,children:h,dangerouslySetInnerHTML:i,...j}=a,k={};if(f)k.src=f;else if(i&&i.__html)k.dangerouslySetInnerHTML={__html:i.__html};else if(h)k.dangerouslySetInnerHTML={__html:"string"==typeof h?h:Array.isArray(h)?h.join(""):""};else throw Object.defineProperty(Error("Invalid usage of next/script. Did you forget to include a src attribute or an inline script? https://nextjs.org/docs/messages/invalid-script"),"__NEXT_ERROR_CODE",{value:"E82",enumerable:!1,configurable:!0});return(0,e.createElement)("script",{...k,...j,type:"text/partytown",key:f||c,nonce:b.nonce,"data-nscript":"worker",crossOrigin:b.crossOrigin||g})})]})}catch(a){return(0,i.default)(a)&&"MODULE_NOT_FOUND"!==a.code&&console.warn(`Warning: ${a.message}`),null}}(a,b),j=(c.beforeInteractive||[]).filter(a=>a.src).map((a,c)=>{let{strategy:d,...h}=a;return(0,e.createElement)("script",{...h,key:h.src||c,defer:h.defer??!f,nonce:h.nonce||b.nonce,"data-nscript":"beforeInteractive",crossOrigin:b.crossOrigin||g})});return(0,d.jsxs)(d.Fragment,{children:[h,j]})}class v extends e.default.Component{static #a=this.contextType=j.HtmlContext;getCssLinks(a){let{assetPrefix:b,assetQueryString:c,dynamicImports:e,dynamicCssManifest:f,crossOrigin:g,optimizeCss:h}=this.context,i=a.allFiles.filter(a=>a.endsWith(".css")),j=new Set(a.sharedFiles),l=new Set([]),m=Array.from(new Set(e.filter(a=>a.endsWith(".css"))));if(m.length){let a=new Set(i);l=new Set(m=m.filter(b=>!(a.has(b)||j.has(b)))),i.push(...m)}let n=[];return i.forEach(a=>{let e=j.has(a),i=l.has(a),m=f.has(a);h||n.push((0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"style",crossOrigin:this.props.crossOrigin||g},`${a}-preload`)),n.push((0,d.jsx)("link",{nonce:this.props.nonce,rel:"stylesheet",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,crossOrigin:this.props.crossOrigin||g,"data-n-g":i?void 0:e?"":void 0,"data-n-p":e||i||m?void 0:""},a))}),0===n.length?null:n}getPreloadDynamicChunks(){let{dynamicImports:a,assetPrefix:b,assetQueryString:c,crossOrigin:e}=this.context;return a.map(a=>a.endsWith(".js")?(0,d.jsx)("link",{rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"script",nonce:this.props.nonce,crossOrigin:this.props.crossOrigin||e},a):null).filter(Boolean)}getPreloadMainLinks(a){let{assetPrefix:b,assetQueryString:c,scriptLoader:e,crossOrigin:f}=this.context,g=a.allFiles.filter(a=>a.endsWith(".js"));return[...(e.beforeInteractive||[]).map(a=>(0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:a.src,as:"script",crossOrigin:this.props.crossOrigin||f},a.src)),...g.map(a=>(0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"script",crossOrigin:this.props.crossOrigin||f},a))]}getBeforeInteractiveInlineScripts(){let{scriptLoader:a}=this.context,{nonce:b,crossOrigin:c}=this.props;return(a.beforeInteractive||[]).filter(a=>!a.src&&(a.dangerouslySetInnerHTML||a.children)).map((a,d)=>{let{strategy:f,children:g,dangerouslySetInnerHTML:h,src:i,...j}=a,k="";return h&&h.__html?k=h.__html:g&&(k="string"==typeof g?g:Array.isArray(g)?g.join(""):""),(0,e.createElement)("script",{...j,dangerouslySetInnerHTML:{__html:k},key:j.id||d,nonce:b,"data-nscript":"beforeInteractive",crossOrigin:c||void 0})})}getDynamicChunks(a){return s(this.context,this.props,a)}getPreNextScripts(){return u(this.context,this.props)}getScripts(a){return t(this.context,this.props,a)}getPolyfillScripts(){return q(this.context,this.props)}render(){let{styles:a,ampPath:b,inAmpMode:f,hybridAmp:g,canonicalBase:h,__NEXT_DATA__:i,dangerousAsPath:j,headTags:n,unstable_runtimeJS:o,unstable_JsPreload:q,disableOptimizedLoading:s,optimizeCss:t,assetPrefix:u,nextFontManifest:v}=this.context,w=!1===o,x=!1===q||!s;this.context.docComponentsRendered.Head=!0;let{head:y}=this.context,z=[],A=[];y&&(y.forEach(a=>{a&&"link"===a.type&&"preload"===a.props.rel&&"style"===a.props.as?z.push(a):a&&A.push(e.default.cloneElement(a,{"data-next-head":""}))}),y=z.concat(A));let B=e.default.Children.toArray(this.props.children).filter(Boolean),C=!1,D=!1;y=e.default.Children.map(y||[],a=>{if(!a)return a;let{type:b,props:c}=a;if(f){let d="";if("meta"===b&&"viewport"===c.name?d='name="viewport"':"link"===b&&"canonical"===c.rel?D=!0:"script"===b&&(c.src&&-1>c.src.indexOf("ampproject")||c.dangerouslySetInnerHTML&&(!c.type||"text/javascript"===c.type))&&(d="<script",Object.keys(c).forEach(a=>{d+=` ${a}="${c[a]}"`}),d+="/>"),d)return console.warn(`Found conflicting amp tag "${a.type}" with conflicting prop ${d} in ${i.page}. https://nextjs.org/docs/messages/conflicting-amp-tag`),null}else"link"===b&&"amphtml"===c.rel&&(C=!0);return a});let E=p(this.context.buildManifest,this.context.__NEXT_DATA__.page,f),F=function(a,b,c=""){if(!a)return{preconnect:null,preload:null};let e=a.pages["/_app"],f=a.pages[b],g=Array.from(new Set([...e??[],...f??[]]));return{preconnect:0===g.length&&(e||f)?(0,d.jsx)("link",{"data-next-font":a.pagesUsingSizeAdjust?"size-adjust":"",rel:"preconnect",href:"/",crossOrigin:"anonymous"}):null,preload:g?g.map(a=>{let b=/\.(woff|woff2|eot|ttf|otf)$/.exec(a)[1];return(0,d.jsx)("link",{rel:"preload",href:`${c}/_next/${(0,k.encodeURIPath)(a)}`,as:"font",type:`font/${b}`,crossOrigin:"anonymous","data-next-font":a.includes("-s")?"size-adjust":""},a)}):null}}(v,j,u),G=((0,m.getTracedMetadata)((0,l.getTracer)().getTracePropagationData(),this.context.experimentalClientTraceMetadata)||[]).map(({key:a,value:b},c)=>(0,d.jsx)("meta",{name:a,content:b},`next-trace-data-${c}`));return(0,d.jsxs)("head",{...function(a){let{crossOrigin:b,nonce:c,...d}=a;return d}(this.props),children:[this.context.isDevelopment&&(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("style",{"data-next-hide-fouc":!0,"data-ampdevmode":f?"true":void 0,dangerouslySetInnerHTML:{__html:"body{display:none}"}}),(0,d.jsx)("noscript",{"data-next-hide-fouc":!0,"data-ampdevmode":f?"true":void 0,children:(0,d.jsx)("style",{dangerouslySetInnerHTML:{__html:"body{display:block}"}})})]}),y,B,F.preconnect,F.preload,f&&(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("meta",{name:"viewport",content:"width=device-width,minimum-scale=1,initial-scale=1"}),!D&&(0,d.jsx)("link",{rel:"canonical",href:h+c(5401).cleanAmpPath(j)}),(0,d.jsx)("link",{rel:"preload",as:"script",href:"https://cdn.ampproject.org/v0.js"}),(0,d.jsx)(r,{styles:a}),(0,d.jsx)("style",{"amp-boilerplate":"",dangerouslySetInnerHTML:{__html:"body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}"}}),(0,d.jsx)("noscript",{children:(0,d.jsx)("style",{"amp-boilerplate":"",dangerouslySetInnerHTML:{__html:"body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}"}})}),(0,d.jsx)("script",{async:!0,src:"https://cdn.ampproject.org/v0.js"})]}),!f&&(0,d.jsxs)(d.Fragment,{children:[!C&&g&&(0,d.jsx)("link",{rel:"amphtml",href:h+(b||`${j}${j.includes("?")?"&":"?"}amp=1`)}),this.getBeforeInteractiveInlineScripts(),!t&&this.getCssLinks(E),!t&&(0,d.jsx)("noscript",{"data-n-css":this.props.nonce??""}),!w&&!x&&this.getPreloadDynamicChunks(),!w&&!x&&this.getPreloadMainLinks(E),!s&&!w&&this.getPolyfillScripts(),!s&&!w&&this.getPreNextScripts(),!s&&!w&&this.getDynamicChunks(E),!s&&!w&&this.getScripts(E),t&&this.getCssLinks(E),t&&(0,d.jsx)("noscript",{"data-n-css":this.props.nonce??""}),this.context.isDevelopment&&(0,d.jsx)("noscript",{id:"__next_css__DO_NOT_USE__"}),G,a||null]}),e.default.createElement(e.default.Fragment,{},...n||[])]})}}class w extends e.default.Component{static #a=this.contextType=j.HtmlContext;getDynamicChunks(a){return s(this.context,this.props,a)}getPreNextScripts(){return u(this.context,this.props)}getScripts(a){return t(this.context,this.props,a)}getPolyfillScripts(){return q(this.context,this.props)}static getInlineScriptSource(a){let{__NEXT_DATA__:b,largePageDataBytes:d}=a;try{let e=JSON.stringify(b);if(o.has(b.page))return(0,h.htmlEscapeJsonString)(e);let f=Buffer.from(e).byteLength,g=c(3135).A;return d&&f>d&&(o.add(b.page),console.warn(`Warning: data for page "${b.page}"${b.page===a.dangerousAsPath?"":` (path "${a.dangerousAsPath}")`} is ${g(f)} which exceeds the threshold of ${g(d)}, this amount of data can reduce performance.
./frontend/.next/server/chunks/61.js:  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`))}function X(a,b,c,d){if(0!==b){if(c.hasSuspenseAboveBody)return;if(d.syncDynamicErrorWithStack)throw W(a,d.syncDynamicErrorWithStack),new f.StaticGenBailoutError;let e=c.dynamicErrors;if(e.length>0){for(let b=0;b<e.length;b++)W(a,e[b]);throw new f.StaticGenBailoutError}if(c.hasDynamicViewport)throw console.error(`Route "${a.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`),new f.StaticGenBailoutError;if(1===b)throw console.error(`Route "${a.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`),new f.StaticGenBailoutError}else if(!1===c.hasAllowedDynamic&&c.hasDynamicMetadata)throw console.error(`Route "${a.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`),new f.StaticGenBailoutError}function Y(a,b){return a.runtimeStagePromise?a.runtimeStagePromise.then(()=>b):b}},1830:(a,b)=>{"use strict";function c(a,b){return void 0===b&&(b=!0),a.pathname+a.search+(b?a.hash:"")}Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"createHrefFromUrl",{enumerable:!0,get:function(){return c}}),("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},1832:(a,b,c)=>{"use strict";a.exports=c(6796).vendored.contexts.ServerInsertedHtml},1843:(a,b)=>{"use strict";function c(a){let b=5381;for(let c=0;c<a.length;c++)b=(b<<5)+b+a.charCodeAt(c)|0;return b>>>0}function d(a){return c(a).toString(36).slice(0,5)}Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{djb2Hash:function(){return c},hexHash:function(){return d}})},1938:(a,b)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{StaticGenBailoutError:function(){return d},isStaticGenBailoutError:function(){return e}});let c="NEXT_STATIC_GEN_BAILOUT";class d extends Error{constructor(...a){super(...a),this.code=c}}function e(a){return"object"==typeof a&&null!==a&&"code"in a&&a.code===c}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},1949:(a,b)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"LRUCache",{enumerable:!0,get:function(){return e}});class c{constructor(a,b,c){this.prev=null,this.next=null,this.key=a,this.data=b,this.size=c}}class d{constructor(){this.prev=null,this.next=null}}class e{constructor(a,b){this.cache=new Map,this.totalSize=0,this.maxSize=a,this.calculateSize=b,this.head=new d,this.tail=new d,this.head.next=this.tail,this.tail.prev=this.head}addToHead(a){a.prev=this.head,a.next=this.head.next,this.head.next.prev=a,this.head.next=a}removeNode(a){a.prev.next=a.next,a.next.prev=a.prev}moveToHead(a){this.removeNode(a),this.addToHead(a)}removeTail(){let a=this.tail.prev;return this.removeNode(a),a}set(a,b){let d=(null==this.calculateSize?void 0:this.calculateSize.call(this,b))??1;if(d>this.maxSize)return void console.warn("Single item size exceeds maxSize");let e=this.cache.get(a);if(e)e.data=b,this.totalSize=this.totalSize-e.size+d,e.size=d,this.moveToHead(e);else{let e=new c(a,b,d);this.cache.set(a,e),this.addToHead(e),this.totalSize+=d}for(;this.totalSize>this.maxSize&&this.cache.size>0;){let a=this.removeTail();this.cache.delete(a.key),this.totalSize-=a.size}}has(a){return this.cache.has(a)}get(a){let b=this.cache.get(a);if(b)return this.moveToHead(b),b.data}*[Symbol.iterator](){let a=this.head.next;for(;a&&a!==this.tail;){let b=a;yield[b.key,b.data],a=a.next}}remove(a){let b=this.cache.get(a);b&&(this.removeNode(b),this.cache.delete(a),this.totalSize-=b.size)}get size(){return this.cache.size}get currentSize(){return this.totalSize}}},1972:a=>{(()=>{"use strict";var b={328:a=>{a.exports=function(a){for(var b=5381,c=a.length;c;)b=33*b^a.charCodeAt(--c);return b>>>0}}},c={};function d(a){var e=c[a];if(void 0!==e)return e.exports;var f=c[a]={exports:{}},g=!0;try{b[a](f,f.exports,d),g=!1}finally{g&&delete c[a]}return f.exports}d.ab=__dirname+"/",a.exports=d(328)})()},1981:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"isNextRouterError",{enumerable:!0,get:function(){return f}});let d=c(8541),e=c(2781);function f(a){return(0,e.isRedirectError)(a)||(0,d.isHTTPAccessFallbackError)(a)}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2074:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{createFlightReactServerErrorHandler:function(){return p},createHTMLErrorHandler:function(){return r},createHTMLReactServerErrorHandler:function(){return q},getDigestForWellKnownError:function(){return o},isUserLandError:function(){return s}});let d=function(a){return a&&a.__esModule?a:{default:a}}(c(1972)),e=c(4397),f=c(2324),g=c(5088),h=c(9305),i=c(9168),j=c(1981),k=c(6906),l=c(9816),m=c(7907),n=c(5439);function o(a){if((0,h.isBailoutToCSRError)(a)||(0,j.isNextRouterError)(a)||(0,i.isDynamicServerError)(a)||(0,k.isPrerenderInterruptedError)(a))return a.digest}function p(a,b){return c=>{if("string"==typeof c)return(0,d.default)(c).toString();if((0,g.isAbortError)(c))return;let h=o(c);if(h)return h;if((0,n.isReactLargeShellError)(c))return void console.error(c);let i=(0,l.getProperError)(c);i.digest||(i.digest=(0,d.default)(i.message+i.stack||"").toString()),a&&(0,e.formatServerError)(i);let j=(0,f.getTracer)().getActiveScopeSpan();return j&&(j.recordException(i),j.setAttribute("error.type",i.name),j.setStatus({code:f.SpanStatusCode.ERROR,message:i.message})),b(i),(0,m.createDigestWithErrorCode)(c,i.digest)}}function q(a,b,c,h,i){return j=>{var k;if("string"==typeof j)return(0,d.default)(j).toString();if((0,g.isAbortError)(j))return;let p=o(j);if(p)return p;if((0,n.isReactLargeShellError)(j))return void console.error(j);let q=(0,l.getProperError)(j);if(q.digest||(q.digest=(0,d.default)(q.message+(q.stack||"")).toString()),c.has(q.digest)||c.set(q.digest,q),a&&(0,e.formatServerError)(q),!(b&&(null==q||null==(k=q.message)?void 0:k.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))){let a=(0,f.getTracer)().getActiveScopeSpan();a&&(a.recordException(q),a.setAttribute("error.type",q.name),a.setStatus({code:f.SpanStatusCode.ERROR,message:q.message})),h||null==i||i(q)}return(0,m.createDigestWithErrorCode)(j,q.digest)}}function r(a,b,c,h,i,j){return(k,p)=>{var q;if((0,n.isReactLargeShellError)(k))return void console.error(k);let r=!0;if(h.push(k),(0,g.isAbortError)(k))return;let s=o(k);if(s)return s;let t=(0,l.getProperError)(k);if(t.digest?c.has(t.digest)&&(k=c.get(t.digest),r=!1):t.digest=(0,d.default)(t.message+((null==p?void 0:p.componentStack)||t.stack||"")).toString(),a&&(0,e.formatServerError)(t),!(b&&(null==t||null==(q=t.message)?void 0:q.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))){let a=(0,f.getTracer)().getActiveScopeSpan();a&&(a.recordException(t),a.setAttribute("error.type",t.name),a.setStatus({code:f.SpanStatusCode.ERROR,message:t.message})),!i&&r&&j(t,p)}return(0,m.createDigestWithErrorCode)(k,t.digest)}}function s(a){return!(0,g.isAbortError)(a)&&!(0,h.isBailoutToCSRError)(a)&&!(0,j.isNextRouterError)(a)}},2090:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"unstable_rethrow",{enumerable:!0,get:function(){return d}});let d=c(7761).unstable_rethrow;("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2120:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"useRouterBFCache",{enumerable:!0,get:function(){return e}});let d=c(8301);function e(a,b){let[c,e]=(0,d.useState)(()=>({tree:a,stateKey:b,next:null}));if(c.tree===a)return c;let f={tree:a,stateKey:b,next:null},g=1,h=c,i=f;for(;null!==h&&g<1;){if(h.stateKey===b){i.next=h.next;break}{g++;let a={tree:h.tree,stateKey:h.stateKey,next:null};i.next=a,i=a}h=h.next}return e(f),f}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2131:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"Postpone",{enumerable:!0,get:function(){return d.Postpone}});let d=c(6906)},2146:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"IconMark",{enumerable:!0,get:function(){return e}});let d=c(1124),e=()=>(0,d.jsx)("meta",{name:"\xabnxt-icon\xbb"})},2158:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{dispatchAppRouterAction:function(){return g},useActionQueue:function(){return h}});let d=c(5823)._(c(8301)),e=c(9039),f=null;function g(a){if(null===f)throw Object.defineProperty(Error("Internal Next.js error: Router action dispatched before initialization."),"__NEXT_ERROR_CODE",{value:"E668",enumerable:!1,configurable:!0});f(a)}function h(a){let[b,c]=d.default.useState(a.state);return f=b=>a.dispatch(b,c),(0,e.isThenable)(b)?(0,d.use)(b):b}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2263:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{MetadataBoundary:function(){return f},OutletBoundary:function(){return h},RootLayoutBoundary:function(){return i},ViewportBoundary:function(){return g}});let d=c(5818),e={[d.METADATA_BOUNDARY_NAME]:function({children:a}){return a},[d.VIEWPORT_BOUNDARY_NAME]:function({children:a}){return a},[d.OUTLET_BOUNDARY_NAME]:function({children:a}){return a},[d.ROOT_LAYOUT_BOUNDARY_NAME]:function({children:a}){return a}},f=e[d.METADATA_BOUNDARY_NAME.slice(0)],g=e[d.VIEWPORT_BOUNDARY_NAME.slice(0)],h=e[d.OUTLET_BOUNDARY_NAME.slice(0)],i=e[d.ROOT_LAYOUT_BOUNDARY_NAME.slice(0)]},2324:(a,b,c)=>{"use strict";let d;Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{BubbledError:function(){return m},SpanKind:function(){return k},SpanStatusCode:function(){return j},getTracer:function(){return u},isBubbledError:function(){return n}});let e=c(8928),f=c(9577);try{d=c(8688)}catch(a){d=c(8688)}let{context:g,propagation:h,trace:i,SpanStatusCode:j,SpanKind:k,ROOT_CONTEXT:l}=d;class m extends Error{constructor(a,b){super(),this.bubble=a,this.result=b}}function n(a){return"object"==typeof a&&null!==a&&a instanceof m}let o=(a,b)=>{n(b)&&b.bubble?a.setAttribute("next.bubble",!0):(b&&(a.recordException(b),a.setAttribute("error.type",b.name)),a.setStatus({code:j.ERROR,message:null==b?void 0:b.message})),a.end()},p=new Map,q=d.createContextKey("next.rootSpanId"),r=0,s={set(a,b,c){a.push({key:b,value:c})}};class t{getTracerInstance(){return i.getTracer("next.js","0.0.1")}getContext(){return g}getTracePropagationData(){let a=g.active(),b=[];return h.inject(a,b,s),b}getActiveScopeSpan(){return i.getSpan(null==g?void 0:g.active())}withPropagatedContext(a,b,c){let d=g.active();if(i.getSpanContext(d))return b();let e=h.extract(d,a,c);return g.with(e,b)}trace(...a){var b;let[c,d,h]=a,{fn:j,options:k}="function"==typeof d?{fn:d,options:{}}:{fn:h,options:{...d}},m=k.spanName??c;if(!e.NextVanillaSpanAllowlist.includes(c)&&"1"!==process.env.NEXT_OTEL_VERBOSE||k.hideSpan)return j();let n=this.getSpanContext((null==k?void 0:k.parentSpan)??this.getActiveScopeSpan()),s=!1;n?(null==(b=i.getSpanContext(n))?void 0:b.isRemote)&&(s=!0):(n=(null==g?void 0:g.active())??l,s=!0);let t=r++;return k.attributes={"next.span_name":m,"next.span_type":c,...k.attributes},g.with(n.setValue(q,t),()=>this.getTracerInstance().startActiveSpan(m,k,a=>{let b="performance"in globalThis&&"measure"in performance?globalThis.performance.now():void 0,d=()=>{p.delete(t),b&&process.env.NEXT_OTEL_PERFORMANCE_PREFIX&&e.LogSpanAllowList.includes(c||"")&&performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(c.split(".").pop()||"").replace(/[A-Z]/g,a=>"-"+a.toLowerCase())}`,{start:b,end:performance.now()})};s&&p.set(t,new Map(Object.entries(k.attributes??{})));try{if(j.length>1)return j(a,b=>o(a,b));let b=j(a);if((0,f.isThenable)(b))return b.then(b=>(a.end(),b)).catch(b=>{throw o(a,b),b}).finally(d);return a.end(),d(),b}catch(b){throw o(a,b),d(),b}}))}wrap(...a){let b=this,[c,d,f]=3===a.length?a:[a[0],{},a[1]];return e.NextVanillaSpanAllowlist.includes(c)||"1"===process.env.NEXT_OTEL_VERBOSE?function(){let a=d;"function"==typeof a&&"function"==typeof f&&(a=a.apply(this,arguments));let e=arguments.length-1,h=arguments[e];if("function"!=typeof h)return b.trace(c,a,()=>f.apply(this,arguments));{let d=b.getContext().bind(g.active(),h);return b.trace(c,a,(a,b)=>(arguments[e]=function(a){return null==b||b(a),d.apply(this,arguments)},f.apply(this,arguments)))}}:f}startSpan(...a){let[b,c]=a,d=this.getSpanContext((null==c?void 0:c.parentSpan)??this.getActiveScopeSpan());return this.getTracerInstance().startSpan(b,c,d)}getSpanContext(a){return a?i.setSpan(g.active(),a):void 0}getRootSpanAttributes(){let a=g.active().getValue(q);return p.get(a)}setRootSpanAttribute(a,b){let c=g.active().getValue(q),d=p.get(c);d&&d.set(a,b)}}let u=(()=>{let a=new t;return()=>a})()},2418:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"HandleISRError",{enumerable:!0,get:function(){return e}});let d=c(9294).workAsyncStorage;function e(a){let{error:b}=a;if(d){let a=d.getStore();if((null==a?void 0:a.isRevalidate)||(null==a?void 0:a.isStaticGeneration))throw console.error(b),b}return null}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2435:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{accumulateMetadata:function(){return I},accumulateViewport:function(){return J},resolveMetadata:function(){return K},resolveViewport:function(){return L}}),c(7925);let d=c(4515),e=c(9880),f=c(8512),g=c(7782),h=c(96),i=c(8783),j=c(1166),k=c(6613),l=c(3958),m=c(2324),n=c(8928),o=c(6896),p=function(a,b){if(a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return{default:a};var c=r(b);if(c&&c.has(a))return c.get(a);var d={__proto__:null},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var f in a)if("default"!==f&&Object.prototype.hasOwnProperty.call(a,f)){var g=e?Object.getOwnPropertyDescriptor(a,f):null;g&&(g.get||g.set)?Object.defineProperty(d,f,g):d[f]=a[f]}return d.default=a,c&&c.set(a,d),d}(c(310)),q=c(9963);function r(a){if("function"!=typeof WeakMap)return null;var b=new WeakMap,c=new WeakMap;return(r=function(a){return a?c:b})(a)}async function s(a,b,c,d,e,g,h){var i,j;if(!c)return b;let{icon:k,apple:l,openGraph:m,twitter:n,manifest:o}=c;if(k&&(g.icon=k),l&&(g.apple=l),n&&!(null==a||null==(i=a.twitter)?void 0:i.hasOwnProperty("images"))){let a=(0,f.resolveTwitter)({...b.twitter,images:n},b.metadataBase,{...d,isStaticMetadataRouteFile:!0},e.twitter);b.twitter=a}if(m&&!(null==a||null==(j=a.openGraph)?void 0:j.hasOwnProperty("images"))){let a=await (0,f.resolveOpenGraph)({...b.openGraph,images:m},b.metadataBase,h,{...d,isStaticMetadataRouteFile:!0},e.openGraph);b.openGraph=a}return o&&(b.manifest=o),b}async function t(a,b,{source:c,target:d,staticFilesMetadata:e,titleTemplates:i,metadataContext:j,buildState:m,leafSegmentStaticIcons:n}){let o=void 0!==(null==c?void 0:c.metadataBase)?c.metadataBase:d.metadataBase;for(let e in c)switch(e){case"title":d.title=(0,g.resolveTitle)(c.title,i.title);break;case"alternates":d.alternates=await (0,k.resolveAlternates)(c.alternates,o,b,j);break;case"openGraph":d.openGraph=await (0,f.resolveOpenGraph)(c.openGraph,o,b,j,i.openGraph);break;case"twitter":d.twitter=(0,f.resolveTwitter)(c.twitter,o,j,i.twitter);break;case"facebook":d.facebook=(0,k.resolveFacebook)(c.facebook);break;case"verification":d.verification=(0,k.resolveVerification)(c.verification);break;case"icons":d.icons=(0,l.resolveIcons)(c.icons);break;case"appleWebApp":d.appleWebApp=(0,k.resolveAppleWebApp)(c.appleWebApp);break;case"appLinks":d.appLinks=(0,k.resolveAppLinks)(c.appLinks);break;case"robots":d.robots=(0,k.resolveRobots)(c.robots);break;case"archives":case"assets":case"bookmarks":case"keywords":d[e]=(0,h.resolveAsArrayOrUndefined)(c[e]);break;case"authors":d[e]=(0,h.resolveAsArrayOrUndefined)(c.authors);break;case"itunes":d[e]=await (0,k.resolveItunes)(c.itunes,o,b,j);break;case"pagination":d.pagination=await (0,k.resolvePagination)(c.pagination,o,b,j);break;case"abstract":case"applicationName":case"description":case"generator":case"creator":case"publisher":case"category":case"classification":case"referrer":case"formatDetection":case"manifest":case"pinterest":d[e]=c[e]||null;break;case"other":d.other=Object.assign({},d.other,c.other);break;case"metadataBase":d.metadataBase=o;break;case"apple-touch-fullscreen":m.warnings.add(`Use appleWebApp instead
./frontend/.next/server/webpack-runtime.js:(()=>{"use strict";var a={},b={};function c(d){var e=b[d];if(void 0!==e)return e.exports;var f=b[d]={exports:{}},g=!0;try{a[d](f,f.exports,c),g=!1}finally{g&&delete b[d]}return f.exports}c.m=a,c.n=a=>{var b=a&&a.__esModule?()=>a.default:()=>a;return c.d(b,{a:b}),b},(()=>{var a,b=Object.getPrototypeOf?a=>Object.getPrototypeOf(a):a=>a.__proto__;c.t=function(d,e){if(1&e&&(d=this(d)),8&e||"object"==typeof d&&d&&(4&e&&d.__esModule||16&e&&"function"==typeof d.then))return d;var f=Object.create(null);c.r(f);var g={};a=a||[null,b({}),b([]),b(b)];for(var h=2&e&&d;"object"==typeof h&&!~a.indexOf(h);h=b(h))Object.getOwnPropertyNames(h).forEach(a=>g[a]=()=>d[a]);return g.default=()=>d,c.d(f,g),f}})(),c.d=(a,b)=>{for(var d in b)c.o(b,d)&&!c.o(a,d)&&Object.defineProperty(a,d,{enumerable:!0,get:b[d]})},c.f={},c.e=a=>Promise.all(Object.keys(c.f).reduce((b,d)=>(c.f[d](a,b),b),[])),c.u=a=>""+a+".js",c.o=(a,b)=>Object.prototype.hasOwnProperty.call(a,b),c.r=a=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},c.X=(a,b,d)=>{var e=b;d||(b=a,d=()=>c(c.s=e)),b.map(c.e,c);var f=d();return void 0===f?a:f},(()=>{var a={311:1},b=b=>{var d=b.modules,e=b.ids,f=b.runtime;for(var g in d)c.o(d,g)&&(c.m[g]=d[g]);f&&f(c);for(var h=0;h<e.length;h++)a[e[h]]=1};c.f.require=(d,e)=>{a[d]||(311!=d?b(require("./chunks/"+c.u(d))):a[d]=1)},module.exports=c,c.C=b})()})();
./frontend/.next/server/app/page.js.nft.json:{"version":1,"files":["../../../node_modules/next/dist/client/components/app-router-headers.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/index.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/package.json","../../../node_modules/next/dist/compiled/jsonwebtoken/index.js","../../../node_modules/next/dist/compiled/jsonwebtoken/package.json","../../../node_modules/next/dist/compiled/next-server/app-page.runtime.prod.js","../../../node_modules/next/dist/lib/client-and-server-references.js","../../../node_modules/next/dist/lib/constants.js","../../../node_modules/next/dist/lib/interop-default.js","../../../node_modules/next/dist/lib/is-error.js","../../../node_modules/next/dist/lib/semver-noop.js","../../../node_modules/next/dist/server/app-render/action-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/action-async-storage.external.js","../../../node_modules/next/dist/server/app-render/after-task-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/after-task-async-storage.external.js","../../../node_modules/next/dist/server/app-render/async-local-storage.js","../../../node_modules/next/dist/server/app-render/cache-signal.js","../../../node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js","../../../node_modules/next/dist/server/app-render/module-loading/track-module-loading.external.js","../../../node_modules/next/dist/server/app-render/module-loading/track-module-loading.instance.js","../../../node_modules/next/dist/server/app-render/work-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-async-storage.external.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage.external.js","../../../node_modules/next/dist/server/lib/cache-handlers/default.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/memory-cache.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/shared-cache-controls.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js","../../../node_modules/next/dist/server/lib/lru-cache.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-globals.external.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-node-extensions.js","../../../node_modules/next/dist/server/lib/trace/constants.js","../../../node_modules/next/dist/server/lib/trace/tracer.js","../../../node_modules/next/dist/server/load-manifest.external.js","../../../node_modules/next/dist/server/response-cache/types.js","../../../node_modules/next/dist/shared/lib/deep-freeze.js","../../../node_modules/next/dist/shared/lib/invariant-error.js","../../../node_modules/next/dist/shared/lib/is-plain-object.js","../../../node_modules/next/dist/shared/lib/is-thenable.js","../../../node_modules/next/dist/shared/lib/no-fallback-error.external.js","../../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js","../../../node_modules/next/dist/shared/lib/router/utils/app-paths.js","../../../node_modules/next/dist/shared/lib/router/utils/html-bots.js","../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js","../../../node_modules/next/dist/shared/lib/segment.js","../../../node_modules/next/dist/shared/lib/server-reference-info.js","../../../node_modules/next/package.json","../../package.json","../chunks/61.js","../chunks/72.js","../webpack-runtime.js","page_client-reference-manifest.js"]}
./frontend/.next/server/app/_not-found/page.js.nft.json:{"version":1,"files":["../../../../node_modules/next/dist/client/components/app-router-headers.js","../../../../node_modules/next/dist/compiled/@opentelemetry/api/index.js","../../../../node_modules/next/dist/compiled/@opentelemetry/api/package.json","../../../../node_modules/next/dist/compiled/jsonwebtoken/index.js","../../../../node_modules/next/dist/compiled/jsonwebtoken/package.json","../../../../node_modules/next/dist/compiled/next-server/app-page.runtime.prod.js","../../../../node_modules/next/dist/lib/client-and-server-references.js","../../../../node_modules/next/dist/lib/constants.js","../../../../node_modules/next/dist/lib/interop-default.js","../../../../node_modules/next/dist/lib/is-error.js","../../../../node_modules/next/dist/lib/semver-noop.js","../../../../node_modules/next/dist/server/app-render/action-async-storage-instance.js","../../../../node_modules/next/dist/server/app-render/action-async-storage.external.js","../../../../node_modules/next/dist/server/app-render/after-task-async-storage-instance.js","../../../../node_modules/next/dist/server/app-render/after-task-async-storage.external.js","../../../../node_modules/next/dist/server/app-render/async-local-storage.js","../../../../node_modules/next/dist/server/app-render/cache-signal.js","../../../../node_modules/next/dist/server/app-render/dynamic-access-async-storage-instance.js","../../../../node_modules/next/dist/server/app-render/dynamic-access-async-storage.external.js","../../../../node_modules/next/dist/server/app-render/module-loading/track-module-loading.external.js","../../../../node_modules/next/dist/server/app-render/module-loading/track-module-loading.instance.js","../../../../node_modules/next/dist/server/app-render/work-async-storage-instance.js","../../../../node_modules/next/dist/server/app-render/work-async-storage.external.js","../../../../node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js","../../../../node_modules/next/dist/server/app-render/work-unit-async-storage.external.js","../../../../node_modules/next/dist/server/lib/cache-handlers/default.external.js","../../../../node_modules/next/dist/server/lib/incremental-cache/memory-cache.external.js","../../../../node_modules/next/dist/server/lib/incremental-cache/shared-cache-controls.external.js","../../../../node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js","../../../../node_modules/next/dist/server/lib/lru-cache.js","../../../../node_modules/next/dist/server/lib/router-utils/instrumentation-globals.external.js","../../../../node_modules/next/dist/server/lib/router-utils/instrumentation-node-extensions.js","../../../../node_modules/next/dist/server/lib/trace/constants.js","../../../../node_modules/next/dist/server/lib/trace/tracer.js","../../../../node_modules/next/dist/server/load-manifest.external.js","../../../../node_modules/next/dist/server/response-cache/types.js","../../../../node_modules/next/dist/shared/lib/deep-freeze.js","../../../../node_modules/next/dist/shared/lib/invariant-error.js","../../../../node_modules/next/dist/shared/lib/is-plain-object.js","../../../../node_modules/next/dist/shared/lib/is-thenable.js","../../../../node_modules/next/dist/shared/lib/no-fallback-error.external.js","../../../../node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js","../../../../node_modules/next/dist/shared/lib/router/utils/app-paths.js","../../../../node_modules/next/dist/shared/lib/router/utils/html-bots.js","../../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js","../../../../node_modules/next/dist/shared/lib/segment.js","../../../../node_modules/next/dist/shared/lib/server-reference-info.js","../../../../node_modules/next/package.json","../../../package.json","../../chunks/61.js","../../chunks/72.js","../../webpack-runtime.js","page_client-reference-manifest.js"]}
./frontend/.next/server/server-reference-manifest.js:self.__RSC_SERVER_MANIFEST="{\"node\":{},\"edge\":{},\"encryptionKey\":\"process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY\"}"
./frontend/.next/server/pages/_document.js.nft.json:{"version":1,"files":["../../../node_modules/client-only/index.js","../../../node_modules/client-only/package.json","../../../node_modules/next/dist/client/components/app-router-headers.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/index.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/package.json","../../../node_modules/next/dist/compiled/jsonwebtoken/index.js","../../../node_modules/next/dist/compiled/jsonwebtoken/package.json","../../../node_modules/next/dist/compiled/next-server/pages.runtime.prod.js","../../../node_modules/next/dist/lib/client-and-server-references.js","../../../node_modules/next/dist/lib/constants.js","../../../node_modules/next/dist/lib/interop-default.js","../../../node_modules/next/dist/lib/is-error.js","../../../node_modules/next/dist/lib/semver-noop.js","../../../node_modules/next/dist/pages/_document.js","../../../node_modules/next/dist/server/app-render/async-local-storage.js","../../../node_modules/next/dist/server/app-render/work-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-async-storage.external.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage.external.js","../../../node_modules/next/dist/server/lib/cache-handlers/default.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/memory-cache.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/shared-cache-controls.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js","../../../node_modules/next/dist/server/lib/lru-cache.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-globals.external.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-node-extensions.js","../../../node_modules/next/dist/server/lib/trace/constants.js","../../../node_modules/next/dist/server/lib/trace/tracer.js","../../../node_modules/next/dist/server/load-manifest.external.js","../../../node_modules/next/dist/server/response-cache/types.js","../../../node_modules/next/dist/shared/lib/deep-freeze.js","../../../node_modules/next/dist/shared/lib/invariant-error.js","../../../node_modules/next/dist/shared/lib/is-plain-object.js","../../../node_modules/next/dist/shared/lib/is-thenable.js","../../../node_modules/next/dist/shared/lib/server-reference-info.js","../../../node_modules/next/package.json","../../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js","../../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js","../../../node_modules/react-dom/cjs/react-dom-server.browser.development.js","../../../node_modules/react-dom/cjs/react-dom-server.browser.production.js","../../../node_modules/react-dom/cjs/react-dom-server.edge.development.js","../../../node_modules/react-dom/cjs/react-dom-server.edge.production.js","../../../node_modules/react-dom/cjs/react-dom.development.js","../../../node_modules/react-dom/cjs/react-dom.production.js","../../../node_modules/react-dom/index.js","../../../node_modules/react-dom/package.json","../../../node_modules/react-dom/server.browser.js","../../../node_modules/react-dom/server.edge.js","../../../node_modules/react/cjs/react-jsx-runtime.development.js","../../../node_modules/react/cjs/react-jsx-runtime.production.js","../../../node_modules/react/cjs/react.development.js","../../../node_modules/react/cjs/react.production.js","../../../node_modules/react/index.js","../../../node_modules/react/jsx-runtime.js","../../../node_modules/react/package.json","../../../node_modules/styled-jsx/dist/index/index.js","../../../node_modules/styled-jsx/index.js","../../../node_modules/styled-jsx/package.json","../../../package.json","../../package.json","../chunks/611.js","../webpack-runtime.js"]}
./frontend/.next/server/pages/_error.js.nft.json:{"version":1,"files":["../../../node_modules/client-only/index.js","../../../node_modules/client-only/package.json","../../../node_modules/next/dist/client/components/app-router-headers.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/index.js","../../../node_modules/next/dist/compiled/@opentelemetry/api/package.json","../../../node_modules/next/dist/compiled/jsonwebtoken/index.js","../../../node_modules/next/dist/compiled/jsonwebtoken/package.json","../../../node_modules/next/dist/compiled/next-server/pages.runtime.prod.js","../../../node_modules/next/dist/lib/client-and-server-references.js","../../../node_modules/next/dist/lib/constants.js","../../../node_modules/next/dist/lib/interop-default.js","../../../node_modules/next/dist/lib/is-error.js","../../../node_modules/next/dist/lib/semver-noop.js","../../../node_modules/next/dist/server/app-render/async-local-storage.js","../../../node_modules/next/dist/server/app-render/work-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-async-storage.external.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js","../../../node_modules/next/dist/server/app-render/work-unit-async-storage.external.js","../../../node_modules/next/dist/server/lib/cache-handlers/default.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/memory-cache.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/shared-cache-controls.external.js","../../../node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js","../../../node_modules/next/dist/server/lib/lru-cache.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-globals.external.js","../../../node_modules/next/dist/server/lib/router-utils/instrumentation-node-extensions.js","../../../node_modules/next/dist/server/lib/trace/constants.js","../../../node_modules/next/dist/server/lib/trace/tracer.js","../../../node_modules/next/dist/server/load-manifest.external.js","../../../node_modules/next/dist/server/response-cache/types.js","../../../node_modules/next/dist/shared/lib/deep-freeze.js","../../../node_modules/next/dist/shared/lib/invariant-error.js","../../../node_modules/next/dist/shared/lib/is-plain-object.js","../../../node_modules/next/dist/shared/lib/is-thenable.js","../../../node_modules/next/dist/shared/lib/no-fallback-error.external.js","../../../node_modules/next/dist/shared/lib/server-reference-info.js","../../../node_modules/next/package.json","../../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js","../../../node_modules/react-dom/cjs/react-dom-server-legacy.browser.production.js","../../../node_modules/react-dom/cjs/react-dom-server.browser.development.js","../../../node_modules/react-dom/cjs/react-dom-server.browser.production.js","../../../node_modules/react-dom/cjs/react-dom-server.edge.development.js","../../../node_modules/react-dom/cjs/react-dom-server.edge.production.js","../../../node_modules/react-dom/cjs/react-dom.development.js","../../../node_modules/react-dom/cjs/react-dom.production.js","../../../node_modules/react-dom/index.js","../../../node_modules/react-dom/package.json","../../../node_modules/react-dom/server.browser.js","../../../node_modules/react-dom/server.edge.js","../../../node_modules/react/cjs/react-jsx-runtime.development.js","../../../node_modules/react/cjs/react-jsx-runtime.production.js","../../../node_modules/react/cjs/react.development.js","../../../node_modules/react/cjs/react.production.js","../../../node_modules/react/index.js","../../../node_modules/react/jsx-runtime.js","../../../node_modules/react/package.json","../../../node_modules/styled-jsx/dist/index/index.js","../../../node_modules/styled-jsx/index.js","../../../node_modules/styled-jsx/package.json","../../package.json","../chunks/611.js","../webpack-runtime.js"]}
./frontend/.next/types/app/page.ts:  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
./frontend/.next/types/app/page.ts:// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
./frontend/.next/types/app/page.ts:type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
./frontend/.next/types/app/page.ts:type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>
./frontend/.next/types/app/page.ts:function checkFields<_ extends { [k in keyof any]: never }>() {}
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4",
./frontend/package-lock.json:        "js-tokens": "^4.0.0",
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:    "node_modules/@csstools/css-tokenizer": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@csstools/css-tokenizer/-/css-tokenizer-3.0.4.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.3"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:    "node_modules/@typescript-eslint/visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.44.0.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^4.2.1"
./frontend/package-lock.json:    "node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
./frontend/package-lock.json:        "js-tokens": "^9.0.1"
./frontend/package-lock.json:    "node_modules/ast-v8-to-istanbul/node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
./frontend/package-lock.json:        "path-key": "^3.1.0",
./frontend/package-lock.json:        "object-keys": "^1.1.1"
./frontend/package-lock.json:        "object-keys": "^1.1.1",
./frontend/package-lock.json:        "own-keys": "^1.0.1",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.3",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "7.18.0"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "7.18.0",
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-7.18.0.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.3"
./frontend/package-lock.json:    "node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.1"
./frontend/package-lock.json:        "keyv": "^4.5.3",
./frontend/package-lock.json:    "node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
./frontend/package-lock.json:    "node_modules/keyv": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
./frontend/package-lock.json:        "js-tokens": "^3.0.0 || ^4.0.0"
./frontend/package-lock.json:    "node_modules/object-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
./frontend/package-lock.json:        "object-keys": "^1.1.1"
./frontend/package-lock.json:    "node_modules/own-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/own-keys/-/own-keys-1.0.1.tgz",
./frontend/package-lock.json:        "object-keys": "^1.1.1",
./frontend/package-lock.json:    "node_modules/path-key": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
./frontend/package-lock.json:        "js-tokens": "^9.0.1"
./frontend/package-lock.json:    "node_modules/strip-literal/node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
./frontend/package-lock.json:      "integrity": "sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==",
