./analysis/20250920/npm-licenses.json:  "@csstools/css-tokenizer@3.0.4": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@csstools/css-tokenizer",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@csstools/css-tokenizer/LICENSE.md"
./analysis/20250920/npm-licenses.json:  "@typescript-eslint/visitor-keys@7.18.0": {
./analysis/20250920/npm-licenses.json:  "@typescript-eslint/visitor-keys@8.44.0": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "eslint-visitor-keys@3.4.3": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/eslint/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/eslint-visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "eslint-visitor-keys@4.2.1": {
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "js-tokens@4.0.0": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/lydell/js-tokens",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/js-tokens",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/js-tokens/LICENSE"
./analysis/20250920/npm-licenses.json:  "js-tokens@9.0.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/lydell/js-tokens",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/ast-v8-to-istanbul/node_modules/js-tokens",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/ast-v8-to-istanbul/node_modules/js-tokens/LICENSE"
./analysis/20250920/npm-licenses.json:  "keyv@4.5.4": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/jaredwray/keyv",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/keyv",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/keyv/README.md"
./analysis/20250920/npm-licenses.json:  "object-keys@1.1.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/ljharb/object-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/object-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/object-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "own-keys@1.0.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/ljharb/own-keys",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/own-keys",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/own-keys/LICENSE"
./analysis/20250920/npm-licenses.json:  "path-key@3.1.1": {
./analysis/20250920/npm-licenses.json:    "repository": "https://github.com/sindresorhus/path-key",
./analysis/20250920/npm-licenses.json:    "path": "/workspaces/ai-orchestrator-hub/frontend/node_modules/path-key",
./analysis/20250920/npm-licenses.json:    "licenseFile": "/workspaces/ai-orchestrator-hub/frontend/node_modules/path-key/license"
./backend/src/utils/auth.rs://! - JWT-based authentication with refresh tokens
./backend/src/utils/auth.rs://! - API key management for service-to-service communication
./backend/src/utils/auth.rs:    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
./backend/src/utils/auth.rs:use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
./backend/src/utils/auth.rs:    pub refresh_token: Option<String>,
./backend/src/utils/auth.rs:    pub key_id: String,
./backend/src/utils/auth.rs:    pub key_hash: String,
./backend/src/utils/auth.rs:    /// JWT encoding key
./backend/src/utils/auth.rs:    encoding_key: EncodingKey,
./backend/src/utils/auth.rs:    /// JWT decoding key
./backend/src/utils/auth.rs:    decoding_key: DecodingKey,
./backend/src/utils/auth.rs:    /// API keys
./backend/src/utils/auth.rs:    api_keys: Arc<RwLock<HashMap<String, ApiKey>>>,
./backend/src/utils/auth.rs:    /// Refresh token timeout
./backend/src/utils/auth.rs:        jwt_secret: &str,
./backend/src/utils/auth.rs:        let encoding_key = EncodingKey::from_secret(jwt_secret.as_ref());
./backend/src/utils/auth.rs:        let decoding_key = DecodingKey::from_secret(jwt_secret.as_ref());
./backend/src/utils/auth.rs:            encoding_key,
./backend/src/utils/auth.rs:            decoding_key,
./backend/src/utils/auth.rs:            api_keys: Arc::new(RwLock::new(HashMap::new())),
./backend/src/utils/auth.rs:    /// Hash an API key using Argon2id with OWASP-recommended parameters
./backend/src/utils/auth.rs:    fn hash_api_key(api_key: &str) -> HiveResult<String> {
./backend/src/utils/auth.rs:        let password_hash = argon2
./backend/src/utils/auth.rs:            .hash_password(api_key.as_bytes(), &salt)
./backend/src/utils/auth.rs:                reason: format!("Failed to hash API key: {e}"),
./backend/src/utils/auth.rs:        Ok(password_hash)
./backend/src/utils/auth.rs:    /// Verify an API key against a hash using Argon2id
./backend/src/utils/auth.rs:    fn verify_api_key(api_key: &str, hash: &str) -> HiveResult<bool> {
./backend/src/utils/auth.rs:            reason: format!("Invalid password hash format: {e}"),
./backend/src/utils/auth.rs:            .verify_password(api_key.as_bytes(), &parsed_hash)
./backend/src/utils/auth.rs:            refresh_token: Some(Uuid::new_v4().to_string()),
./backend/src/utils/auth.rs:        // Generate JWT token
./backend/src/utils/auth.rs:        let token = encode(&Header::default(), &claims, &self.encoding_key).map_err(|e| {
./backend/src/utils/auth.rs:        Ok((token, session_id))
./backend/src/utils/auth.rs:    /// Validate JWT token and return claims
./backend/src/utils/auth.rs:    pub async fn validate_token(&self, token: &str) -> HiveResult<Claims> {
./backend/src/utils/auth.rs:        let token_data = decode::<Claims>(token, &self.decoding_key, &validation).map_err(|e| {
./backend/src/utils/auth.rs:                reason: format!("Invalid JWT token: {e}"),
./backend/src/utils/auth.rs:        let claims = token_data.claims;
./backend/src/utils/auth.rs:    /// Refresh JWT token
./backend/src/utils/auth.rs:    pub async fn refresh_token(&self, refresh_token: &str) -> HiveResult<String> {
./backend/src/utils/auth.rs:        // Find session by refresh token
./backend/src/utils/auth.rs:            .find(|s| s.refresh_token.as_ref() == Some(&refresh_token.to_string()))
./backend/src/utils/auth.rs:                reason: "Invalid refresh token".to_string(),
./backend/src/utils/auth.rs:        // Generate new JWT token
./backend/src/utils/auth.rs:        let token = encode(&Header::default(), &claims, &self.encoding_key).map_err(|e| {
./backend/src/utils/auth.rs:        Ok(token)
./backend/src/utils/auth.rs:    /// Create API key for service authentication
./backend/src/utils/auth.rs:    pub async fn create_api_key(
./backend/src/utils/auth.rs:        let key_id = Uuid::new_v4().to_string();
./backend/src/utils/auth.rs:        let api_key = Uuid::new_v4().to_string();
./backend/src/utils/auth.rs:        let key_hash = Self::hash_api_key(&api_key)?;
./backend/src/utils/auth.rs:        let api_key_obj = ApiKey {
./backend/src/utils/auth.rs:            key_id: key_id.clone(),
./backend/src/utils/auth.rs:            key_hash,
./backend/src/utils/auth.rs:        let mut api_keys = self.api_keys.write().await;
./backend/src/utils/auth.rs:        api_keys.insert(key_id.clone(), api_key_obj);
./backend/src/utils/auth.rs:        Ok((key_id, api_key))
./backend/src/utils/auth.rs:    /// Validate API key
./backend/src/utils/auth.rs:    pub async fn validate_api_key(&self, api_key: &str) -> HiveResult<HashSet<Permission>> {
./backend/src/utils/auth.rs:        let mut api_keys = self.api_keys.write().await;
./backend/src/utils/auth.rs:        for (_, key_obj) in api_keys.iter_mut() {
./backend/src/utils/auth.rs:            if Self::verify_api_key(api_key, &key_obj.key_hash)? {
./backend/src/utils/auth.rs:                if let Some(expires_at) = key_obj.expires_at {
./backend/src/utils/auth.rs:                            reason: "API key expired".to_string(),
./backend/src/utils/auth.rs:                key_obj.last_used = Some(Utc::now());
./backend/src/utils/auth.rs:                key_obj.usage_count += 1;
./backend/src/utils/auth.rs:                return Ok(key_obj.permissions.clone());
./backend/src/utils/auth.rs:            reason: "Invalid API key".to_string(),
./backend/src/utils/auth.rs:            let Some(token) = auth_header else {
./backend/src/utils/auth.rs:                // Check for API key
./backend/src/utils/auth.rs:                if let Some(api_key) = req.headers().get("X-API-Key").and_then(|h| h.to_str().ok())
./backend/src/utils/auth.rs:                    match auth_manager.validate_api_key(api_key).await {
./backend/src/utils/auth.rs:            // Validate JWT token
./backend/src/utils/auth.rs:            match auth_manager.validate_token(token).await {
./backend/src/utils/auth.rs:        let (token, session_id) = auth_manager
./backend/src/utils/auth.rs:        assert!(!token.is_empty());
./backend/src/utils/auth.rs:        // Test token validation
./backend/src/utils/auth.rs:        let claims = auth_manager.validate_token(&token).await?;
./backend/src/utils/auth.rs:        // Create API key
./backend/src/utils/auth.rs:        let (key_id, api_key) = auth_manager
./backend/src/utils/auth.rs:            .create_api_key(
./backend/src/utils/auth.rs:        assert!(!key_id.is_empty());
./backend/src/utils/auth.rs:        assert!(!api_key.is_empty());
./backend/src/utils/auth.rs:        // Validate API key
./backend/src/utils/auth.rs:        let validated_permissions = auth_manager.validate_api_key(&api_key).await?;
./backend/src/utils/auth.rs:        let hash = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        // Verify the password against the hash
./backend/src/utils/auth.rs:        let is_valid = AuthManager::verify_api_key(api_key, &hash)?;
./backend/src/utils/auth.rs:        // Verify that wrong password fails
./backend/src/utils/auth.rs:        let is_valid_wrong = AuthManager::verify_api_key("wrong_password", &hash)?;
./backend/src/utils/auth.rs:        // Hash the same password multiple times
./backend/src/utils/auth.rs:        let hash1 = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        let hash2 = AuthManager::hash_api_key(api_key)?;
./backend/src/utils/auth.rs:        let is_valid1 = AuthManager::verify_api_key(api_key, &hash1)?;
./backend/src/utils/auth.rs:        let is_valid2 = AuthManager::verify_api_key(api_key, &hash2)?;
./backend/src/utils/structured_logging.rs:    pub fn with_data(mut self, key: &str, value: &str) -> Self {
./backend/src/utils/structured_logging.rs:            .insert(key.to_string(), value.to_string());
./backend/src/utils/error_handling.rs:    pub fn get_string(value: &Value, key: &str) -> HiveResult<String> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid string field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_number(value: &Value, key: &str) -> HiveResult<f64> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid number field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_boolean(value: &Value, key: &str) -> HiveResult<bool> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid boolean field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_array<'a>(value: &'a Value, key: &str) -> HiveResult<Vec<&'a Value>> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid array field: {}", key),
./backend/src/utils/error_handling.rs:        key: &str,
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:                field: key.to_string(),
./backend/src/utils/error_handling.rs:                reason: format!("Missing or invalid object field: {}", key),
./backend/src/utils/error_handling.rs:    pub fn get_optional_string(value: &Value, key: &str) -> Option<String> {
./backend/src/utils/error_handling.rs:            .get(key)
./backend/src/utils/error_handling.rs:    pub fn get_optional_number(value: &Value, key: &str) -> Option<f64> {
./backend/src/utils/error_handling.rs:        value.get(key).and_then(|v| v.as_f64())
./backend/src/utils/error_handling.rs:    pub fn get_optional_boolean(value: &Value, key: &str) -> Option<bool> {
./backend/src/utils/error_handling.rs:        value.get(key).and_then(|v| v.as_bool())
./backend/src/utils/validate_centralized_error_handling.rs:    // Test that key error types exist and can be created
./backend/src/utils/error.rs:    #[error("Cache error: {operation}, key: {key}, reason: {reason}")]
./backend/src/utils/error.rs:        key: String,
./backend/src/utils/error.rs:    #[error("Cache miss: {key}")]
./backend/src/utils/error.rs:    CacheMiss { key: String },
./backend/src/utils/error.rs:    #[error("Environment configuration missing: {envname}, required_key: {requiredkey}")]
./backend/src/utils/error.rs:        requiredkey: String,
./backend/src/utils/error.rs:    #[error("Secret management failed: {secretname}, operation: {operation}")]
./backend/src/utils/error.rs:        secretname: String,
./backend/src/utils/error.rs:        "Configuration override conflict: {overridekey}, source1: {source1}, source2: {source2}"
./backend/src/utils/error.rs:        overridekey: String,
./backend/src/utils/error.rs:    pub fn with_info(mut self, key: &str, value: &str) -> Self {
./backend/src/utils/error.rs:            .insert(key.to_string(), value.to_string());
./backend/src/utils/error_recovery.rs:        let key = format!("{}:{}", context.component, context.operation);
./backend/src/utils/error_recovery.rs:        history.entry(key).or_insert_with(Vec::new).push(result);
./backend/src/utils/error_recovery.rs:        let key = format!("{}:{}", context.component, context.operation);
./backend/src/utils/error_recovery.rs:        if let Some(results) = history.get(&key) {
./backend/src/utils/error_recovery.rs:    fn safe_get(&self, key: &str) -> HiveResult<&serde_json::Value>;
./backend/src/utils/error_recovery.rs:    fn safe_get_str(&self, key: &str) -> HiveResult<&str>;
./backend/src/utils/error_recovery.rs:    fn safe_get_u64(&self, key: &str) -> HiveResult<u64>;
./backend/src/utils/error_recovery.rs:    fn safe_get_f64(&self, key: &str) -> HiveResult<f64>;
./backend/src/utils/error_recovery.rs:    fn safe_get_bool(&self, key: &str) -> HiveResult<bool>;
./backend/src/utils/error_recovery.rs:    fn safe_get(&self, key: &str) -> HiveResult<&serde_json::Value> {
./backend/src/utils/error_recovery.rs:        self.get(key).ok_or_else(|| HiveError::ValidationError {
./backend/src/utils/error_recovery.rs:            field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_str(&self, key: &str) -> HiveResult<&str> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_u64(&self, key: &str) -> HiveResult<u64> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_f64(&self, key: &str) -> HiveResult<f64> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/error_recovery.rs:    fn safe_get_bool(&self, key: &str) -> HiveResult<bool> {
./backend/src/utils/error_recovery.rs:        self.safe_get(key)?
./backend/src/utils/error_recovery.rs:                field: key.to_string(),
./backend/src/utils/config.rs:        for (key, value) in override_config.component_health_scores {
./backend/src/utils/config.rs:            merged_health_scores.insert(key, value);
./backend/src/utils/config.rs:        for (key, value) in override_config.component_issues {
./backend/src/utils/config.rs:            merged_issues.insert(key, value);
./backend/src/utils/config.rs:        for (key, value) in override_config.component_recommendations {
./backend/src/utils/config.rs:            merged_recommendations.insert(key, value);
./backend/src/agents/collaborative_learning.rs:            &problem_data.keywords,
./backend/src/agents/collaborative_learning.rs:                format!("Collaborative solution for: {}", problem_data.keywords.join(", ")),
./backend/src/agents/collaborative_learning.rs:                problem_data.keywords.clone(),
./backend/src/agents/collaborative_learning.rs:        problem_keywords: &[String],
./backend/src/agents/collaborative_learning.rs:            for keyword in problem_keywords {
./backend/src/agents/collaborative_learning.rs:                if knowledge.content.to_lowercase().contains(&keyword.to_lowercase()) {
./backend/src/agents/collaborative_learning.rs:                    if tag.to_lowercase().contains(&keyword.to_lowercase()) {
./backend/src/agents/collaborative_learning.rs:        assert!(system.knowledge_base.contains_key(&knowledge_id));
./backend/src/agents/collaborative_learning.rs:        assert!(system.active_sessions.contains_key(&session_id));
./backend/src/agents/self_healing_swarm.rs:                    if !self.active_recoveries.contains_key(agent_id) {
./backend/src/agents/self_healing_swarm.rs:                    if self.active_recoveries.contains_key(agent_id) {
./backend/src/agents/self_healing_swarm.rs:        let strategy_key = format!("{:?}", strategy);
./backend/src/agents/self_healing_swarm.rs:            .get(&strategy_key)
./backend/src/agents/self_healing_swarm.rs:        self.learned_thresholds.insert(strategy_key, new_confidence);
./backend/src/agents/self_healing_swarm.rs:                let pattern_key =
./backend/src/agents/self_healing_swarm.rs:                    .get(&pattern_key)
./backend/src/agents/self_healing_swarm.rs:                self.learned_thresholds.insert(pattern_key, new_confidence);
./backend/src/agents/agent.rs:                let tokens: Vec<String> = insight
./backend/src/agents/agent.rs:                let sentiment = nlp_processor.analyze_sentiment(&tokens);
./backend/src/agents/agent.rs:                let pattern_key = format!(
./backend/src/agents/agent.rs:                    .get(&pattern_key)
./backend/src/agents/agent.rs:                    .insert(pattern_key, new_strength.clamp(-1.0, 1.0));
./backend/src/agents/skill_evolution.rs:            let agent_id = *agent_entry.key();
./backend/src/agents/skill_evolution.rs:                    .keys()
./backend/src/agents/simple_verification.rs:    KeywordPresence { keywords: Vec<String> },
./backend/src/agents/simple_verification.rs:                RuleType::KeywordPresence { keywords } => {
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_presence(
./backend/src/agents/simple_verification.rs:                        keywords,
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_absence(
./backend/src/agents/simple_verification.rs:                RuleType::KeywordPresence { keywords } => {
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_presence(
./backend/src/agents/simple_verification.rs:                        keywords,
./backend/src/agents/simple_verification.rs:                    SimpleVerificationSystem::check_keyword_absence(
./backend/src/agents/simple_verification.rs:                    tokens: output.split_whitespace().map(str::to_string).collect(),
./backend/src/agents/simple_verification.rs:                    keywords: Vec::new(),
./backend/src/agents/simple_verification.rs:                tokens: goal.split_whitespace().map(str::to_string).collect(),
./backend/src/agents/simple_verification.rs:                keywords: Vec::new(),
./backend/src/agents/simple_verification.rs:        let tokens: Vec<String> = output.split_whitespace().map(str::to_string).collect();
./backend/src/agents/simple_verification.rs:        let sentiment = self.nlp_processor.analyze_sentiment(&tokens);
./backend/src/agents/simple_verification.rs:    fn check_keyword_presence(
./backend/src/agents/simple_verification.rs:        keywords: &[String],
./backend/src/agents/simple_verification.rs:        let mut found_keywords = 0;
./backend/src/agents/simple_verification.rs:        for keyword in keywords {
./backend/src/agents/simple_verification.rs:            if output_lower.contains(&keyword.to_lowercase()) {
./backend/src/agents/simple_verification.rs:                found_keywords += 1;
./backend/src/agents/simple_verification.rs:        let score = f64::from(found_keywords) / keywords.len() as f64;
./backend/src/agents/simple_verification.rs:            let missing_keywords: Vec<String> = keywords
./backend/src/agents/simple_verification.rs:                .filter(|keyword| !output_lower.contains(&keyword.to_lowercase()))
./backend/src/agents/simple_verification.rs:                description: format!("Missing required keywords: {}", missing_keywords.join(", ")),
./backend/src/agents/simple_verification.rs:                suggestion: Some("Include all required keywords in the output".to_string()),
./backend/src/agents/simple_verification.rs:    fn check_keyword_absence(
./backend/src/agents/simple_verification.rs:        let tier_key = format!("{:?}", result.verification_tier);
./backend/src/agents/simple_verification.rs:        *metrics.tier_usage.entry(tier_key).or_insert(0) += 1;
./backend/src/agents/multimodal_agent.rs:            if text.keywords.iter().any(|k| k.contains("quality")) && data.quality_score < 0.6 {
./backend/src/agents/multimodal_agent.rs:        if input.to_lowercase().contains("password") && input.contains("=") {
./backend/src/agents/multimodal_agent.rs:                description: "Hardcoded password detected".to_string(),
./backend/src/agents/multimodal_agent.rs:            // Text quality based on sentiment and keyword richness
./backend/src/agents/multimodal_agent.rs:                              (text.keywords.len() as f64 / 10.0).min(1.0) * 0.3;
./backend/src/agents/multimodal_agent.rs:            let text_complexity = (text.keywords.len() as f64 / 20.0).min(1.0);
./backend/src/agents/multimodal_agent.rs:            let modality_key = format!("{:?}", modality);
./backend/src/agents/multimodal_agent.rs:            *self.performance_metrics.analyses_by_modality.entry(modality_key.clone()).or_insert(0) += 1;
./backend/src/agents/multimodal_agent.rs:            let current_avg = self.performance_metrics.avg_processing_time.get(&modality_key).copied().unwrap_or(0.0);
./backend/src/agents/multimodal_agent.rs:            let count = self.performance_metrics.analyses_by_modality[&modality_key] as f64;
./backend/src/agents/multimodal_agent.rs:            self.performance_metrics.avg_processing_time.insert(modality_key, new_avg);
./backend/src/agents/verification_engine.rs:        self.strategies.keys().cloned().collect()
./backend/src/agents/verification_engine.rs:        let goal_tokens: Vec<String> = original_goal.split_whitespace()
./backend/src/agents/verification_engine.rs:        let result_tokens: Vec<String> = result_output.split_whitespace()
./backend/src/agents/verification_engine.rs:        let goal_sentiment = self.nlp_processor.analyze_sentiment(&goal_tokens);
./backend/src/agents/verification_engine.rs:        let result_sentiment = self.nlp_processor.analyze_sentiment(&result_tokens);
./backend/src/agents/verification_engine.rs:        // Calculate keyword overlap
./backend/src/agents/verification_engine.rs:        let goal_keywords: std::collections::HashSet<_> = goal_tokens.iter().collect();
./backend/src/agents/verification_engine.rs:        let result_keywords: std::collections::HashSet<_> = result_tokens.iter().collect();
./backend/src/agents/verification_engine.rs:        let intersection_size = goal_keywords.intersection(&result_keywords).count();
./backend/src/agents/verification_engine.rs:        let union_size = goal_keywords.union(&result_keywords).count();
./backend/src/agents/verification_engine.rs:        let keyword_overlap = if union_size > 0 {
./backend/src/agents/verification_engine.rs:        let alignment_score = (sentiment_alignment * 0.4) + (keyword_overlap * 0.6);
./backend/src/agents/verification_engine.rs:        debug!("Goal alignment analysis: sentiment={:.3}, keywords={:.3}, total={:.3}",
./backend/src/agents/verification_engine.rs:               sentiment_alignment, keyword_overlap, alignment_score);
./backend/src/agents/memory.rs:            learned_strategy: Some("focus on key patterns".to_string()),
./backend/src/agents/adaptive_verification.rs:            .flat_map(|outcome| outcome.rule_thresholds_used.keys())
./backend/src/agents/adaptive_verification.rs:            .filter(|outcome| outcome.rule_thresholds_used.contains_key(rule_id))
./backend/src/agents/agent_evolution.rs:        let species_key = self.determine_species(&genome);
./backend/src/agents/agent_evolution.rs:            .entry(species_key)
./backend/src/agents/agent_evolution.rs:            let species_key = self.determine_species(genome);
./backend/src/agents/agent_evolution.rs:            let species_size = self.species_registry.get(&species_key).map_or(1, |v| v.len());
./backend/src/agents/agent_evolution.rs:        assert!(system.genomes.contains_key(&agent.id));
./backend/src/agents/verification_strategies.rs:        let tokens: Vec<String> = original_goal.split_whitespace()
./backend/src/agents/verification_strategies.rs:        // Extract key verbs (action words)
./backend/src/agents/verification_strategies.rs:        let actions: Vec<String> = tokens.iter()
./backend/src/agents/verification_strategies.rs:            .filter(|token| action_words.contains(&token.as_str()))
./backend/src/agents/verification_strategies.rs:        // Extract key nouns (target objects)
./backend/src/agents/verification_strategies.rs:        let targets: Vec<String> = tokens.iter()
./backend/src/agents/verification_strategies.rs:            .filter(|token| target_indicators.contains(&token.as_str()))
./backend/src/communication/protocols.rs:    pub fn with_metadata(mut self, key: String, value: serde_json::Value) -> Self {
./backend/src/communication/protocols.rs:        self.metadata.insert(key, value);
./backend/src/communication/patterns.rs:    pub async fn get_connection(&self, key: &str) -> CommunicationResult<CommunicationChannel> {
./backend/src/communication/patterns.rs:        if let Some(channel) = connections.get(key) {
./backend/src/communication/patterns.rs:            reason: format!("Connection not found for key: {}", key),
./backend/src/communication/patterns.rs:    pub async fn add_connection(&self, key: String, channel: CommunicationChannel) {
./backend/src/communication/patterns.rs:        connections.insert(key, channel);
./backend/src/communication/patterns.rs:    pub async fn remove_connection(&self, key: &str) {
./backend/src/communication/patterns.rs:        connections.remove(key);
./backend/src/communication/mcp.rs:            "keywords": text.split_whitespace().take(5).collect::<Vec<_>>(),
./backend/src/server.rs:    password: String,
./backend/src/server.rs:    token: String,
./backend/src/server.rs:    refresh_token: String,
./backend/src/server.rs:/// Refresh token request
./backend/src/server.rs:    refresh_token: String,
./backend/src/server.rs:        let token = match auth_header {
./backend/src/server.rs:            Some(token) => token,
./backend/src/server.rs:                        "error": "Missing authorization token"
./backend/src/server.rs:        // In production, you'd validate the token here
./backend/src/server.rs:    if payload.username.is_empty() || payload.password.is_empty() {
./backend/src/server.rs:    // Generate JWT token
./backend/src/server.rs:    let (token, session_id) = state.auth_manager.authenticate_user(
./backend/src/server.rs:        token,
./backend/src/server.rs:        refresh_token: session_id.clone(), // Using session_id as refresh token for demo
./backend/src/server.rs:async fn refresh_token(
./backend/src/server.rs:    // Refresh the token
./backend/src/server.rs:    let new_token = state.auth_manager.refresh_token(&payload.refresh_token).await.map_err(|e| {
./backend/src/server.rs:                "error": "Invalid refresh token",
./backend/src/server.rs:        "token": new_token,
./backend/src/server.rs:            warn!("🚫 [{}] No authentication token provided", request_id);
./backend/src/server.rs:        .route("/api/auth/refresh", axum::routing::post(refresh_token))
./backend/src/neural/nlp.rs:    pub keywords: Vec<String>,
./backend/src/neural/nlp.rs:        let tokens = self.tokenize(text);
./backend/src/neural/nlp.rs:        let semantic_vector = self.generate_semantic_vector(&tokens).await;
./backend/src/neural/nlp.rs:        let sentiment = self.analyze_sentiment(&tokens);
./backend/src/neural/nlp.rs:        let keywords = self.extract_keywords(text, 5).await;
./backend/src/neural/nlp.rs:        let patterns = self.identify_patterns(&tokens).await;
./backend/src/neural/nlp.rs:            tokens,
./backend/src/neural/nlp.rs:            keywords,
./backend/src/neural/nlp.rs:        self.update_vocabulary(&processed_input.tokens, success)
./backend/src/neural/nlp.rs:        self.update_vocabulary(&processed_output.tokens, success)
./backend/src/neural/nlp.rs:                    pattern.keywords.join(" "),
./backend/src/neural/nlp.rs:                    pattern.keywords.join(" ")
./backend/src/neural/nlp.rs:    fn tokenize(&self, text: &str) -> Vec<String> {
./backend/src/neural/nlp.rs:    async fn generate_semantic_vector(&self, tokens: &[String]) -> SemanticVector {
./backend/src/neural/nlp.rs:        for (i, token) in tokens.iter().enumerate() {
./backend/src/neural/nlp.rs:            let weight = vocabulary.get(token).copied().unwrap_or(0.1);
./backend/src/neural/nlp.rs:            let index = (token.len() + i) % dimensions.len();
./backend/src/neural/nlp.rs:    pub fn analyze_sentiment(&self, tokens: &[String]) -> f64 {
./backend/src/neural/nlp.rs:        let positive_count = tokens
./backend/src/neural/nlp.rs:            .filter(|token| positive_words.contains(&token.as_str()))
./backend/src/neural/nlp.rs:        let negative_count = tokens
./backend/src/neural/nlp.rs:            .filter(|token| negative_words.contains(&token.as_str()))
./backend/src/neural/nlp.rs:    pub async fn extract_keywords(&self, text: &str, limit: usize) -> Vec<String> {
./backend/src/neural/nlp.rs:        let tokens: Vec<String> = text
./backend/src/neural/nlp.rs:        let mut keyword_scores: Vec<(String, f64)> = tokens
./backend/src/neural/nlp.rs:            .map(|token| {
./backend/src/neural/nlp.rs:                let score = vocabulary.get(token).copied().unwrap_or(0.1);
./backend/src/neural/nlp.rs:                (token.clone(), score)
./backend/src/neural/nlp.rs:        keyword_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
./backend/src/neural/nlp.rs:        keyword_scores
./backend/src/neural/nlp.rs:    async fn identify_patterns(&self, tokens: &[String]) -> Vec<Uuid> {
./backend/src/neural/nlp.rs:                .keywords
./backend/src/neural/nlp.rs:                .filter(|keyword| tokens.contains(keyword))
./backend/src/neural/nlp.rs:            if matches as f64 / pattern.keywords.len() as f64 > 0.5 {
./backend/src/neural/nlp.rs:    async fn update_vocabulary(&self, tokens: &[String], success: bool) {
./backend/src/neural/nlp.rs:        for token in tokens {
./backend/src/neural/nlp.rs:            let current_score = vocabulary.get(token).copied().unwrap_or(0.5);
./backend/src/neural/nlp.rs:            vocabulary.insert(token.clone(), new_score);
./backend/src/neural/nlp.rs:            keywords: input.keywords.clone(),
./backend/src/neural/nlp.rs:        let key = input.keywords.join("_");
./backend/src/neural/nlp.rs:        patterns.insert(key, pattern);
./backend/src/neural/nlp.rs:            keywords: input.keywords.clone(),
./backend/src/neural/nlp.rs:        let key = input.keywords.join("_");
./backend/src/neural/nlp.rs:        patterns.insert(key, pattern);
./backend/src/neural/nlp.rs:                input.keywords.join(" "),
./backend/src/neural/nlp.rs:                output.keywords.join(" ")
./backend/src/neural/nlp.rs:            .keywords
./backend/src/neural/nlp.rs:            .filter(|keyword| processed.keywords.contains(keyword))
./backend/src/neural/nlp.rs:        matches as f64 / pattern.keywords.len() as f64 > 0.3
./backend/src/neural/nlp.rs:        let tokens = self.tokenize(text);
./backend/src/neural/nlp.rs:        self.generate_semantic_vector(&tokens).await
./backend/src/neural/nlp.rs:    pub tokens: Vec<String>,
./backend/src/neural/nlp.rs:    pub keywords: Vec<String>,
./backend/src/neural/adaptive_learning.rs:        features.push(processed_text.tokens.len() as f64);
./backend/src/neural/adaptive_learning.rs:        features.push(processed_text.keywords.len() as f64);
./backend/src/core/hive/metrics_collection/events.rs:                .max_by_key(|(_, &count)| count)
./backend/src/core/hive/metrics_collection/collector.rs:    /// and alerting purposes. Uses string keys for flexibility.
./backend/src/core/hive/metrics_collection/collector.rs:        let event_key = format!("agent_{}", event_type);
./backend/src/core/hive/metrics_collection/collector.rs:            *counters.entry(event_key).or_insert(0) += 1;
./backend/src/core/hive/task_management_legacy/analytics.rs:        // Extract key metrics
./backend/src/core/hive/agent_management/lifecycle.rs:                let agent_id = *entry.key();
./backend/src/core/hive/agent_management/metrics.rs:        let metrics_key = CacheKey::AgentMetrics(agent_id);
./backend/src/core/hive/agent_management/metrics.rs:        if let Err(e) = self.cache_manager.invalidate_key(&metrics_key).await {
./backend/src/core/hive/agent_management/metrics.rs:            .map(|entry| (*entry.key(), entry.value().performance_score))
./backend/src/core/hive/agent_management/registry.rs:        let cache_key = CacheKey::Agent(agent_id);
./backend/src/core/hive/agent_management/registry.rs:        if let Err(e) = self.cache_manager.set_cached(cache_key, cache_entry).await {
./backend/src/core/hive/agent_management/registry.rs:        let cache_key = CacheKey::Agent(agent_id);
./backend/src/core/hive/agent_management/registry.rs:        if let Some(agent) = self.cache_manager.get_cached(&cache_key).await {
./backend/src/core/hive/agent_management/registry.rs:            if let Err(e) = self.cache_manager.set_cached(cache_key, cache_entry).await {
./backend/src/core/hive/agent_management/registry.rs:            .map(|entry| (*entry.key(), entry.value().clone()))
./backend/src/core/hive/agent_management/registry.rs:        self.agents.contains_key(&agent_id)
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("work_stealing_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("learning_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("swarm_coordination_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("metrics_collection_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config.contains_key("resource_monitoring_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("work_stealing_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("learning_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("swarm_coordination_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("metrics_collection_interval_ms"));
./backend/src/core/hive/background_processes.rs:        assert!(config_obj.contains_key("resource_monitoring_interval_ms"));
./backend/src/core/hive/task_management/task_executor.rs:            .keys()
./backend/src/core/hive/task_management/mod.rs:// Re-export key components
./backend/src/core/auto_scaling.rs:                candidates.sort_by_key(|(_, agent)| agent.memory.experiences.len());
./backend/src/core/auto_scaling.rs:                candidates.sort_by_key(|(_, agent)| agent.capabilities.len());
./backend/src/core/swarm_intelligence.rs:            let type_key = std::mem::discriminant(&agent.agent_type);
./backend/src/core/swarm_intelligence.rs:            if !agent_types_used.contains(&type_key) || selected.len() < 3 {
./backend/src/core/swarm_intelligence.rs:                agent_types_used.insert(type_key);
./backend/src/monitoring.rs:    password: String,
./backend/src/monitoring.rs:        password: String,
./backend/src/monitoring.rs:            password,
./backend/src/init.rs:    // Load encryption key from secure sources
./backend/src/init.rs:    let encryption_key = PersistenceManager::load_encryption_key();
./backend/src/init.rs:    let encryption_enabled = encryption_key.is_some();
./backend/src/init.rs:        info!("🔐 Encryption enabled with secure key management");
./backend/src/init.rs:        encryption_key,
./backend/src/init.rs:        "your-secret-key-here-change-in-production", // JWT secret - should be from config
./backend/src/tasks/work_stealing_queue.rs:            let agent_id = *entry.key();
./backend/src/tasks/work_stealing_queue.rs:            let agent_id = *entry.key();
./backend/src/tasks/task.rs:    pub fn with_context(mut self, key: String, value: String) -> Self {
./backend/src/tasks/task.rs:        self.context.insert(key, value);
./backend/src/infrastructure/cached_query.rs:/// Cache key types for different data entities
./backend/src/infrastructure/cached_query.rs:    /// Custom key for flexible caching
./backend/src/infrastructure/cached_query.rs:            CacheKey::SystemStatus(key) => write!(f, "system_status:{}", key),
./backend/src/infrastructure/cached_query.rs:            CacheKey::PerformanceMetrics(key) => write!(f, "performance_metrics:{}", key),
./backend/src/infrastructure/cached_query.rs:            CacheKey::Custom(key) => write!(f, "custom:{}", key),
./backend/src/infrastructure/cached_query.rs:        key: CacheKey,
./backend/src/infrastructure/cached_query.rs:        if let Some(cached_value) = self.get_cached(&key).await {
./backend/src/infrastructure/cached_query.rs:            debug!("Cache hit for key: {}", key);
./backend/src/infrastructure/cached_query.rs:        debug!("Cache miss for key: {}, executing query", key);
./backend/src/infrastructure/cached_query.rs:        self.set_cached(key.clone(), cache_entry).await?;
./backend/src/infrastructure/cached_query.rs:    pub async fn get_cached<T>(&self, key: &CacheKey) -> Option<T>
./backend/src/infrastructure/cached_query.rs:        let cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        if let Some(value) = self.cache_manager.get(&cache_key).await {
./backend/src/infrastructure/cached_query.rs:                if !self.is_entry_valid(&entry, key).await {
./backend/src/infrastructure/cached_query.rs:                    self.invalidate_key(key).await;
./backend/src/infrastructure/cached_query.rs:    pub async fn set_cached<T>(&self, key: CacheKey, entry: CacheEntry<T>) -> HiveResult<()>
./backend/src/infrastructure/cached_query.rs:        let cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        self.cache_manager.set(cache_key, cache_value).await?;
./backend/src/infrastructure/cached_query.rs:            tracker.insert(key, entry.version);
./backend/src/infrastructure/cached_query.rs:    /// Invalidate a specific cache key
./backend/src/infrastructure/cached_query.rs:    pub async fn invalidate_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cached_query.rs:        let _cache_key = key.to_string();
./backend/src/infrastructure/cached_query.rs:        debug!("Invalidating cache key: {}", key);
./backend/src/infrastructure/cached_query.rs:            tracker.remove(key);
./backend/src/infrastructure/cached_query.rs:        // Get all keys that depend on this dependency
./backend/src/infrastructure/cached_query.rs:        let keys_to_invalidate: Vec<CacheKey> = {
./backend/src/infrastructure/cached_query.rs:            tracker.keys().cloned().collect()
./backend/src/infrastructure/cached_query.rs:        for key in keys_to_invalidate {
./backend/src/infrastructure/cached_query.rs:            if let Some(cached_value) = self.cache_manager.get(&key.to_string()).await {
./backend/src/infrastructure/cached_query.rs:                                    self.invalidate_key(&key).await;
./backend/src/infrastructure/cached_query.rs:    /// Bulk invalidate multiple keys
./backend/src/infrastructure/cached_query.rs:    pub async fn invalidate_keys(&self, keys: &[CacheKey]) {
./backend/src/infrastructure/cached_query.rs:        for key in keys {
./backend/src/infrastructure/cached_query.rs:            self.invalidate_key(key).await;
./backend/src/infrastructure/cached_query.rs:    pub async fn warm_cache<F, Fut, T>(&self, keys: Vec<CacheKey>, fetcher: F) -> HiveResult<()>
./backend/src/infrastructure/cached_query.rs:        info!("Starting cache warming for {} keys", keys.len());
./backend/src/infrastructure/cached_query.rs:        for key in keys {
./backend/src/infrastructure/cached_query.rs:            let _key_clone = key.clone();
./backend/src/infrastructure/cached_query.rs:            debug!("Would prefetch data for key: {}", key);
./backend/src/infrastructure/cached_query.rs:    async fn is_entry_valid<T>(&self, entry: &CacheEntry<T>, key: &CacheKey) -> bool {
./backend/src/infrastructure/cached_query.rs:                if let Some(current_version) = tracker.get(key) {
./backend/src/infrastructure/cached_query.rs:                    if !tracker.contains_key(dep) {
./backend/src/infrastructure/cached_query.rs:        query_key: String,
./backend/src/infrastructure/cached_query.rs:            if let Some(execution) = deduplication.get(&query_key) {
./backend/src/infrastructure/cached_query.rs:            query_key: query_key.clone(),
./backend/src/infrastructure/cached_query.rs:            deduplication.insert(query_key.clone(), execution.clone());
./backend/src/infrastructure/cached_query.rs:            analyzer.record_execution(&query_key, execution_time);
./backend/src/infrastructure/cached_query.rs:        let query_key_clone = query_key.clone();
./backend/src/infrastructure/cached_query.rs:            deduplication.remove(&query_key_clone);
./backend/src/infrastructure/cached_query.rs:    ($cache_manager:expr, $key:expr, $dependencies:expr, $query:block) => {
./backend/src/infrastructure/cached_query.rs:        $cache_manager.execute_cached_query($key, $dependencies, || async move $query).await
./backend/src/infrastructure/cached_query.rs:    ($cache_manager:expr, $query_key:expr, $query:block) => {
./backend/src/infrastructure/cached_query.rs:        $cache_manager.execute_deduplicated_query($query_key, || async move $query).await
./backend/src/infrastructure/cached_query.rs:        let result1 = cached_query!(cache_manager, key.clone(), dependencies.clone(), {
./backend/src/infrastructure/cached_query.rs:        let result2 = cached_query!(cache_manager, key, dependencies, {
./backend/src/infrastructure/cached_query.rs:        let _ = cached_query!(cache_manager, key.clone(), dependencies.clone(), {
./backend/src/infrastructure/cached_query.rs:        // Invalidate the key
./backend/src/infrastructure/cached_query.rs:        cache_manager.invalidate_key(&key).await;
./backend/src/infrastructure/cached_query.rs:        let result = cached_query!(cache_manager, key, dependencies, {
./backend/src/infrastructure/cache_warming.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_warming.rs:    pub related_keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:    startup_keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:    pub total_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub warmed_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub failed_keys: usize,
./backend/src/infrastructure/cache_warming.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_warming.rs:                startup_keys: Vec::new(),
./backend/src/infrastructure/cache_warming.rs:    /// Record access pattern for a cache key
./backend/src/infrastructure/cache_warming.rs:    pub async fn record_access(&self, key: &CacheKey, context: Option<HashMap<String, String>>) {
./backend/src/infrastructure/cache_warming.rs:            .entry(key.clone())
./backend/src/infrastructure/cache_warming.rs:                key: key.clone(),
./backend/src/infrastructure/cache_warming.rs:                related_keys: Vec::new(),
./backend/src/infrastructure/cache_warming.rs:            candidates.insert(key.clone());
./backend/src/infrastructure/cache_warming.rs:            self.trigger_prefetching(key, context.unwrap_or_default())
./backend/src/infrastructure/cache_warming.rs:        for key in candidates {
./backend/src/infrastructure/cache_warming.rs:            match self.warm_key(&key).await {
./backend/src/infrastructure/cache_warming.rs:                    warn!("Failed to warm cache key {}: {}", key, e);
./backend/src/infrastructure/cache_warming.rs:        info!("Cache warming completed, warmed {} keys", warmed_count);
./backend/src/infrastructure/cache_warming.rs:            match self.prefetch_key(&item.key, item.context).await {
./backend/src/infrastructure/cache_warming.rs:                    warn!("Failed to prefetch cache key {}: {}", item.key, e);
./backend/src/infrastructure/cache_warming.rs:    pub async fn add_warming_candidate(&self, key: CacheKey) {
./backend/src/infrastructure/cache_warming.rs:        candidates.insert(key);
./backend/src/infrastructure/cache_warming.rs:    /// Configure startup warming keys
./backend/src/infrastructure/cache_warming.rs:        keys: Vec<CacheKey>,
./backend/src/infrastructure/cache_warming.rs:        startup_data.startup_keys = keys;
./backend/src/infrastructure/cache_warming.rs:        if startup_data.startup_keys.is_empty() {
./backend/src/infrastructure/cache_warming.rs:            "Starting startup cache warming for {} keys",
./backend/src/infrastructure/cache_warming.rs:            startup_data.startup_keys.len()
./backend/src/infrastructure/cache_warming.rs:            total_keys: startup_data.startup_keys.len(),
./backend/src/infrastructure/cache_warming.rs:            warmed_keys: 0,
./backend/src/infrastructure/cache_warming.rs:            failed_keys: 0,
./backend/src/infrastructure/cache_warming.rs:        // Group keys by priority
./backend/src/infrastructure/cache_warming.rs:        let mut keys_by_priority: HashMap<WarmingPriority, Vec<CacheKey>> = HashMap::new();
./backend/src/infrastructure/cache_warming.rs:        for key in &startup_data.startup_keys {
./backend/src/infrastructure/cache_warming.rs:            let priority = self.determine_key_priority(key).await;
./backend/src/infrastructure/cache_warming.rs:            keys_by_priority
./backend/src/infrastructure/cache_warming.rs:                .push(key.clone());
./backend/src/infrastructure/cache_warming.rs:        // Warm keys in priority order
./backend/src/infrastructure/cache_warming.rs:            if let Some(keys) = keys_by_priority.get(priority) {
./backend/src/infrastructure/cache_warming.rs:                info!("Warming {} keys with {:?} priority", keys.len(), priority);
./backend/src/infrastructure/cache_warming.rs:                for key in keys {
./backend/src/infrastructure/cache_warming.rs:                    match self.warm_key_with_fetcher(key, fetcher.clone()).await {
./backend/src/infrastructure/cache_warming.rs:                            progress.warmed_keys += 1;
./backend/src/infrastructure/cache_warming.rs:                            progress.failed_keys += 1;
./backend/src/infrastructure/cache_warming.rs:                            warn!("Failed to warm startup key {}: {}", key, e);
./backend/src/infrastructure/cache_warming.rs:            progress.warmed_keys, progress.failed_keys
./backend/src/infrastructure/cache_warming.rs:    /// Determine priority for a cache key
./backend/src/infrastructure/cache_warming.rs:    async fn determine_key_priority(&self, key: &CacheKey) -> WarmingPriority {
./backend/src/infrastructure/cache_warming.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/cache_warming.rs:    /// Warm key with custom fetcher
./backend/src/infrastructure/cache_warming.rs:    async fn warm_key_with_fetcher<F, Fut>(&self, key: &CacheKey, fetcher: F) -> HiveResult<()>
./backend/src/infrastructure/cache_warming.rs:            .get_cached::<serde_json::Value>(key)
./backend/src/infrastructure/cache_warming.rs:        let data = fetcher(key.clone()).await?;
./backend/src/infrastructure/cache_warming.rs:        let dependencies = vec![]; // Could be determined based on key relationships
./backend/src/infrastructure/cache_warming.rs:            .set_cached(key.clone(), cache_entry)
./backend/src/infrastructure/cache_warming.rs:        debug!("Successfully warmed cache key: {}", key);
./backend/src/infrastructure/cache_warming.rs:                    key: CacheKey::Custom(recommendation.key.clone()),
./backend/src/infrastructure/cache_warming.rs:                "startup_keys_count": startup_data.startup_keys.len(),
./backend/src/infrastructure/cache_warming.rs:    pub async fn remove_warming_candidate(&self, key: &CacheKey) {
./backend/src/infrastructure/cache_warming.rs:        candidates.remove(key);
./backend/src/infrastructure/cache_warming.rs:        // Find top accessed keys
./backend/src/infrastructure/cache_warming.rs:        let top_keys = top_patterns
./backend/src/infrastructure/cache_warming.rs:                    "key": p.key.to_string(),
./backend/src/infrastructure/cache_warming.rs:            "top_accessed_keys": top_keys,
./backend/src/infrastructure/cache_warming.rs:    async fn warm_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_warming.rs:            .get_cached::<serde_json::Value>(key)
./backend/src/infrastructure/cache_warming.rs:        debug!("Would warm cache key: {}", key);
./backend/src/infrastructure/cache_warming.rs:        candidates.remove(key);
./backend/src/infrastructure/cache_warming.rs:    async fn prefetch_key(
./backend/src/infrastructure/cache_warming.rs:        key: &CacheKey,
./backend/src/infrastructure/cache_warming.rs:        // Similar to warm_key, we can't actually prefetch without fetchers
./backend/src/infrastructure/cache_warming.rs:            "Would prefetch cache key: {} with context {:?}",
./backend/src/infrastructure/cache_warming.rs:            key, context
./backend/src/infrastructure/cache_warming.rs:    async fn trigger_prefetching(&self, key: &CacheKey, context: HashMap<String, String>) {
./backend/src/infrastructure/cache_warming.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/cache_warming.rs:                        key: key.clone(),
./backend/src/infrastructure/cache_warming.rs:            // Find keys with high access frequency
./backend/src/infrastructure/cache_warming.rs:            let mut high_frequency_keys: Vec<_> = patterns
./backend/src/infrastructure/cache_warming.rs:                .map(|p| p.key.clone())
./backend/src/infrastructure/cache_warming.rs:            high_frequency_keys.sort_by(|a, b| {
./backend/src/infrastructure/cache_warming.rs:            Ok(high_frequency_keys.into_iter().take(50).collect())
./backend/src/infrastructure/cache_warming.rs:        /// Predict keys that will be accessed soon
./backend/src/infrastructure/cache_warming.rs:            let mut predicted_keys: Vec<_> = patterns
./backend/src/infrastructure/cache_warming.rs:                .map(|p| p.key.clone())
./backend/src/infrastructure/cache_warming.rs:            predicted_keys.sort_by(|a, b| {
./backend/src/infrastructure/cache_warming.rs:            Ok(predicted_keys)
./backend/src/infrastructure/cache_warming.rs:        engine.record_access(&key1, None).await;
./backend/src/infrastructure/cache_warming.rs:        engine.record_access(&key2, None).await;
./backend/src/infrastructure/cache_warming.rs:        assert!(patterns.contains_key(&key1));
./backend/src/infrastructure/cache_warming.rs:        assert!(patterns.contains_key(&key2));
./backend/src/infrastructure/security_middleware.rs:            if let Some(token) = auth_str.strip_prefix("Bearer ") {
./backend/src/infrastructure/security_middleware.rs:                match auth_manager.validate_token(token).await {
./backend/src/infrastructure/security_middleware.rs:    // Try API key authentication
./backend/src/infrastructure/security_middleware.rs:    if let Some(api_key_header) = headers.get("x-api-key") {
./backend/src/infrastructure/security_middleware.rs:        if let Ok(api_key) = api_key_header.to_str() {
./backend/src/infrastructure/security_middleware.rs:            match auth_manager.validate_api_key(api_key).await {
./backend/src/infrastructure/security_middleware.rs:                    // Check if API key has required permission
./backend/src/infrastructure/security_middleware.rs:                            // Create pseudo-claims for API key
./backend/src/infrastructure/security_middleware.rs:                                sub: "api_key".to_string(),
./backend/src/infrastructure/security_middleware.rs:                                session_id: "api_key_session".to_string(),
./backend/src/infrastructure/security_middleware.rs:                    // API key is valid and no specific permission required
./backend/src/infrastructure/security_middleware.rs:                        sub: "api_key".to_string(),
./backend/src/infrastructure/security_middleware.rs:                        session_id: "api_key_session".to_string(),
./backend/src/infrastructure/cpu_optimizer.rs:                    .min_by_key(|(_, w)| w.active_tasks)
./backend/src/infrastructure/cache_invalidation.rs:    /// Pattern to match cache keys (supports regex)
./backend/src/infrastructure/cache_invalidation.rs:    pub key_pattern: String,
./backend/src/infrastructure/cache_invalidation.rs:    /// Forward dependencies: key -> dependent keys
./backend/src/infrastructure/cache_invalidation.rs:    /// Reverse dependencies: key -> keys that depend on it
./backend/src/infrastructure/cache_invalidation.rs:    pub fn add_dependency(&mut self, key: CacheKey, depends_on: CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        // Forward: key depends on depends_on
./backend/src/infrastructure/cache_invalidation.rs:            .entry(key.clone())
./backend/src/infrastructure/cache_invalidation.rs:        // Reverse: depends_on is depended on by key
./backend/src/infrastructure/cache_invalidation.rs:            .insert(key);
./backend/src/infrastructure/cache_invalidation.rs:    pub fn remove_dependency(&mut self, key: &CacheKey, depends_on: &CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        if let Some(deps) = self.forward_deps.get_mut(key) {
./backend/src/infrastructure/cache_invalidation.rs:            rev_deps.remove(key);
./backend/src/infrastructure/cache_invalidation.rs:    /// Get all keys that depend on the given key
./backend/src/infrastructure/cache_invalidation.rs:    pub fn get_dependents(&self, key: &CacheKey) -> HashSet<CacheKey> {
./backend/src/infrastructure/cache_invalidation.rs:        self.reverse_deps.get(key).cloned().unwrap_or_default()
./backend/src/infrastructure/cache_invalidation.rs:    /// Get all keys that the given key depends on
./backend/src/infrastructure/cache_invalidation.rs:    pub fn get_dependencies(&self, key: &CacheKey) -> HashSet<CacheKey> {
./backend/src/infrastructure/cache_invalidation.rs:        self.forward_deps.get(key).cloned().unwrap_or_default()
./backend/src/infrastructure/cache_invalidation.rs:    /// Last invalidation times for keys
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate a single cache key
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_key(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:        debug!("Invalidating cache key: {}", key);
./backend/src/infrastructure/cache_invalidation.rs:        // Invalidate the key itself
./backend/src/infrastructure/cache_invalidation.rs:        self.cache_manager.invalidate_key(key).await;
./backend/src/infrastructure/cache_invalidation.rs:        self.handle_cascade_invalidation(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate multiple keys with batching
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_keys(&self, keys: &[CacheKey]) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_keys_batched(keys, *batch_size).await
./backend/src/infrastructure/cache_invalidation.rs:                for key in keys {
./backend/src/infrastructure/cache_invalidation.rs:                    self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate keys based on a pattern
./backend/src/infrastructure/cache_invalidation.rs:        // For now, just invalidate keys that contain the pattern
./backend/src/infrastructure/cache_invalidation.rs:        let keys_to_check: Vec<CacheKey> = {
./backend/src/infrastructure/cache_invalidation.rs:        for key in keys_to_check {
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys matching pattern: {}",
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn add_dependency(&self, key: CacheKey, depends_on: CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key, depends_on);
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn remove_dependency(&self, key: &CacheKey, depends_on: &CacheKey) {
./backend/src/infrastructure/cache_invalidation.rs:        graph.remove_dependency(key, depends_on);
./backend/src/infrastructure/cache_invalidation.rs:        // Invalidate keys that exceed threshold in current window
./backend/src/infrastructure/cache_invalidation.rs:        let keys_to_check: Vec<CacheKey> = state.invalidation_counts.keys().cloned().collect();
./backend/src/infrastructure/cache_invalidation.rs:        for key in keys_to_check {
./backend/src/infrastructure/cache_invalidation.rs:            if let Some(counts) = state.invalidation_counts.get(&key) {
./backend/src/infrastructure/cache_invalidation.rs:                    self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:                    // Reset the window for this key
./backend/src/infrastructure/cache_invalidation.rs:                    state.invalidation_counts.remove(&key);
./backend/src/infrastructure/cache_invalidation.rs:                    state.last_invalidation_times.insert(key, now);
./backend/src/infrastructure/cache_invalidation.rs:        // Get all cache keys (this would need to be implemented in the cache manager)
./backend/src/infrastructure/cache_invalidation.rs:        let all_keys: Vec<CacheKey> = vec![]; // Placeholder - would need cache manager method
./backend/src/infrastructure/cache_invalidation.rs:        for key in all_keys {
./backend/src/infrastructure/cache_invalidation.rs:            let age = if let Some(last_invalidation) = state.age_distribution.get(&key) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:                state.age_distribution.insert(key, Duration::from_secs(0));
./backend/src/infrastructure/cache_invalidation.rs:        // Get all cache keys (this would need to be implemented in the cache manager)
./backend/src/infrastructure/cache_invalidation.rs:        let all_keys: Vec<CacheKey> = vec![]; // Placeholder - would need cache manager method
./backend/src/infrastructure/cache_invalidation.rs:        for key in all_keys {
./backend/src/infrastructure/cache_invalidation.rs:            if regex.is_match(&key.to_string()) {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys matching regex pattern: {}",
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn invalidate_by_access_pattern(&self, key: &CacheKey) -> HiveResult<bool> {
./backend/src/infrastructure/cache_invalidation.rs:            // Check if key matches the pattern
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(&rule.base_rule.key_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                        self.check_access_pattern_condition(key, condition).await;
./backend/src/infrastructure/cache_invalidation.rs:                        self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:        _key: &CacheKey,
./backend/src/infrastructure/cache_invalidation.rs:        for (key, size) in cache_sizes {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(&key).await?;
./backend/src/infrastructure/cache_invalidation.rs:            "Invalidated {} keys exceeding size threshold: {} bytes",
./backend/src/infrastructure/cache_invalidation.rs:            key_pattern: "temp_*".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:            key_pattern: "stale_*".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                .invalidate_by_pattern(&recommendation.key_pattern)
./backend/src/infrastructure/cache_invalidation.rs:                "Applied recommendation: {} - invalidated {} keys",
./backend/src/infrastructure/cache_invalidation.rs:            let keys = pending_invalidations.drain().collect();
./backend/src/infrastructure/cache_invalidation.rs:            keys
./backend/src/infrastructure/cache_invalidation.rs:            for key in &pending {
./backend/src/infrastructure/cache_invalidation.rs:                self.invalidate_key(key).await?;
./backend/src/infrastructure/cache_invalidation.rs:    async fn handle_cascade_invalidation(&self, key: &CacheKey) -> HiveResult<()> {
./backend/src/infrastructure/cache_invalidation.rs:        let dependents = graph.get_dependents(key);
./backend/src/infrastructure/cache_invalidation.rs:                "Invalidating {} dependent keys for: {}",
./backend/src/infrastructure/cache_invalidation.rs:                dependents_count, key
./backend/src/infrastructure/cache_invalidation.rs:                self.cache_manager.invalidate_key(dependent).await;
./backend/src/infrastructure/cache_invalidation.rs:    /// Invalidate keys in batches
./backend/src/infrastructure/cache_invalidation.rs:    async fn invalidate_keys_batched(
./backend/src/infrastructure/cache_invalidation.rs:        keys: &[CacheKey],
./backend/src/infrastructure/cache_invalidation.rs:        for chunk in keys.chunks(batch_size) {
./backend/src/infrastructure/cache_invalidation.rs:            for key in chunk {
./backend/src/infrastructure/cache_invalidation.rs:                pending.insert(key.clone());
./backend/src/infrastructure/cache_invalidation.rs:    /// Check if a key should be invalidated based on rules
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn should_invalidate(&self, key: &CacheKey) -> bool {
./backend/src/infrastructure/cache_invalidation.rs:            if key.to_string().contains(&rule.key_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:                    if key.to_string().contains(dep_pattern) {
./backend/src/infrastructure/cache_invalidation.rs:    pub async fn get_dependency_info(&self, key: &CacheKey) -> DependencyInfo {
./backend/src/infrastructure/cache_invalidation.rs:            key: key.clone(),
./backend/src/infrastructure/cache_invalidation.rs:            depends_on: graph.get_dependencies(key).into_iter().collect(),
./backend/src/infrastructure/cache_invalidation.rs:            depended_by: graph.get_dependents(key).into_iter().collect(),
./backend/src/infrastructure/cache_invalidation.rs:/// Dependency information for a cache key
./backend/src/infrastructure/cache_invalidation.rs:    pub key: CacheKey,
./backend/src/infrastructure/cache_invalidation.rs:    pub key_pattern: String,
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![CacheKey::Agent(agent_id), CacheKey::AgentMetrics(agent_id)];
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:        // This would need to be implemented to get all agent keys
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "agent".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "agent_metrics".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![CacheKey::Task(task_id), CacheKey::TaskMetrics(task_id)];
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:        let keys = vec![
./backend/src/infrastructure/cache_invalidation.rs:        self.base_manager.invalidate_keys(&keys).await?;
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "task".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:                key_pattern: "task_metrics".to_string(),
./backend/src/infrastructure/cache_invalidation.rs:        let key1 = CacheKey::Agent(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        let key2 = CacheKey::Task(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        let key3 = CacheKey::AgentMetrics(Uuid::new_v4());
./backend/src/infrastructure/cache_invalidation.rs:        // key1 depends on key2
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key1.clone(), key2.clone());
./backend/src/infrastructure/cache_invalidation.rs:        // key3 depends on key1
./backend/src/infrastructure/cache_invalidation.rs:        graph.add_dependency(key3.clone(), key1.clone());
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependencies(&key1).contains(&key2));
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependents(&key1).contains(&key3));
./backend/src/infrastructure/cache_invalidation.rs:        assert!(graph.get_dependents(&key2).contains(&key1));
./backend/src/infrastructure/cache_invalidation.rs:        let dep_key = CacheKey::Custom("dep_key".to_string());
./backend/src/infrastructure/cache_invalidation.rs:            .add_dependency(key.clone(), dep_key.clone())
./backend/src/infrastructure/cache_invalidation.rs:        invalidation_manager.invalidate_key(&dep_key).await?;
./backend/src/infrastructure/cache_invalidation.rs:        // Check that dependent key was also invalidated
./backend/src/infrastructure/connection_pool.rs:    pub async fn get(&self, key: &str) -> Option<CachedResponse> {
./backend/src/infrastructure/connection_pool.rs:        if let Some(response) = cache.get(key) {
./backend/src/infrastructure/connection_pool.rs:                cache.remove(key);
./backend/src/infrastructure/connection_pool.rs:    pub async fn set(&self, key: String, data: Vec<u8>, content_type: String) {
./backend/src/infrastructure/connection_pool.rs:            if let Some(oldest_key) = cache.keys().next().cloned() {
./backend/src/infrastructure/connection_pool.rs:                cache.remove(&oldest_key);
./backend/src/infrastructure/connection_pool.rs:        cache.insert(key, response);
./backend/src/infrastructure/connection_pool.rs:        cache.set(key.clone(), data.clone(), content_type.clone()).await;
./backend/src/infrastructure/connection_pool.rs:        let cached = cache.get(&key).await
./backend/src/infrastructure/throughput_optimizer.rs:    pub async fn cache_data(&self, key: String, data: Vec<u8>) -> HiveResult<()> {
./backend/src/infrastructure/throughput_optimizer.rs:        self.intelligent_cache.set(key, data).await
./backend/src/infrastructure/throughput_optimizer.rs:    pub async fn get_cached_data(&self, key: &str) -> Option<Vec<u8>> {
./backend/src/infrastructure/throughput_optimizer.rs:        self.intelligent_cache.get(key).await
./backend/src/infrastructure/performance_optimizer.rs:    pub async fn get(&self, key: &str) -> Option<Vec<u8>> {
./backend/src/infrastructure/performance_optimizer.rs:        if let Some(entry) = cache.get_mut(key) {
./backend/src/infrastructure/performance_optimizer.rs:            cache.remove(key);
./backend/src/infrastructure/performance_optimizer.rs:    pub async fn put(&self, key: String, data: Vec<u8>) -> HiveResult<()> {
./backend/src/infrastructure/performance_optimizer.rs:        cache.insert(key, entry);
./backend/src/infrastructure/performance_optimizer.rs:        entries.sort_by_key(|(_, entry)| entry.last_accessed);
./backend/src/infrastructure/performance_optimizer.rs:        let mut keys_to_remove = Vec::new();
./backend/src/infrastructure/performance_optimizer.rs:        for (key, entry) in entries {
./backend/src/infrastructure/performance_optimizer.rs:            keys_to_remove.push(key.clone());
./backend/src/infrastructure/performance_optimizer.rs:        for key in keys_to_remove {
./backend/src/infrastructure/performance_optimizer.rs:            cache.remove(&key);
./backend/src/infrastructure/performance_optimizer.rs:        let mut keys_to_remove = Vec::new();
./backend/src/infrastructure/performance_optimizer.rs:        for (key, entry) in cache_guard.iter() {
./backend/src/infrastructure/performance_optimizer.rs:                keys_to_remove.push(key.clone());
./backend/src/infrastructure/performance_optimizer.rs:        for key in keys_to_remove {
./backend/src/infrastructure/performance_optimizer.rs:            cache_guard.remove(&key);
./backend/src/infrastructure/performance_optimizer.rs:        assert!(cache.get(&key).await.is_none());
./backend/src/infrastructure/performance_optimizer.rs:        match cache.put(key.clone(), data.clone()).await {
./backend/src/infrastructure/performance_optimizer.rs:        let Some(cached_data) = cache.get(&key).await else {
./backend/src/infrastructure/cache.rs:    pub async fn insert(&self, key: K, value: V) {
./backend/src/infrastructure/cache.rs:        self.insert_with_ttl(key, value, self.default_ttl).await;
./backend/src/infrastructure/cache.rs:    pub async fn insert_with_ttl(&self, key: K, value: V, ttl: Duration) {
./backend/src/infrastructure/cache.rs:        let size_bytes = self.calculate_entry_size(&key, &value);
./backend/src/infrastructure/cache.rs:        data.insert(key, entry);
./backend/src/infrastructure/cache.rs:    pub async fn get(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/cache.rs:        if let Some(entry) = data.get_mut(key) {
./backend/src/infrastructure/cache.rs:                data.remove(key);
./backend/src/infrastructure/cache.rs:    pub async fn remove(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/cache.rs:        data.remove(key).map(|entry| entry.value)
./backend/src/infrastructure/cache.rs:            if let Some((key, entry)) = eviction_candidate {
./backend/src/infrastructure/cache.rs:                entries_to_evict.push((key, entry.size_bytes));
./backend/src/infrastructure/cache.rs:        for (key, _size) in entries_to_evict {
./backend/src/infrastructure/cache.rs:            if let Some(entry) = data.remove(&key) {
./backend/src/infrastructure/cache.rs:                .min_by_key(|(_, entry)| entry.last_accessed)
./backend/src/infrastructure/cache.rs:                .min_by_key(|(_, entry)| entry.access_count)
./backend/src/infrastructure/cache.rs:                    .min_by_key(|(_, entry)| {
./backend/src/infrastructure/cache.rs:    fn calculate_entry_size(&self, key: &K, value: &V) -> usize {
./backend/src/infrastructure/cache.rs:        let key_size = std::mem::size_of_val(key);
./backend/src/infrastructure/cache.rs:        key_size + value_size + 128 // Overhead for HashMap entry
./backend/src/infrastructure/telemetry.rs:            let type_key = format!("{event_type:?}");
./backend/src/infrastructure/telemetry.rs:            *metrics.events_by_type.entry(type_key).or_insert(0) += 1;
./backend/src/infrastructure/telemetry.rs:            let severity_key = format!("{severity:?}");
./backend/src/infrastructure/telemetry.rs:            *metrics.events_by_severity.entry(severity_key).or_insert(0) += 1;
./backend/src/infrastructure/telemetry.rs:    ($collector:expr, $source:expr, $($key:expr => $value:expr),*) => {
./backend/src/infrastructure/telemetry.rs:            serde_json::json!({ $($key: $value),* }),
./backend/src/infrastructure/monitoring_legacy.rs:    pub key_findings: Vec<String>,
./backend/src/infrastructure/monitoring_legacy.rs:                    let _active_agents: Vec<Uuid> = health_map.keys().copied().collect();
./backend/src/infrastructure/monitoring_legacy.rs:                // Generate trend data for key metrics
./backend/src/infrastructure/monitoring_legacy.rs:            let latency_key = format!("MONITORING_{}_LATENCY", component.to_uppercase());
./backend/src/infrastructure/monitoring_legacy.rs:            let latency = std::env::var(&latency_key)
./backend/src/infrastructure/monitoring_legacy.rs:            let throughput_key = format!("MONITORING_{}_THROUGHPUT", component.to_uppercase());
./backend/src/infrastructure/monitoring_legacy.rs:            let throughput = std::env::var(&throughput_key)
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:            key_findings: vec![
./backend/src/infrastructure/monitoring_legacy.rs:    pub async fn setup_grafana_integration(&self, endpoint: &str, api_key: &str) -> HiveResult<()> {
./backend/src/infrastructure/monitoring_legacy.rs:                config.insert("api_key".to_string(), api_key.to_string());
./backend/src/infrastructure/monitoring_legacy.rs:        password: &str,
./backend/src/infrastructure/monitoring_legacy.rs:                config.insert("password".to_string(), password.to_string());
./backend/src/infrastructure/persistence.rs:    pub encryption_key: Option<String>,
./backend/src/infrastructure/persistence.rs:    encryption_key: Option<[u8; 32]>,
./backend/src/infrastructure/persistence.rs:    /// Load encryption key from environment or secure storage
./backend/src/infrastructure/persistence.rs:    pub fn load_encryption_key() -> Option<String> {
./backend/src/infrastructure/persistence.rs:        std::env::var("HIVE_ENCRYPTION_KEY").ok()
./backend/src/infrastructure/persistence.rs:        let encryption_key = config.encryption_key.as_ref().map(|s| {
./backend/src/infrastructure/persistence.rs:            let mut key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            key[..len].copy_from_slice(&bytes[..len]);
./backend/src/infrastructure/persistence.rs:            key
./backend/src/infrastructure/persistence.rs:            encryption_key,
./backend/src/infrastructure/persistence.rs:    /// Encrypt data using AES-GCM with the configured encryption key
./backend/src/infrastructure/persistence.rs:        if let Some(key_bytes) = &self.encryption_key {
./backend/src/infrastructure/persistence.rs:            // Generate a random salt for key derivation
./backend/src/infrastructure/persistence.rs:            let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            pbkdf2_hmac::<Sha256>(key_bytes, &salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:            let key = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:            let cipher = Aes256Gcm::new(key);
./backend/src/infrastructure/persistence.rs:            // If no encryption key is configured, return data as-is
./backend/src/infrastructure/persistence.rs:    /// Decrypt data using AES-GCM with the configured encryption key
./backend/src/infrastructure/persistence.rs:        if let Some(key_bytes) = &self.encryption_key {
./backend/src/infrastructure/persistence.rs:            // Derive decryption key using PBKDF2 with the stored salt
./backend/src/infrastructure/persistence.rs:            let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            pbkdf2_hmac::<Sha256>(key_bytes, salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:            let key = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:            let cipher = Aes256Gcm::new(key);
./backend/src/infrastructure/persistence.rs:            // If no encryption key is configured, return data as-is
./backend/src/infrastructure/persistence.rs:        let id = self.storage.save_snapshot(&snapshot, self.encryption_key.as_ref()).await?;
./backend/src/infrastructure/persistence.rs:        let _snapshot = self.storage.load_snapshot(checkpoint_id, self.encryption_key.as_ref()).await?;
./backend/src/infrastructure/persistence.rs:    async fn save_snapshot(&self, snapshot: &SystemSnapshot, encryption_key: Option<&[u8; 32]>) -> HiveResult<String>;
./backend/src/infrastructure/persistence.rs:    async fn load_snapshot(&self, snapshot_id: &str, encryption_key: Option<&[u8; 32]>) -> HiveResult<SystemSnapshot>;
./backend/src/infrastructure/persistence.rs:                id TEXT PRIMARY KEY,
./backend/src/infrastructure/persistence.rs:    async fn save_snapshot(&self, snapshot: &SystemSnapshot, encryption_key: Option<&[u8; 32]>) -> HiveResult<String> {
./backend/src/infrastructure/persistence.rs:        let encryption_key_clone = encryption_key.map(|k| *k);
./backend/src/infrastructure/persistence.rs:            // Apply encryption if key is provided
./backend/src/infrastructure/persistence.rs:            let processed_data = if let Some(key) = encryption_key_clone {
./backend/src/infrastructure/persistence.rs:                // Generate a random salt for key derivation
./backend/src/infrastructure/persistence.rs:                let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:                pbkdf2_hmac::<Sha256>(&key, &salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:                let key_obj = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:                let cipher = Aes256Gcm::new(key_obj);
./backend/src/infrastructure/persistence.rs:    async fn load_snapshot(&self, snapshot_id: &str, encryption_key: Option<&[u8; 32]>) -> HiveResult<SystemSnapshot> {
./backend/src/infrastructure/persistence.rs:        let encryption_key_clone = encryption_key.map(|k| *k);
./backend/src/infrastructure/persistence.rs:            // Apply decryption if key is provided
./backend/src/infrastructure/persistence.rs:            let json_data = if let Some(key) = encryption_key_clone {
./backend/src/infrastructure/persistence.rs:                // Derive decryption key using PBKDF2 with the stored salt
./backend/src/infrastructure/persistence.rs:                let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:                pbkdf2_hmac::<Sha256>(&key, salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:                let key_obj = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:                let cipher = Aes256Gcm::new(key_obj);
./backend/src/infrastructure/persistence.rs:    async fn save_snapshot(&self, snapshot: &SystemSnapshot, encryption_key: Option<&[u8; 32]>) -> HiveResult<String> {
./backend/src/infrastructure/persistence.rs:        // Apply encryption if key is provided
./backend/src/infrastructure/persistence.rs:        let data_to_write = if let Some(key) = encryption_key {
./backend/src/infrastructure/persistence.rs:            // Generate a random salt for key derivation
./backend/src/infrastructure/persistence.rs:            let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            pbkdf2_hmac::<Sha256>(key, &salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:            let key_obj = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:            let cipher = Aes256Gcm::new(key_obj);
./backend/src/infrastructure/persistence.rs:    async fn load_snapshot(&self, snapshot_id: &str, encryption_key: Option<&[u8; 32]>) -> HiveResult<SystemSnapshot> {
./backend/src/infrastructure/persistence.rs:        // Apply decryption if key is provided
./backend/src/infrastructure/persistence.rs:        let json_data = if let Some(key) = encryption_key {
./backend/src/infrastructure/persistence.rs:            // Derive decryption key using PBKDF2 with the stored salt
./backend/src/infrastructure/persistence.rs:            let mut derived_key = [0u8; 32];
./backend/src/infrastructure/persistence.rs:            pbkdf2_hmac::<Sha256>(key, salt, 10000, &mut derived_key);
./backend/src/infrastructure/persistence.rs:            let key_obj = Key::<Aes256Gcm>::from_slice(&derived_key);
./backend/src/infrastructure/persistence.rs:            let cipher = Aes256Gcm::new(key_obj);
./backend/src/infrastructure/persistence.rs:    async fn save_snapshot(&self, snapshot: &SystemSnapshot, _encryption_key: Option<&[u8; 32]>) -> HiveResult<String> {
./backend/src/infrastructure/persistence.rs:            let oldest_key = snapshots.keys().next().cloned();
./backend/src/infrastructure/persistence.rs:            if let Some(key) = oldest_key {
./backend/src/infrastructure/persistence.rs:                snapshots.remove(&key);
./backend/src/infrastructure/persistence.rs:            let oldest_key = snapshots.keys().next().cloned();
./backend/src/infrastructure/persistence.rs:            if let Some(key) = oldest_key {
./backend/src/infrastructure/persistence.rs:                snapshots.remove(&key);
./backend/src/infrastructure/persistence.rs:    async fn load_snapshot(&self, snapshot_id: &str, _encryption_key: Option<&[u8; 32]>) -> HiveResult<SystemSnapshot> {
./backend/src/infrastructure/persistence.rs:        let keys_to_remove: Vec<String> = snapshots.keys().take(to_remove).cloned().collect();
./backend/src/infrastructure/persistence.rs:        for key in &keys_to_remove {
./backend/src/infrastructure/persistence.rs:            snapshots.remove(key);
./backend/src/infrastructure/persistence.rs:        Ok(keys_to_remove.len())
./backend/src/infrastructure/persistence.rs:            encryption_key: None,
./backend/src/infrastructure/intelligent_cache.rs:    pub query_key: String,
./backend/src/infrastructure/intelligent_cache.rs:    pub query_key: String,
./backend/src/infrastructure/intelligent_cache.rs:    /// Classify based on key patterns
./backend/src/infrastructure/intelligent_cache.rs:    /// Sequential access patterns (what comes after this key)
./backend/src/infrastructure/intelligent_cache.rs:    fn record_access(&mut self, previous_key: Option<&str>) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(prev_key) = previous_key {
./backend/src/infrastructure/intelligent_cache.rs:                .entry(prev_key.to_string())
./backend/src/infrastructure/intelligent_cache.rs:    /// Check if this key is in a burst access pattern
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, count)| (key.clone(), *count as f64 / total_sequential as f64))
./backend/src/infrastructure/intelligent_cache.rs:    last_accessed_key: Arc<RwLock<Option<K>>>,
./backend/src/infrastructure/intelligent_cache.rs:            last_accessed_key: Arc::new(RwLock::new(None)),
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/intelligent_cache.rs:        // Get the previous key for sequential pattern tracking
./backend/src/infrastructure/intelligent_cache.rs:        let previous_key = {
./backend/src/infrastructure/intelligent_cache.rs:            let mut last_key = self.last_accessed_key.write().await;
./backend/src/infrastructure/intelligent_cache.rs:            let prev = last_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:            *last_key = Some(key.clone());
./backend/src/infrastructure/intelligent_cache.rs:        self.record_access(key, previous_key.as_ref()).await;
./backend/src/infrastructure/intelligent_cache.rs:        let result = self.cache.get(key).await;
./backend/src/infrastructure/intelligent_cache.rs:                if prefetch_queue.contains(&key.to_string()) {
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set(&self, key: K, value: V) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:            self.calculate_adaptive_ttl(&key).await
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.insert_with_ttl(key.clone(), value, ttl).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set_with_ttl(&self, key: K, value: V, ttl: Duration) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.insert_with_ttl(key, value, ttl).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn remove(&self, key: &K) -> Option<V> {
./backend/src/infrastructure/intelligent_cache.rs:            patterns.remove(key);
./backend/src/infrastructure/intelligent_cache.rs:        self.cache.remove(key).await
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn prefetch<F, Fut>(&self, key: K, loader: F) -> HiveResult<()>
./backend/src/infrastructure/intelligent_cache.rs:        if self.cache.get(&key).await.is_some() {
./backend/src/infrastructure/intelligent_cache.rs:                self.set(key.clone(), value).await?;
./backend/src/infrastructure/intelligent_cache.rs:                    queue.push_back(key.to_string());
./backend/src/infrastructure/intelligent_cache.rs:                debug!("Successfully prefetched data for key");
./backend/src/infrastructure/intelligent_cache.rs:    /// Record access pattern for a key
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_access(&self, key: &K, previous_key: Option<&K>) {
./backend/src/infrastructure/intelligent_cache.rs:            .entry(key.clone())
./backend/src/infrastructure/intelligent_cache.rs:        pattern.record_access(previous_key.map(|k| k.as_ref()));
./backend/src/infrastructure/intelligent_cache.rs:            self.trigger_predictive_prefetching(key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn trigger_predictive_prefetching(&self, key: &K) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:            for (next_key, probability) in sequential_predictions.into_iter().take(3) {
./backend/src/infrastructure/intelligent_cache.rs:                        key.to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                        next_key,
./backend/src/infrastructure/intelligent_cache.rs:                    queue.push_back(next_key.clone());
./backend/src/infrastructure/intelligent_cache.rs:                    "Burst access detected for key: {}, triggering aggressive prefetching",
./backend/src/infrastructure/intelligent_cache.rs:                    key.to_string()
./backend/src/infrastructure/intelligent_cache.rs:                self.trigger_burst_prefetching(key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn trigger_burst_prefetching(&self, key: &K) {
./backend/src/infrastructure/intelligent_cache.rs:        // Find other keys with similar access patterns
./backend/src/infrastructure/intelligent_cache.rs:        let similar_keys: Vec<String> = patterns
./backend/src/infrastructure/intelligent_cache.rs:                k.as_ref() != key.as_ref() && p.access_frequency > 0.1 && p.is_in_burst()
./backend/src/infrastructure/intelligent_cache.rs:        for similar_key in similar_keys {
./backend/src/infrastructure/intelligent_cache.rs:            debug!("Burst prefetching similar key: {}", similar_key);
./backend/src/infrastructure/intelligent_cache.rs:            queue.push_back(similar_key);
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate adaptive TTL for a key
./backend/src/infrastructure/intelligent_cache.rs:    async fn calculate_adaptive_ttl(&self, key: &K) -> Duration {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(pattern) = patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:    /// Get keys that should be prefetched
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, _)| key.clone())
./backend/src/infrastructure/intelligent_cache.rs:    /// Get TTL adaptation statistics for all keys
./backend/src/infrastructure/intelligent_cache.rs:            .map(|(key, pattern)| (key.clone(), pattern.get_ttl_stats()))
./backend/src/infrastructure/intelligent_cache.rs:        for (key, pattern) in &*patterns {
./backend/src/infrastructure/intelligent_cache.rs:                key: key.clone(),
./backend/src/infrastructure/intelligent_cache.rs:                sequential_keys: sequential_predictions
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate predicted benefit of prefetching a key
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                match loader_clone(key_clone).await {
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                match loader_clone(key_clone).await {
./backend/src/infrastructure/intelligent_cache.rs:            let key_clone = recommendation.key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                let _ = loader_clone(key_clone).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub key: String,
./backend/src/infrastructure/intelligent_cache.rs:    pub key: K,
./backend/src/infrastructure/intelligent_cache.rs:    pub sequential_keys: Vec<String>,
./backend/src/infrastructure/intelligent_cache.rs:                let task_id = format!("warm_{}", request.key);
./backend/src/infrastructure/intelligent_cache.rs:                                "Successfully warmed cache for key: {} in {:.4}s",
./backend/src/infrastructure/intelligent_cache.rs:                                request.key,
./backend/src/infrastructure/intelligent_cache.rs:                            tracing::warn!("Failed to warm cache for key: {}: {}", request.key, e);
./backend/src/infrastructure/intelligent_cache.rs:        for (key, records) in &analyzer.patterns {
./backend/src/infrastructure/intelligent_cache.rs:                        recommendations.push(key.clone());
./backend/src/infrastructure/intelligent_cache.rs:    pub fn record_access(&mut self, key: &str, access_type: AccessType) {
./backend/src/infrastructure/intelligent_cache.rs:            frequency_score: self.calculate_frequency_score(key),
./backend/src/infrastructure/intelligent_cache.rs:            .entry(key.to_string())
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get_mut(key) {
./backend/src/infrastructure/intelligent_cache.rs:        self.update_prediction_model(key);
./backend/src/infrastructure/intelligent_cache.rs:    /// Calculate frequency score for a key
./backend/src/infrastructure/intelligent_cache.rs:    fn calculate_frequency_score(&self, key: &str) -> f64 {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:    /// Update prediction model for a key
./backend/src/infrastructure/intelligent_cache.rs:    fn update_prediction_model(&mut self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(records) = self.patterns.get(key) {
./backend/src/infrastructure/intelligent_cache.rs:                self.prediction_model.insert(key.to_string(), model);
./backend/src/infrastructure/intelligent_cache.rs:    /// Predict if key will be accessed soon
./backend/src/infrastructure/intelligent_cache.rs:    pub fn predict_access(&self, key: &str) -> Option<f64> {
./backend/src/infrastructure/intelligent_cache.rs:            .get(key)
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l1_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l2_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            let _ = self.l1_cache.set(key.to_string(), value.clone()).await;
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn set(&self, key: String, value: serde_json::Value) -> HiveResult<()> {
./backend/src/infrastructure/intelligent_cache.rs:        self.l1_cache.set(key.clone(), value.clone()).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.l2_cache.set(key, value).await?;
./backend/src/infrastructure/intelligent_cache.rs:        let query_key = request.query_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:            .entry(query_key)
./backend/src/infrastructure/intelligent_cache.rs:    pub async fn get_with_warming(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l1_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            self.record_cache_hit(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        if let Some(value) = self.l2_cache.get(&key.to_string()).await {
./backend/src/infrastructure/intelligent_cache.rs:            let _ = self.l1_cache.set(key.to_string(), value.clone()).await;
./backend/src/infrastructure/intelligent_cache.rs:            self.record_cache_hit(key).await;
./backend/src/infrastructure/intelligent_cache.rs:            self.analyze_and_trigger_warming(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        self.record_cache_miss(key).await;
./backend/src/infrastructure/intelligent_cache.rs:        key: String,
./backend/src/infrastructure/intelligent_cache.rs:        self.l1_cache.set(key.clone(), value.clone()).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.l2_cache.set(key.clone(), value).await?;
./backend/src/infrastructure/intelligent_cache.rs:        self.analyze_and_trigger_warming(&key).await;
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_cache_hit(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        analyzer.record_access(key, AccessType::Read);
./backend/src/infrastructure/intelligent_cache.rs:    async fn record_cache_miss(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        analyzer.record_access(key, AccessType::Read);
./backend/src/infrastructure/intelligent_cache.rs:    async fn analyze_and_trigger_warming(&self, key: &str) {
./backend/src/infrastructure/intelligent_cache.rs:        if recommendations.contains(&key.to_string()) {
./backend/src/infrastructure/intelligent_cache.rs:            // Create warming request for this key
./backend/src/infrastructure/intelligent_cache.rs:                key: key.to_string(),
./backend/src/infrastructure/intelligent_cache.rs:            .set("key1".to_string(), serde_json::json!({"value": 42}))
./backend/src/infrastructure/intelligent_cache.rs:        let value = cache_manager.get("key1").await;
./backend/src/infrastructure/intelligent_cache.rs:            .prefetch("prefetch_key".to_string(), || async {
./backend/src/infrastructure/intelligent_cache.rs:        let value = cache.get(&"prefetch_key".to_string()).await;
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                    "name": format!("User {}", key),
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                    "name": format!("Product {}", key),
./backend/src/infrastructure/intelligent_cache.rs:                    "id": key,
./backend/src/infrastructure/intelligent_cache.rs:                Ok(serde_json::json!({"data": format!("Generic data for {}", key)}))
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/intelligent_cache.rs:            let query_key_clone = query_key.clone();
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user1".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user2".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:                query_key: "user:user3".to_string(),
./backend/src/infrastructure/intelligent_cache.rs:            let (query_type, key) = &workload[idx];
./backend/src/infrastructure/intelligent_cache.rs:            workload.push((query_type.clone(), key.clone()));
./backend/src/infrastructure/intelligent_cache.rs:        for (query_type, key) in workload {
./backend/src/infrastructure/intelligent_cache.rs:            let cache_key = CacheKey::Custom(format!("{}:{}", query_type, key));
./backend/src/infrastructure/intelligent_cache.rs:                .execute_cached_query(cache_key, vec![], || async {
./backend/src/infrastructure/streaming.rs:    pub fn with_metadata(mut self, key: String, value: String) -> Self {
./backend/src/infrastructure/streaming.rs:        self.metadata.insert(key, value);
./backend/src/infrastructure/monitoring/health_monitor.rs:        let agent_ids: Vec<Uuid> = self.agent_health.read().await.keys().cloned().collect();
./backend/src/infrastructure/monitoring/mod.rs:// Re-export key components
./backend/src/infrastructure/cache_optimization.rs:            let key = CacheKey::Custom(format!("benchmark_key_{}", operations % 1000));
./backend/src/infrastructure/cache_optimization.rs:                if let Err(e) = self.cache_manager.set_cached(key, cache_entry).await {
./backend/src/infrastructure/cache_optimization.rs:                    .get_cached::<serde_json::Value>(&key)
./backend/src/infrastructure/network_optimizer.rs:        let key = format!("{}:{}", host, port);
./backend/src/infrastructure/network_optimizer.rs:            if let Some(pool) = pools.get_mut(&key) {
./backend/src/infrastructure/network_optimizer.rs:        let key = format!("{}:{}", connection.host, connection.port);
./backend/src/infrastructure/network_optimizer.rs:        let pool = pools.entry(key).or_insert_with(Vec::new);
./backend/src/infrastructure/network_optimizer.rs:    tokens: Arc<Mutex<u64>>,
./backend/src/infrastructure/network_optimizer.rs:            tokens: Arc::new(Mutex::new(config.rate_limit_bytes_per_sec)),
./backend/src/infrastructure/network_optimizer.rs:        let mut tokens = self.tokens.lock().await;
./backend/src/infrastructure/network_optimizer.rs:        // Refill tokens based on elapsed time
./backend/src/infrastructure/network_optimizer.rs:        let tokens_to_add = (elapsed.as_secs_f64() * self.config.rate_limit_bytes_per_sec as f64) as u64;
./backend/src/infrastructure/network_optimizer.rs:        *tokens = (*tokens + tokens_to_add).min(self.config.rate_limit_bytes_per_sec);
./backend/src/infrastructure/network_optimizer.rs:        if *tokens >= requested_bytes as u64 {
./backend/src/infrastructure/network_optimizer.rs:            *tokens -= requested_bytes as u64;
./backend/src/infrastructure/performance_integration.rs:    pub async fn get_cached(&self, key: &str) -> Option<serde_json::Value> {
./backend/src/infrastructure/performance_integration.rs:        self.cache_manager.get(key).await
./backend/src/infrastructure/performance_integration.rs:    pub async fn set_cached(&self, key: String, value: serde_json::Value) -> HiveResult<()> {
./backend/src/infrastructure/performance_integration.rs:        self.cache_manager.set(key, value).await
./backend/src/infrastructure/performance_integration.rs:    pub async fn get_or_load<F, Fut>(&self, key: &str, loader: F) -> HiveResult<serde_json::Value>
./backend/src/infrastructure/performance_integration.rs:        if let Some(cached) = self.get_cached(key).await {
./backend/src/infrastructure/performance_integration.rs:        self.set_cached(key.to_string(), value.clone()).await?;
./backend/src/infrastructure/performance_integration.rs:            .get_or_load("new_key", || async {
./backend/src/infrastructure/intelligent_alerting.rs:            let alert_key = format!(
./backend/src/infrastructure/intelligent_alerting.rs:            if let Some(last_sent) = suppression.suppressed_alerts.get(&alert_key) {
./backend/src/infrastructure/intelligent_alerting.rs:            suppression.suppressed_alerts.insert(alert_key, now);
./backend/src/infrastructure/intelligent_alerting.rs:            .max_by_key(|(_, count)| *count)
./backend/performance_benchmark.rs:        let key = format!("key_{}", i);
./backend/performance_benchmark.rs:            map.insert(key, data);
./backend/bench_runner.rs:            for (key, value) in &result.custom_metrics {
./backend/bench_runner.rs:                println!("     {}: {:.2}", key, value);
./backend/benches/performance_optimizations.rs:                let key = format!("key_{}", i);
./backend/benches/performance_optimizations.rs:                cache.set(key.clone(), value.clone()).await.unwrap();
./backend/benches/performance_optimizations.rs:                    let _ = cache.get(&key).await;
./backend/benches/performance_optimizations.rs:                    .set_with_intelligence(key, value)
./backend/benches/performance_optimizations.rs:                if cache_manager.get_with_warming(&key).await.is_some() {
./backend/benches/performance_optimizations.rs:                let key = format!("hot_key_{}", i % 10); // High frequency keys
./backend/benches/performance_optimizations.rs:                    let _ = cache_manager.get_with_warming(&key).await;
./backend/simple_perf_benchmark.rs:                let key = format!("thread_{}_item_{}", i, j);
./backend/simple_perf_benchmark.rs:                map.insert(key, data);
./backend/simple_perf_benchmark.rs:        if map.contains_key(&i) {
./frontend/e2e/dashboard.spec.ts:    const metricsChanged = Object.keys(initialMetrics).some(
./frontend/e2e/dashboard.spec.ts:      key => initialMetrics[key] !== updatedMetrics[key],
./frontend/src/utils/logger.ts:    if (context && Object.keys(context).length > 0) {
./frontend/src/hooks/useErrorRecovery.ts:          retryableErrors.some(keyword => message.includes(keyword)) ||
./frontend/src/hooks/useErrorRecovery.ts:        const isNonRetryable = nonRetryableErrors.some(keyword => message.includes(keyword))
./frontend/scripts/agent-map.js:      Object.keys(agentMap.agents).length > 0
./frontend/scripts/agent-map.js:        ? totalConnections / Object.keys(agentMap.agents).length
./frontend/scripts/agent-map.js:    console.log(`   Total Agents: ${Object.keys(agentMap.agents).length}`)
./frontend/scripts/agent-behavior-decisions.js:    const agents = Object.keys(decisionPatterns.agent_decision_profiles)
./frontend/scripts/agent-behavior-communication.js:    commPatterns.patterns.isolated_agents = Object.keys(commPatterns.interaction_frequency).filter(
./frontend/.next/static/chunks/983-5434139a4bf2acaa.js:"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[983],{5380:(e,r,t)=>{t.d(r,{A:()=>i,AuthProvider:()=>a});var o=t(5155),s=t(2115);let n=(0,s.createContext)(void 0),i=()=>{let e=(0,s.useContext)(n);if(void 0===e)throw Error("useAuth must be used within an AuthProvider");return e},a=e=>{let{children:r}=e,[t,i]=(0,s.useState)({user:null,token:null,refreshToken:null,isAuthenticated:!1,isLoading:!0});(0,s.useEffect)(()=>{(()=>{try{let e=localStorage.getItem("auth_token"),r=localStorage.getItem("refresh_token"),t=localStorage.getItem("user");if(e&&t){let o=JSON.parse(t);i({user:o,token:e,refreshToken:r,isAuthenticated:!0,isLoading:!1})}else i(e=>({...e,isLoading:!1}))}catch(e){console.error("Error initializing auth state:",e),localStorage.removeItem("auth_token"),localStorage.removeItem("refresh_token"),localStorage.removeItem("user"),i(e=>({...e,isLoading:!1}))}})()},[]);let a=async function(e,r){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Human";try{let o=await fetch("/api/auth/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:e,password:r,client_type:t})});if(!o.ok){let e=await o.json();throw Error(e.error||"Login failed")}let s=await o.json();localStorage.setItem("auth_token",s.token),localStorage.setItem("refresh_token",s.refresh_token),localStorage.setItem("user",JSON.stringify(s.user)),i({user:s.user,token:s.token,refreshToken:s.refresh_token,isAuthenticated:!0,isLoading:!1})}catch(e){throw console.error("Login error:",e),e}},l=async()=>{try{if(t.token){var e;await fetch("/api/auth/logout",{method:"POST",headers:{"Content-Type":"application/json",Authorization:"Bearer ".concat(t.token)},body:JSON.stringify({session_id:(null==(e=t.user)?void 0:e.id)||"unknown"})})}}catch(e){console.error("Logout API error:",e)}localStorage.removeItem("auth_token"),localStorage.removeItem("refresh_token"),localStorage.removeItem("user"),i({user:null,token:null,refreshToken:null,isAuthenticated:!1,isLoading:!1})},c=async()=>{if(!t.refreshToken)throw Error("No refresh token available");try{let e=await fetch("/api/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refresh_token:t.refreshToken})});if(!e.ok){let r=await e.json();throw Error(r.error||"Token refresh failed")}let r=await e.json();localStorage.setItem("auth_token",r.token),i(e=>({...e,token:r.token}))}catch(e){throw console.error("Token refresh error:",e),await l(),e}},u={...t,login:a,logout:l,refreshTokenFn:c,hasPermission:e=>{var r;return(null==(r=t.user)?void 0:r.permissions.includes(e))||!1},hasRole:e=>{var r;return(null==(r=t.user)?void 0:r.roles.includes(e))||!1}};return(0,o.jsx)(n.Provider,{value:u,children:r})}},7088:(e,r,t)=>{t.d(r,{tH:()=>c});var o=t(5155),s=t(2115),n=t(2056),i=t(6927),a=t(9559),l=t(5993);class c extends s.Component{static getDerivedStateFromError(e){return{hasError:!0,error:e}}componentDidCatch(e,r){var t,o;console.error("ErrorBoundary caught an error:",e,r),null==(t=(o=this.props).onError)||t.call(o,e,r),this.reportError(e,r),this.setState({error:e,errorInfo:r})}componentWillUnmount(){this.retryTimeouts.forEach(e=>clearTimeout(e))}render(){if(this.state.hasError){var e;return this.props.fallback?this.props.fallback:(0,o.jsx)("div",{className:"min-h-screen bg-gray-50 flex items-center justify-center px-4",children:(0,o.jsxs)("div",{className:"max-w-md w-full bg-white rounded-lg shadow-lg p-6",children:[(0,o.jsx)("div",{className:"flex items-center justify-center mb-4",children:(0,o.jsx)("div",{className:"bg-red-100 rounded-full p-3",children:(0,o.jsx)(n.A,{className:"h-8 w-8 text-red-600"})})}),(0,o.jsx)("h1",{className:"text-xl font-semibold text-gray-900 text-center mb-2",children:"Something went wrong"}),(0,o.jsx)("p",{className:"text-gray-600 text-center mb-6",children:"We encountered an unexpected error. Please try refreshing the page or contact support if the problem persists."}),this.props.showDetails&&this.state.error&&(0,o.jsxs)("div",{className:"bg-gray-50 rounded-md p-4 mb-4",children:[(0,o.jsxs)("h3",{className:"text-sm font-medium text-gray-900 mb-2 flex items-center",children:[(0,o.jsx)(i.A,{className:"h-4 w-4 mr-2"}),"Error Details"]}),(0,o.jsxs)("details",{className:"text-xs text-gray-600",children:[(0,o.jsx)("summary",{className:"cursor-pointer hover:text-gray-900",children:"Click to show technical details"}),(0,o.jsxs)("pre",{className:"mt-2 whitespace-pre-wrap break-words",children:[this.state.error.message,this.state.error.stack&&"\n\n".concat(this.state.error.stack),(null==(e=this.state.errorInfo)?void 0:e.componentStack)&&"\n\nComponent Stack:\n".concat(this.state.errorInfo.componentStack)]})]})]}),(0,o.jsxs)("div",{className:"flex flex-col sm:flex-row gap-3",children:[(0,o.jsxs)("button",{onClick:this.handleRetry,className:"flex-1 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 flex items-center justify-center",children:[(0,o.jsx)(a.A,{className:"h-4 w-4 mr-2"}),"Try Again"]}),(0,o.jsxs)("button",{onClick:this.handleGoHome,className:"flex-1 bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 flex items-center justify-center",children:[(0,o.jsx)(l.A,{className:"h-4 w-4 mr-2"}),"Go Home"]})]}),this.state.retryCount>0&&(0,o.jsxs)("p",{className:"text-xs text-gray-500 text-center mt-4",children:["Retry attempts: ",this.state.retryCount]})]})})}return this.props.children}constructor(e){super(e),this.retryTimeouts=[],this.reportError=(e,r)=>{console.error("Error Report:",{message:e.message,stack:e.stack,componentStack:r.componentStack,timestamp:new Date().toISOString(),userAgent:navigator.userAgent,url:window.location.href,retryCount:this.state.retryCount})},this.handleRetry=()=>{this.setState(e=>({hasError:!1,error:void 0,errorInfo:void 0,retryCount:e.retryCount+1}))},this.handleAutoRetry=()=>{let e=setTimeout(()=>{this.handleRetry()},2e3);this.retryTimeouts.push(e)},this.handleGoHome=()=>{window.location.href="/"},this.state={hasError:!1,retryCount:0}}}s.Component},8812:(e,r,t)=>{t.d(r,{NZ:()=>l,v$:()=>a,vV:()=>i});class o{generateSessionId(){return"session_".concat(Date.now(),"_").concat(Math.random().toString(36).substring(2,11))}generateErrorId(){return"error_".concat(Date.now(),"_").concat(Math.random().toString(36).substring(2,11))}determineSeverity(e){let r=e.message.toLowerCase();return r.includes("network")||r.includes("fetch")||r.includes("connection")?"medium":r.includes("unauthorized")||r.includes("forbidden")||r.includes("auth")||r.includes("typeerror")||r.includes("referenceerror")||r.includes("syntaxerror")?"high":r.includes("rangeerror")||r.includes("urierror")?"medium":"low"}determineCategory(e,r){let t=e.message.toLowerCase();return(null==r?void 0:r.componentName)||t.includes("component")||t.includes("render")?"ui":t.includes("network")||t.includes("fetch")||t.includes("connection")?"network":t.includes("api")||t.includes("http")||t.includes("request")?"api":"javascript"}logError(e,r,t,o){let s={id:this.generateErrorId(),timestamp:new Date().toISOString(),message:e.message,stack:e.stack,componentStack:t,userAgent:navigator.userAgent,url:window.location.href,sessionId:this.config.enableSessionTracking?this.sessionId:void 0,severity:this.determineSeverity(e),category:this.determineCategory(e,r),context:r,retryCount:o,resolved:!1};return this.errorQueue.push(s),this.config.enableConsoleLogging&&console.error("[ErrorLogger]",s),this.errorQueue.length>this.config.maxStoredErrors&&this.errorQueue.shift(),"critical"===s.severity&&this.flush(),s.id}logNetworkError(e,r,t,o,s){let n=Error("Network request failed: ".concat(r," ").concat(e).concat(t?" (".concat(t,")"):"")),i={...s,url:e,method:r,status:t,responseText:null==o?void 0:o.substring(0,500)};return this.logError(n,i)}logAPIError(e,r,t,o,s){let n=Error("API request failed: ".concat(r," ").concat(e," (").concat(t,")")),i={...s,endpoint:e,method:r,status:t,responseData:"object"==typeof o?JSON.stringify(o).substring(0,500):o};return this.logError(n,i)}markResolved(e,r){let t=this.errorQueue.find(r=>r.id===e);t&&(t.resolved=!0,t.resolution=r)}async flush(){if(0===this.errorQueue.length||!this.config.enableRemoteReporting)return;let e=this.errorQueue.splice(0,this.config.batchSize);try{if(this.config.remoteEndpoint){let r=await fetch(this.config.remoteEndpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({errors:e,sessionId:this.sessionId,timestamp:new Date().toISOString()})});r.ok||(console.warn("[ErrorLogger] Failed to send error reports:",r.status),this.errorQueue.unshift(...e))}}catch(r){console.warn("[ErrorLogger] Failed to flush error reports:",r),this.errorQueue.unshift(...e)}}startPeriodicFlush(){this.flushTimer=setInterval(()=>{this.flush()},this.config.flushInterval)}async forceFlush(){await this.flush()}getQueuedErrors(){return[...this.errorQueue]}getErrorStats(){let e={total:this.errorQueue.length,bySeverity:{low:0,medium:0,high:0,critical:0},byCategory:{javascript:0,network:0,api:0,ui:0,unknown:0},unresolved:0};return this.errorQueue.forEach(r=>{e.bySeverity[r.severity]++,e.byCategory[r.category]++,!r.resolved&&e.unresolved++}),e}clearQueue(){this.errorQueue=[]}destroy(){this.flushTimer&&clearInterval(this.flushTimer),this.clearQueue()}constructor(e={}){this.errorQueue=[],this.config={enableConsoleLogging:!0,enableRemoteReporting:!1,maxStoredErrors:100,batchSize:10,flushInterval:3e4,enableUserTracking:!1,enableSessionTracking:!0,...e},this.sessionId=this.generateSessionId(),this.config.enableRemoteReporting&&this.config.flushInterval>0&&this.startPeriodicFlush()}}let s=null;function n(e){return s||(s=new o(e)),s}function i(e,r,t,o){return n().logError(e,r,t,o)}function a(e,r,t,o,s){return n().logNetworkError(e,r,t,o,s)}function l(){window.addEventListener("unhandledrejection",e=>{i(Error("Unhandled promise rejection: ".concat(e.reason)),{type:"unhandledrejection",reason:e.reason,promise:e.promise})}),window.addEventListener("error",e=>{i(e.error||Error(e.message),{type:"uncaughterror",filename:e.filename,lineno:e.lineno,colno:e.colno})});let e=console.error;console.error=function(){for(var r=arguments.length,t=Array(r),o=0;o<r;o++)t[o]=arguments[o];if(e.apply(console,t),t.length>0){let e=t.map(e=>"object"==typeof e?JSON.stringify(e):String(e)).join(" ");i(Error("Console error: ".concat(e)),{type:"console_error",originalArgs:t})}}}}}]);
./frontend/.next/static/chunks/app/layout-c44f2ae15e1d8ecb.js:(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[177],{1847:(e,t,r)=>{"use strict";r.d(t,{A:()=>i});var a=r(2115);let s=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,r)=>r?r.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},l=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return t.filter((e,t,r)=>!!e&&""!==e.trim()&&r.indexOf(e)===t).join(" ").trim()};var o={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let n=(0,a.forwardRef)((e,t)=>{let{color:r="currentColor",size:s=24,strokeWidth:n=2,absoluteStrokeWidth:i,className:h="",children:d,iconNode:c,...u}=e;return(0,a.createElement)("svg",{ref:t,...o,width:s,height:s,stroke:r,strokeWidth:i?24*Number(n)/Number(s):n,className:l("lucide",h),...!d&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(u)&&{"aria-hidden":"true"},...u},[...c.map(e=>{let[t,r]=e;return(0,a.createElement)(t,r)}),...Array.isArray(d)?d:[d]])}),i=(e,t)=>{let r=(0,a.forwardRef)((r,o)=>{let{className:i,...h}=r;return(0,a.createElement)(n,{ref:o,iconNode:t,className:l("lucide-".concat(s(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()),"lucide-".concat(e),i),...h})});return r.displayName=s(e),r}},2056:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]])},3673:()=>{},4805:(e,t,r)=>{Promise.resolve().then(r.t.bind(r,8963,23)),Promise.resolve().then(r.t.bind(r,3673,23)),Promise.resolve().then(r.bind(r,5048)),Promise.resolve().then(r.bind(r,5380))},5048:(e,t,r)=>{"use strict";r.d(t,{ClientErrorBoundary:()=>n});var a=r(5155),s=r(2115),l=r(7088),o=r(8812);function n(e){let{children:t}=e,[r,n]=(0,s.useState)(!1);return((0,s.useEffect)(()=>{n(!0),(0,o.NZ)()},[]),r)?(0,a.jsx)(l.tH,{showDetails:!1,onError:(e,t)=>{console.error("Root layout error:",e,t)},children:t}):(0,a.jsx)(a.Fragment,{children:t})}},5993:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("house",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"r6nss1"}]])},6927:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("bug",[["path",{d:"M12 20v-9",key:"1qisl0"}],["path",{d:"M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z",key:"uouzyp"}],["path",{d:"M14.12 3.88 16 2",key:"qol33r"}],["path",{d:"M21 21a4 4 0 0 0-3.81-4",key:"1b0z45"}],["path",{d:"M21 5a4 4 0 0 1-3.55 3.97",key:"5cxbf6"}],["path",{d:"M22 13h-4",key:"1jl80f"}],["path",{d:"M3 21a4 4 0 0 1 3.81-4",key:"1fjd4g"}],["path",{d:"M3 5a4 4 0 0 0 3.55 3.97",key:"1d7oge"}],["path",{d:"M6 13H2",key:"82j7cp"}],["path",{d:"m8 2 1.88 1.88",key:"fmnt4t"}],["path",{d:"M9 7.13V6a3 3 0 1 1 6 0v1.13",key:"1vgav8"}]])},8963:e=>{e.exports={style:{fontFamily:"'Inter', 'Inter Fallback'",fontStyle:"normal"},className:"__className_f367f3"}},9559:(e,t,r)=>{"use strict";r.d(t,{A:()=>a});let a=(0,r(1847).A)("refresh-cw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]])}},e=>{e.O(0,[300,983,441,255,358],()=>e(e.s=4805)),_N_E=e.O()}]);
./frontend/.next/static/chunks/626-16fabec83e504c9b.js:"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[626],{508:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("user",[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]])},1473:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("brain",[["path",{d:"M12 18V5",key:"adv99a"}],["path",{d:"M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4",key:"1e3is1"}],["path",{d:"M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5",key:"1gqd8o"}],["path",{d:"M17.997 5.125a4 4 0 0 1 2.526 5.77",key:"iwvgf7"}],["path",{d:"M18 18a4 4 0 0 0 2-7.464",key:"efp6ie"}],["path",{d:"M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517",key:"1gq6am"}],["path",{d:"M6 18a4 4 0 0 1-2-7.464",key:"k1g0md"}],["path",{d:"M6.003 5.125a4 4 0 0 0-2.526 5.77",key:"q97ue3"}]])},1524:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("trending-up",[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]])},1847:(e,t,a)=>{a.d(t,{A:()=>k});var d=a(2115);let h=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,a)=>a?a.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},r=function(){for(var e=arguments.length,t=Array(e),a=0;a<e;a++)t[a]=arguments[a];return t.filter((e,t,a)=>!!e&&""!==e.trim()&&a.indexOf(e)===t).join(" ").trim()};var y={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let l=(0,d.forwardRef)((e,t)=>{let{color:a="currentColor",size:h=24,strokeWidth:l=2,absoluteStrokeWidth:k,className:p="",children:i,iconNode:c,...n}=e;return(0,d.createElement)("svg",{ref:t,...y,width:h,height:h,stroke:a,strokeWidth:k?24*Number(l)/Number(h):l,className:r("lucide",p),...!i&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(n)&&{"aria-hidden":"true"},...n},[...c.map(e=>{let[t,a]=e;return(0,d.createElement)(t,a)}),...Array.isArray(i)?i:[i]])}),k=(e,t)=>{let a=(0,d.forwardRef)((a,y)=>{let{className:k,...p}=a;return(0,d.createElement)(l,{ref:y,iconNode:t,className:r("lucide-".concat(h(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()),"lucide-".concat(e),k),...p})});return a.displayName=h(e),a}},2056:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]])},2529:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("circle-check-big",[["path",{d:"M21.801 10A10 10 0 1 1 17 3.335",key:"yps3ct"}],["path",{d:"m9 11 3 3L22 4",key:"1pflzl"}]])},3166:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("wifi",[["path",{d:"M12 20h.01",key:"zekei9"}],["path",{d:"M2 8.82a15 15 0 0 1 20 0",key:"dnpr2z"}],["path",{d:"M5 12.859a10 10 0 0 1 14 0",key:"1x1e6c"}],["path",{d:"M8.5 16.429a5 5 0 0 1 7 0",key:"1bycff"}]])},3738:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("wifi-off",[["path",{d:"M12 20h.01",key:"zekei9"}],["path",{d:"M8.5 16.429a5 5 0 0 1 7 0",key:"1bycff"}],["path",{d:"M5 12.859a10 10 0 0 1 5.17-2.69",key:"1dl1wf"}],["path",{d:"M19 12.859a10 10 0 0 0-2.007-1.523",key:"4k23kn"}],["path",{d:"M2 8.82a15 15 0 0 1 4.177-2.643",key:"1grhjp"}],["path",{d:"M22 8.82a15 15 0 0 0-11.288-3.764",key:"z3jwby"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]])},4172:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("server",[["rect",{width:"20",height:"8",x:"2",y:"2",rx:"2",ry:"2",key:"ngkwjq"}],["rect",{width:"20",height:"8",x:"2",y:"14",rx:"2",ry:"2",key:"iecqi9"}],["line",{x1:"6",x2:"6.01",y1:"6",y2:"6",key:"16zg32"}],["line",{x1:"6",x2:"6.01",y1:"18",y2:"18",key:"nzw8ys"}]])},5707:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("cpu",[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]])},5870:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("settings",[["path",{d:"M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",key:"1i5ecw"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]])},5959:(e,t,a)=>{a.d(t,{v:()=>y});var d=a(2115);let h=e=>{let t,a=new Set,d=(e,d)=>{let h="function"==typeof e?e(t):e;if(!Object.is(h,t)){let e=t;t=(null!=d?d:"object"!=typeof h||null===h)?h:Object.assign({},t,h),a.forEach(a=>a(t,e))}},h=()=>t,r={setState:d,getState:h,getInitialState:()=>y,subscribe:e=>(a.add(e),()=>a.delete(e))},y=t=e(d,h,r);return r},r=e=>{let t=(e=>e?h(e):h)(e),a=e=>(function(e,t=e=>e){let a=d.useSyncExternalStore(e.subscribe,d.useCallback(()=>t(e.getState()),[e,t]),d.useCallback(()=>t(e.getInitialState()),[e,t]));return d.useDebugValue(a),a})(t,e);return Object.assign(a,t),a},y=e=>e?r(e):r},5993:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("house",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-6a2 2 0 0 1 2.582 0l7 6A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"r6nss1"}]])},6132:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("circle-alert",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]])},6154:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]])},6191:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("plus",[["path",{d:"M5 12h14",key:"1ays0h"}],["path",{d:"M12 5v14",key:"s699le"}]])},6927:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("bug",[["path",{d:"M12 20v-9",key:"1qisl0"}],["path",{d:"M14 7a4 4 0 0 1 4 4v3a6 6 0 0 1-12 0v-3a4 4 0 0 1 4-4z",key:"uouzyp"}],["path",{d:"M14.12 3.88 16 2",key:"qol33r"}],["path",{d:"M21 21a4 4 0 0 0-3.81-4",key:"1b0z45"}],["path",{d:"M21 5a4 4 0 0 1-3.55 3.97",key:"5cxbf6"}],["path",{d:"M22 13h-4",key:"1jl80f"}],["path",{d:"M3 21a4 4 0 0 1 3.81-4",key:"1fjd4g"}],["path",{d:"M3 5a4 4 0 0 0 3.55 3.97",key:"1d7oge"}],["path",{d:"M6 13H2",key:"82j7cp"}],["path",{d:"m8 2 1.88 1.88",key:"fmnt4t"}],["path",{d:"M9 7.13V6a3 3 0 1 1 6 0v1.13",key:"1vgav8"}]])},6983:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("clock",[["path",{d:"M12 6v6l4 2",key:"mmk7yg"}],["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}]])},7586:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("message-square",[["path",{d:"M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",key:"18887p"}]])},8874:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("circle-x",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m15 9-6 6",key:"1uzhvr"}],["path",{d:"m9 9 6 6",key:"z0biqf"}]])},9559:(e,t,a)=>{a.d(t,{A:()=>d});let d=(0,a(1847).A)("refresh-cw",[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]])}}]);
./frontend/.next/static/chunks/pages/dashboard-503d001218a9a618.js:(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[724],{2013:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>w});var a={};s.r(a);var r=s(7876),i=s(4232),n=s(7328),l=s.n(n);let c=e=>{let t=e.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase());return t.charAt(0).toUpperCase()+t.slice(1)},d=function(){for(var e=arguments.length,t=Array(e),s=0;s<e;s++)t[s]=arguments[s];return t.filter((e,t,s)=>!!e&&""!==e.trim()&&s.indexOf(e)===t).join(" ").trim()};var o={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};let m=(0,i.forwardRef)((e,t)=>{let{color:s="currentColor",size:a=24,strokeWidth:r=2,absoluteStrokeWidth:n,className:l="",children:c,iconNode:m,...h}=e;return(0,i.createElement)("svg",{ref:t,...o,width:a,height:a,stroke:s,strokeWidth:n?24*Number(r)/Number(a):r,className:d("lucide",l),...!c&&!(e=>{for(let t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0})(h)&&{"aria-hidden":"true"},...h},[...m.map(e=>{let[t,s]=e;return(0,i.createElement)(t,s)}),...Array.isArray(c)?c:[c]])}),h=(e,t)=>{let s=(0,i.forwardRef)((s,a)=>{let{className:r,...n}=s;return(0,i.createElement)(m,{ref:a,iconNode:t,className:d("lucide-".concat(c(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()),"lucide-".concat(e),r),...n})});return s.displayName=c(e),s},x=h("trending-up",[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]]),p=h("trending-down",[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]]),g=h("triangle-alert",[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]]),u=h("zap",[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]]),y=h("cpu",[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]]),j=h("activity",[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]]),f=()=>{let e=Date.now(),t=[];for(let s=59;s>=0;s--)t.push({timestamp:e-1e3*s,throughput_ops_sec:850+100*Math.random()-50,latency_ms:85+20*Math.random()-10,memory_mb:48+4*Math.random()-2,cpu_utilization:65+20*Math.random()-10,active_connections:45+Math.floor(20*Math.random()),error_rate:.1+.3*Math.random()-.15,optimization_score:92+8*Math.random()-4});return{current:t[t.length-1],history:t,summary:{avg_throughput:847.5,peak_throughput:925.3,avg_latency:84.2,p95_latency:98.7,avg_memory_mb:48.1,peak_memory_mb:52.3,health_score:94.2,uptime_percent:99.97},alerts:[{id:"1",threshold:{name:"High Latency",metric:"latency",threshold:100},triggered_at:new Date(e-3e5).toISOString(),current_value:98.7,message:"Latency approaching threshold",acknowledged:!1}],optimization_impact:{improvement_percent:84.2,memory_efficiency_gain:30.1,cpu_efficiency_gain:31.3,communication_improvement:47.8,overall_effectiveness:48.4}}},v=e=>{let{title:t,value:s,unit:a="",trend:i,icon:n,color:l}=e;return(0,r.jsx)("div",{className:"bg-white rounded-lg shadow-md p-6 border-l-4",style:{borderLeftColor:l},children:(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{className:"text-sm font-medium text-gray-600",children:t}),(0,r.jsxs)("p",{className:"text-2xl font-bold text-gray-900",children:["number"==typeof s?s.toFixed(1):s,a]}),void 0!==i&&(0,r.jsxs)("div",{className:"flex items-center mt-1",children:[i>0?(0,r.jsx)(x,{className:"h-4 w-4 text-green-500 mr-1"}):(0,r.jsx)(p,{className:"h-4 w-4 text-red-500 mr-1"}),(0,r.jsxs)("span",{className:"text-sm ".concat(i>0?"text-green-600":"text-red-600"),children:[Math.abs(i).toFixed(1),"%"]})]})]}),(0,r.jsx)("div",{className:"text-3xl",style:{color:l},children:n})]})})},N=e=>{let{data:t,color:s,height:a=60}=e,i=Math.max(...t),n=Math.min(...t),l=i-n||1;return(0,r.jsx)("div",{className:"w-full",style:{height:a},children:(0,r.jsx)("svg",{width:"100%",height:"100%",viewBox:"0 0 ".concat(2*t.length," ").concat(a),children:(0,r.jsx)("polyline",{points:t.map((e,t)=>{let s=a-(e-n)/l*a;return"".concat(2*t,",").concat(s)}).join(" "),fill:"none",stroke:s,strokeWidth:"2"})})})},b=e=>{let{alert:t,onAcknowledge:s}=e;return(0,r.jsx)("div",{className:"p-3 rounded-lg border-l-4 ".concat(t.acknowledged?"bg-gray-50 border-gray-400":"bg-red-50 border-red-400"),children:(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsxs)("div",{className:"flex items-center",children:[(0,r.jsx)(g,{className:"h-5 w-5 mr-2 ".concat(t.acknowledged?"text-gray-500":"text-red-500")}),(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{className:"font-medium ".concat(t.acknowledged?"text-gray-700":"text-red-800"),children:t.threshold.name}),(0,r.jsx)("p",{className:"text-sm ".concat(t.acknowledged?"text-gray-600":"text-red-600"),children:t.message})]})]}),!t.acknowledged&&(0,r.jsx)("button",{onClick:()=>s(t.id),className:"px-3 py-1 bg-red-100 text-red-800 rounded text-sm hover:bg-red-200",children:"Acknowledge"})]})})},_=()=>{let[e,t]=(0,i.useState)(f()),[s,n]=(0,i.useState)(!1);(0,i.useEffect)(()=>{let e=setInterval(()=>{t(f())},1e3);return()=>clearInterval(e)},[]),(0,i.useEffect)(()=>{n(!0)},[]);let l=(0,i.useCallback)(e=>{t(t=>({...t,alerts:t.alerts.map(t=>t.id===e?{...t,acknowledged:!0}:t)}))},[]),c=e.history.map(e=>e.throughput_ops_sec),d=e.history.map(e=>e.latency_ms),o=e.history.map(e=>e.memory_mb),m=e.history.map(e=>e.cpu_utilization);return(0,r.jsx)("div",{className:"min-h-screen bg-gray-100 p-6",children:(0,r.jsxs)("div",{className:"max-w-7xl mx-auto",children:[(0,r.jsxs)("div",{className:"mb-8",children:[(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsx)("h1",{className:"text-3xl font-bold text-gray-900",children:"Performance Dashboard"}),(0,r.jsxs)("div",{className:"flex items-center space-x-2",children:[(0,r.jsx)("div",{className:"w-3 h-3 rounded-full ".concat(s?"bg-green-500":"bg-red-500")}),(0,r.jsx)("span",{className:"text-sm text-gray-600",children:s?"Connected":"Disconnected"})]})]}),(0,r.jsx)("p",{className:"text-gray-600 mt-2",children:"Real-time monitoring of AI Orchestrator Hub performance optimizations"})]}),(0,r.jsxs)("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8",children:[(0,r.jsx)(v,{title:"Throughput",value:e.current.throughput_ops_sec,unit:" ops/sec",trend:e.optimization_impact.improvement_percent,icon:(0,r.jsx)(x,{}),color:"#10B981"}),(0,r.jsx)(v,{title:"Latency",value:e.current.latency_ms,unit:"ms",trend:-12.3,icon:(0,r.jsx)(u,{}),color:"#F59E0B"}),(0,r.jsx)(v,{title:"Memory Usage",value:e.current.memory_mb,unit:"MB",trend:-e.optimization_impact.memory_efficiency_gain,icon:(0,r.jsx)(a.Memory,{}),color:"#8B5CF6"}),(0,r.jsx)(v,{title:"CPU Usage",value:e.current.cpu_utilization,unit:"%",trend:-e.optimization_impact.cpu_efficiency_gain,icon:(0,r.jsx)(y,{}),color:"#EF4444"})]}),(0,r.jsxs)("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8",children:[(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"Throughput Trend (ops/sec)"}),(0,r.jsx)(N,{data:c,color:"#10B981",height:120}),(0,r.jsxs)("div",{className:"mt-4 text-sm text-gray-600",children:["Last 60 seconds • Peak: ",Math.max(...c).toFixed(1)," ops/sec"]})]}),(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"Latency Trend (ms)"}),(0,r.jsx)(N,{data:d,color:"#F59E0B",height:120}),(0,r.jsxs)("div",{className:"mt-4 text-sm text-gray-600",children:["Last 60 seconds • P95: ",e.summary.p95_latency.toFixed(1),"ms"]})]}),(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"Memory Usage (MB)"}),(0,r.jsx)(N,{data:o,color:"#8B5CF6",height:120}),(0,r.jsxs)("div",{className:"mt-4 text-sm text-gray-600",children:["Last 60 seconds • Peak: ",Math.max(...o).toFixed(1),"MB"]})]}),(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"CPU Utilization (%)"}),(0,r.jsx)(N,{data:m,color:"#EF4444",height:120}),(0,r.jsxs)("div",{className:"mt-4 text-sm text-gray-600",children:["Last 60 seconds • Avg: ",e.summary.avg_memory_mb.toFixed(1),"%"]})]})]}),(0,r.jsxs)("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-6",children:[(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"Optimization Impact"}),(0,r.jsxs)("div",{className:"space-y-4",children:[(0,r.jsxs)("div",{className:"flex justify-between items-center",children:[(0,r.jsx)("span",{className:"text-sm text-gray-600",children:"Overall Effectiveness"}),(0,r.jsxs)("span",{className:"font-semibold text-green-600",children:["+",e.optimization_impact.overall_effectiveness.toFixed(1),"%"]})]}),(0,r.jsxs)("div",{className:"flex justify-between items-center",children:[(0,r.jsx)("span",{className:"text-sm text-gray-600",children:"Throughput Improvement"}),(0,r.jsxs)("span",{className:"font-semibold text-green-600",children:["+",e.optimization_impact.improvement_percent.toFixed(1),"%"]})]}),(0,r.jsxs)("div",{className:"flex justify-between items-center",children:[(0,r.jsx)("span",{className:"text-sm text-gray-600",children:"Memory Efficiency"}),(0,r.jsxs)("span",{className:"font-semibold text-blue-600",children:["+",e.optimization_impact.memory_efficiency_gain.toFixed(1),"%"]})]}),(0,r.jsxs)("div",{className:"flex justify-between items-center",children:[(0,r.jsx)("span",{className:"text-sm text-gray-600",children:"CPU Efficiency"}),(0,r.jsxs)("span",{className:"font-semibold text-purple-600",children:["+",e.optimization_impact.cpu_efficiency_gain.toFixed(1),"%"]})]}),(0,r.jsxs)("div",{className:"flex justify-between items-center",children:[(0,r.jsx)("span",{className:"text-sm text-gray-600",children:"Communication Speed"}),(0,r.jsxs)("span",{className:"font-semibold text-orange-600",children:["+",e.optimization_impact.communication_improvement.toFixed(1),"%"]})]})]})]}),(0,r.jsxs)("div",{className:"bg-white rounded-lg shadow-md p-6",children:[(0,r.jsxs)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:["Performance Alerts (",e.alerts.filter(e=>!e.acknowledged).length," active)"]}),(0,r.jsx)("div",{className:"space-y-3",children:e.alerts.length>0?e.alerts.map(e=>(0,r.jsx)(b,{alert:e,onAcknowledge:l},e.id)):(0,r.jsxs)("div",{className:"text-center py-8 text-gray-500",children:[(0,r.jsx)(j,{className:"h-12 w-12 mx-auto mb-2 text-green-500"}),(0,r.jsx)("p",{children:"All systems operating normally"})]})})]})]}),(0,r.jsxs)("div",{className:"mt-8 bg-white rounded-lg shadow-md p-6",children:[(0,r.jsx)("h3",{className:"text-lg font-semibold text-gray-900 mb-4",children:"System Health Summary"}),(0,r.jsxs)("div",{className:"grid grid-cols-2 md:grid-cols-4 gap-4",children:[(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsxs)("p",{className:"text-2xl font-bold text-green-600",children:[e.summary.health_score.toFixed(1),"%"]}),(0,r.jsx)("p",{className:"text-sm text-gray-600",children:"Health Score"})]}),(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsxs)("p",{className:"text-2xl font-bold text-blue-600",children:[e.summary.uptime_percent.toFixed(2),"%"]}),(0,r.jsx)("p",{className:"text-sm text-gray-600",children:"Uptime"})]}),(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsx)("p",{className:"text-2xl font-bold text-purple-600",children:e.current.active_connections}),(0,r.jsx)("p",{className:"text-sm text-gray-600",children:"Active Connections"})]}),(0,r.jsxs)("div",{className:"text-center",children:[(0,r.jsxs)("p",{className:"text-2xl font-bold text-orange-600",children:[e.current.error_rate.toFixed(2),"%"]}),(0,r.jsx)("p",{className:"text-sm text-gray-600",children:"Error Rate"})]})]})]})]})})},w=()=>(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(l(),{children:[(0,r.jsx)("title",{children:"Performance Dashboard - AI Orchestrator Hub"}),(0,r.jsx)("meta",{name:"description",content:"Real-time performance monitoring dashboard for AI Orchestrator Hub optimizations"}),(0,r.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"}),(0,r.jsx)("link",{rel:"icon",href:"/favicon.ico"})]}),(0,r.jsx)("main",{children:(0,r.jsx)(_,{})})]})},7328:(e,t,s)=>{e.exports=s(7918)},7580:(e,t,s)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/dashboard",function(){return s(2013)}])}},e=>{e.O(0,[636,593,792],()=>e(e.s=7580)),_N_E=e.O()}]);
./frontend/.next/server/chunks/611.js:          `}}),(0,d.jsx)("script",{"data-partytown":"",dangerouslySetInnerHTML:{__html:a()}}),(f.worker||[]).map((a,c)=>{let{strategy:d,src:f,children:h,dangerouslySetInnerHTML:i,...j}=a,k={};if(f)k.src=f;else if(i&&i.__html)k.dangerouslySetInnerHTML={__html:i.__html};else if(h)k.dangerouslySetInnerHTML={__html:"string"==typeof h?h:Array.isArray(h)?h.join(""):""};else throw Object.defineProperty(Error("Invalid usage of next/script. Did you forget to include a src attribute or an inline script? https://nextjs.org/docs/messages/invalid-script"),"__NEXT_ERROR_CODE",{value:"E82",enumerable:!1,configurable:!0});return(0,e.createElement)("script",{...k,...j,type:"text/partytown",key:f||c,nonce:b.nonce,"data-nscript":"worker",crossOrigin:b.crossOrigin||g})})]})}catch(a){return(0,i.default)(a)&&"MODULE_NOT_FOUND"!==a.code&&console.warn(`Warning: ${a.message}`),null}}(a,b),j=(c.beforeInteractive||[]).filter(a=>a.src).map((a,c)=>{let{strategy:d,...h}=a;return(0,e.createElement)("script",{...h,key:h.src||c,defer:h.defer??!f,nonce:h.nonce||b.nonce,"data-nscript":"beforeInteractive",crossOrigin:b.crossOrigin||g})});return(0,d.jsxs)(d.Fragment,{children:[h,j]})}class v extends e.default.Component{static #a=this.contextType=j.HtmlContext;getCssLinks(a){let{assetPrefix:b,assetQueryString:c,dynamicImports:e,dynamicCssManifest:f,crossOrigin:g,optimizeCss:h}=this.context,i=a.allFiles.filter(a=>a.endsWith(".css")),j=new Set(a.sharedFiles),l=new Set([]),m=Array.from(new Set(e.filter(a=>a.endsWith(".css"))));if(m.length){let a=new Set(i);l=new Set(m=m.filter(b=>!(a.has(b)||j.has(b)))),i.push(...m)}let n=[];return i.forEach(a=>{let e=j.has(a),i=l.has(a),m=f.has(a);h||n.push((0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"style",crossOrigin:this.props.crossOrigin||g},`${a}-preload`)),n.push((0,d.jsx)("link",{nonce:this.props.nonce,rel:"stylesheet",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,crossOrigin:this.props.crossOrigin||g,"data-n-g":i?void 0:e?"":void 0,"data-n-p":e||i||m?void 0:""},a))}),0===n.length?null:n}getPreloadDynamicChunks(){let{dynamicImports:a,assetPrefix:b,assetQueryString:c,crossOrigin:e}=this.context;return a.map(a=>a.endsWith(".js")?(0,d.jsx)("link",{rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"script",nonce:this.props.nonce,crossOrigin:this.props.crossOrigin||e},a):null).filter(Boolean)}getPreloadMainLinks(a){let{assetPrefix:b,assetQueryString:c,scriptLoader:e,crossOrigin:f}=this.context,g=a.allFiles.filter(a=>a.endsWith(".js"));return[...(e.beforeInteractive||[]).map(a=>(0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:a.src,as:"script",crossOrigin:this.props.crossOrigin||f},a.src)),...g.map(a=>(0,d.jsx)("link",{nonce:this.props.nonce,rel:"preload",href:`${b}/_next/${(0,k.encodeURIPath)(a)}${c}`,as:"script",crossOrigin:this.props.crossOrigin||f},a))]}getBeforeInteractiveInlineScripts(){let{scriptLoader:a}=this.context,{nonce:b,crossOrigin:c}=this.props;return(a.beforeInteractive||[]).filter(a=>!a.src&&(a.dangerouslySetInnerHTML||a.children)).map((a,d)=>{let{strategy:f,children:g,dangerouslySetInnerHTML:h,src:i,...j}=a,k="";return h&&h.__html?k=h.__html:g&&(k="string"==typeof g?g:Array.isArray(g)?g.join(""):""),(0,e.createElement)("script",{...j,dangerouslySetInnerHTML:{__html:k},key:j.id||d,nonce:b,"data-nscript":"beforeInteractive",crossOrigin:c||void 0})})}getDynamicChunks(a){return s(this.context,this.props,a)}getPreNextScripts(){return u(this.context,this.props)}getScripts(a){return t(this.context,this.props,a)}getPolyfillScripts(){return q(this.context,this.props)}render(){let{styles:a,ampPath:b,inAmpMode:f,hybridAmp:g,canonicalBase:h,__NEXT_DATA__:i,dangerousAsPath:j,headTags:n,unstable_runtimeJS:o,unstable_JsPreload:q,disableOptimizedLoading:s,optimizeCss:t,assetPrefix:u,nextFontManifest:v}=this.context,w=!1===o,x=!1===q||!s;this.context.docComponentsRendered.Head=!0;let{head:y}=this.context,z=[],A=[];y&&(y.forEach(a=>{a&&"link"===a.type&&"preload"===a.props.rel&&"style"===a.props.as?z.push(a):a&&A.push(e.default.cloneElement(a,{"data-next-head":""}))}),y=z.concat(A));let B=e.default.Children.toArray(this.props.children).filter(Boolean),C=!1,D=!1;y=e.default.Children.map(y||[],a=>{if(!a)return a;let{type:b,props:c}=a;if(f){let d="";if("meta"===b&&"viewport"===c.name?d='name="viewport"':"link"===b&&"canonical"===c.rel?D=!0:"script"===b&&(c.src&&-1>c.src.indexOf("ampproject")||c.dangerouslySetInnerHTML&&(!c.type||"text/javascript"===c.type))&&(d="<script",Object.keys(c).forEach(a=>{d+=` ${a}="${c[a]}"`}),d+="/>"),d)return console.warn(`Found conflicting amp tag "${a.type}" with conflicting prop ${d} in ${i.page}. https://nextjs.org/docs/messages/conflicting-amp-tag`),null}else"link"===b&&"amphtml"===c.rel&&(C=!0);return a});let E=p(this.context.buildManifest,this.context.__NEXT_DATA__.page,f),F=function(a,b,c=""){if(!a)return{preconnect:null,preload:null};let e=a.pages["/_app"],f=a.pages[b],g=Array.from(new Set([...e??[],...f??[]]));return{preconnect:0===g.length&&(e||f)?(0,d.jsx)("link",{"data-next-font":a.pagesUsingSizeAdjust?"size-adjust":"",rel:"preconnect",href:"/",crossOrigin:"anonymous"}):null,preload:g?g.map(a=>{let b=/\.(woff|woff2|eot|ttf|otf)$/.exec(a)[1];return(0,d.jsx)("link",{rel:"preload",href:`${c}/_next/${(0,k.encodeURIPath)(a)}`,as:"font",type:`font/${b}`,crossOrigin:"anonymous","data-next-font":a.includes("-s")?"size-adjust":""},a)}):null}}(v,j,u),G=((0,m.getTracedMetadata)((0,l.getTracer)().getTracePropagationData(),this.context.experimentalClientTraceMetadata)||[]).map(({key:a,value:b},c)=>(0,d.jsx)("meta",{name:a,content:b},`next-trace-data-${c}`));return(0,d.jsxs)("head",{...function(a){let{crossOrigin:b,nonce:c,...d}=a;return d}(this.props),children:[this.context.isDevelopment&&(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("style",{"data-next-hide-fouc":!0,"data-ampdevmode":f?"true":void 0,dangerouslySetInnerHTML:{__html:"body{display:none}"}}),(0,d.jsx)("noscript",{"data-next-hide-fouc":!0,"data-ampdevmode":f?"true":void 0,children:(0,d.jsx)("style",{dangerouslySetInnerHTML:{__html:"body{display:block}"}})})]}),y,B,F.preconnect,F.preload,f&&(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("meta",{name:"viewport",content:"width=device-width,minimum-scale=1,initial-scale=1"}),!D&&(0,d.jsx)("link",{rel:"canonical",href:h+c(5401).cleanAmpPath(j)}),(0,d.jsx)("link",{rel:"preload",as:"script",href:"https://cdn.ampproject.org/v0.js"}),(0,d.jsx)(r,{styles:a}),(0,d.jsx)("style",{"amp-boilerplate":"",dangerouslySetInnerHTML:{__html:"body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}"}}),(0,d.jsx)("noscript",{children:(0,d.jsx)("style",{"amp-boilerplate":"",dangerouslySetInnerHTML:{__html:"body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}"}})}),(0,d.jsx)("script",{async:!0,src:"https://cdn.ampproject.org/v0.js"})]}),!f&&(0,d.jsxs)(d.Fragment,{children:[!C&&g&&(0,d.jsx)("link",{rel:"amphtml",href:h+(b||`${j}${j.includes("?")?"&":"?"}amp=1`)}),this.getBeforeInteractiveInlineScripts(),!t&&this.getCssLinks(E),!t&&(0,d.jsx)("noscript",{"data-n-css":this.props.nonce??""}),!w&&!x&&this.getPreloadDynamicChunks(),!w&&!x&&this.getPreloadMainLinks(E),!s&&!w&&this.getPolyfillScripts(),!s&&!w&&this.getPreNextScripts(),!s&&!w&&this.getDynamicChunks(E),!s&&!w&&this.getScripts(E),t&&this.getCssLinks(E),t&&(0,d.jsx)("noscript",{"data-n-css":this.props.nonce??""}),this.context.isDevelopment&&(0,d.jsx)("noscript",{id:"__next_css__DO_NOT_USE__"}),G,a||null]}),e.default.createElement(e.default.Fragment,{},...n||[])]})}}class w extends e.default.Component{static #a=this.contextType=j.HtmlContext;getDynamicChunks(a){return s(this.context,this.props,a)}getPreNextScripts(){return u(this.context,this.props)}getScripts(a){return t(this.context,this.props,a)}getPolyfillScripts(){return q(this.context,this.props)}static getInlineScriptSource(a){let{__NEXT_DATA__:b,largePageDataBytes:d}=a;try{let e=JSON.stringify(b);if(o.has(b.page))return(0,h.htmlEscapeJsonString)(e);let f=Buffer.from(e).byteLength,g=c(3135).A;return d&&f>d&&(o.add(b.page),console.warn(`Warning: data for page "${b.page}"${b.page===a.dangerousAsPath?"":` (path "${a.dangerousAsPath}")`} is ${g(f)} which exceeds the threshold of ${g(d)}, this amount of data can reduce performance.
./frontend/.next/server/chunks/61.js:  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`))}function X(a,b,c,d){if(0!==b){if(c.hasSuspenseAboveBody)return;if(d.syncDynamicErrorWithStack)throw W(a,d.syncDynamicErrorWithStack),new f.StaticGenBailoutError;let e=c.dynamicErrors;if(e.length>0){for(let b=0;b<e.length;b++)W(a,e[b]);throw new f.StaticGenBailoutError}if(c.hasDynamicViewport)throw console.error(`Route "${a.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`),new f.StaticGenBailoutError;if(1===b)throw console.error(`Route "${a.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`),new f.StaticGenBailoutError}else if(!1===c.hasAllowedDynamic&&c.hasDynamicMetadata)throw console.error(`Route "${a.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`),new f.StaticGenBailoutError}function Y(a,b){return a.runtimeStagePromise?a.runtimeStagePromise.then(()=>b):b}},1830:(a,b)=>{"use strict";function c(a,b){return void 0===b&&(b=!0),a.pathname+a.search+(b?a.hash:"")}Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"createHrefFromUrl",{enumerable:!0,get:function(){return c}}),("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},1832:(a,b,c)=>{"use strict";a.exports=c(6796).vendored.contexts.ServerInsertedHtml},1843:(a,b)=>{"use strict";function c(a){let b=5381;for(let c=0;c<a.length;c++)b=(b<<5)+b+a.charCodeAt(c)|0;return b>>>0}function d(a){return c(a).toString(36).slice(0,5)}Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{djb2Hash:function(){return c},hexHash:function(){return d}})},1938:(a,b)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{StaticGenBailoutError:function(){return d},isStaticGenBailoutError:function(){return e}});let c="NEXT_STATIC_GEN_BAILOUT";class d extends Error{constructor(...a){super(...a),this.code=c}}function e(a){return"object"==typeof a&&null!==a&&"code"in a&&a.code===c}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},1949:(a,b)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"LRUCache",{enumerable:!0,get:function(){return e}});class c{constructor(a,b,c){this.prev=null,this.next=null,this.key=a,this.data=b,this.size=c}}class d{constructor(){this.prev=null,this.next=null}}class e{constructor(a,b){this.cache=new Map,this.totalSize=0,this.maxSize=a,this.calculateSize=b,this.head=new d,this.tail=new d,this.head.next=this.tail,this.tail.prev=this.head}addToHead(a){a.prev=this.head,a.next=this.head.next,this.head.next.prev=a,this.head.next=a}removeNode(a){a.prev.next=a.next,a.next.prev=a.prev}moveToHead(a){this.removeNode(a),this.addToHead(a)}removeTail(){let a=this.tail.prev;return this.removeNode(a),a}set(a,b){let d=(null==this.calculateSize?void 0:this.calculateSize.call(this,b))??1;if(d>this.maxSize)return void console.warn("Single item size exceeds maxSize");let e=this.cache.get(a);if(e)e.data=b,this.totalSize=this.totalSize-e.size+d,e.size=d,this.moveToHead(e);else{let e=new c(a,b,d);this.cache.set(a,e),this.addToHead(e),this.totalSize+=d}for(;this.totalSize>this.maxSize&&this.cache.size>0;){let a=this.removeTail();this.cache.delete(a.key),this.totalSize-=a.size}}has(a){return this.cache.has(a)}get(a){let b=this.cache.get(a);if(b)return this.moveToHead(b),b.data}*[Symbol.iterator](){let a=this.head.next;for(;a&&a!==this.tail;){let b=a;yield[b.key,b.data],a=a.next}}remove(a){let b=this.cache.get(a);b&&(this.removeNode(b),this.cache.delete(a),this.totalSize-=b.size)}get size(){return this.cache.size}get currentSize(){return this.totalSize}}},1972:a=>{(()=>{"use strict";var b={328:a=>{a.exports=function(a){for(var b=5381,c=a.length;c;)b=33*b^a.charCodeAt(--c);return b>>>0}}},c={};function d(a){var e=c[a];if(void 0!==e)return e.exports;var f=c[a]={exports:{}},g=!0;try{b[a](f,f.exports,d),g=!1}finally{g&&delete c[a]}return f.exports}d.ab=__dirname+"/",a.exports=d(328)})()},1981:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"isNextRouterError",{enumerable:!0,get:function(){return f}});let d=c(8541),e=c(2781);function f(a){return(0,e.isRedirectError)(a)||(0,d.isHTTPAccessFallbackError)(a)}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2074:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{createFlightReactServerErrorHandler:function(){return p},createHTMLErrorHandler:function(){return r},createHTMLReactServerErrorHandler:function(){return q},getDigestForWellKnownError:function(){return o},isUserLandError:function(){return s}});let d=function(a){return a&&a.__esModule?a:{default:a}}(c(1972)),e=c(4397),f=c(2324),g=c(5088),h=c(9305),i=c(9168),j=c(1981),k=c(6906),l=c(9816),m=c(7907),n=c(5439);function o(a){if((0,h.isBailoutToCSRError)(a)||(0,j.isNextRouterError)(a)||(0,i.isDynamicServerError)(a)||(0,k.isPrerenderInterruptedError)(a))return a.digest}function p(a,b){return c=>{if("string"==typeof c)return(0,d.default)(c).toString();if((0,g.isAbortError)(c))return;let h=o(c);if(h)return h;if((0,n.isReactLargeShellError)(c))return void console.error(c);let i=(0,l.getProperError)(c);i.digest||(i.digest=(0,d.default)(i.message+i.stack||"").toString()),a&&(0,e.formatServerError)(i);let j=(0,f.getTracer)().getActiveScopeSpan();return j&&(j.recordException(i),j.setAttribute("error.type",i.name),j.setStatus({code:f.SpanStatusCode.ERROR,message:i.message})),b(i),(0,m.createDigestWithErrorCode)(c,i.digest)}}function q(a,b,c,h,i){return j=>{var k;if("string"==typeof j)return(0,d.default)(j).toString();if((0,g.isAbortError)(j))return;let p=o(j);if(p)return p;if((0,n.isReactLargeShellError)(j))return void console.error(j);let q=(0,l.getProperError)(j);if(q.digest||(q.digest=(0,d.default)(q.message+(q.stack||"")).toString()),c.has(q.digest)||c.set(q.digest,q),a&&(0,e.formatServerError)(q),!(b&&(null==q||null==(k=q.message)?void 0:k.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))){let a=(0,f.getTracer)().getActiveScopeSpan();a&&(a.recordException(q),a.setAttribute("error.type",q.name),a.setStatus({code:f.SpanStatusCode.ERROR,message:q.message})),h||null==i||i(q)}return(0,m.createDigestWithErrorCode)(j,q.digest)}}function r(a,b,c,h,i,j){return(k,p)=>{var q;if((0,n.isReactLargeShellError)(k))return void console.error(k);let r=!0;if(h.push(k),(0,g.isAbortError)(k))return;let s=o(k);if(s)return s;let t=(0,l.getProperError)(k);if(t.digest?c.has(t.digest)&&(k=c.get(t.digest),r=!1):t.digest=(0,d.default)(t.message+((null==p?void 0:p.componentStack)||t.stack||"")).toString(),a&&(0,e.formatServerError)(t),!(b&&(null==t||null==(q=t.message)?void 0:q.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))){let a=(0,f.getTracer)().getActiveScopeSpan();a&&(a.recordException(t),a.setAttribute("error.type",t.name),a.setStatus({code:f.SpanStatusCode.ERROR,message:t.message})),!i&&r&&j(t,p)}return(0,m.createDigestWithErrorCode)(k,t.digest)}}function s(a){return!(0,g.isAbortError)(a)&&!(0,h.isBailoutToCSRError)(a)&&!(0,j.isNextRouterError)(a)}},2090:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"unstable_rethrow",{enumerable:!0,get:function(){return d}});let d=c(7761).unstable_rethrow;("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2120:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"useRouterBFCache",{enumerable:!0,get:function(){return e}});let d=c(8301);function e(a,b){let[c,e]=(0,d.useState)(()=>({tree:a,stateKey:b,next:null}));if(c.tree===a)return c;let f={tree:a,stateKey:b,next:null},g=1,h=c,i=f;for(;null!==h&&g<1;){if(h.stateKey===b){i.next=h.next;break}{g++;let a={tree:h.tree,stateKey:h.stateKey,next:null};i.next=a,i=a}h=h.next}return e(f),f}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2131:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"Postpone",{enumerable:!0,get:function(){return d.Postpone}});let d=c(6906)},2146:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"IconMark",{enumerable:!0,get:function(){return e}});let d=c(1124),e=()=>(0,d.jsx)("meta",{name:"\xabnxt-icon\xbb"})},2158:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{dispatchAppRouterAction:function(){return g},useActionQueue:function(){return h}});let d=c(5823)._(c(8301)),e=c(9039),f=null;function g(a){if(null===f)throw Object.defineProperty(Error("Internal Next.js error: Router action dispatched before initialization."),"__NEXT_ERROR_CODE",{value:"E668",enumerable:!1,configurable:!0});f(a)}function h(a){let[b,c]=d.default.useState(a.state);return f=b=>a.dispatch(b,c),(0,e.isThenable)(b)?(0,d.use)(b):b}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2263:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{MetadataBoundary:function(){return f},OutletBoundary:function(){return h},RootLayoutBoundary:function(){return i},ViewportBoundary:function(){return g}});let d=c(5818),e={[d.METADATA_BOUNDARY_NAME]:function({children:a}){return a},[d.VIEWPORT_BOUNDARY_NAME]:function({children:a}){return a},[d.OUTLET_BOUNDARY_NAME]:function({children:a}){return a},[d.ROOT_LAYOUT_BOUNDARY_NAME]:function({children:a}){return a}},f=e[d.METADATA_BOUNDARY_NAME.slice(0)],g=e[d.VIEWPORT_BOUNDARY_NAME.slice(0)],h=e[d.OUTLET_BOUNDARY_NAME.slice(0)],i=e[d.ROOT_LAYOUT_BOUNDARY_NAME.slice(0)]},2324:(a,b,c)=>{"use strict";let d;Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{BubbledError:function(){return m},SpanKind:function(){return k},SpanStatusCode:function(){return j},getTracer:function(){return u},isBubbledError:function(){return n}});let e=c(8928),f=c(9577);try{d=c(8688)}catch(a){d=c(8688)}let{context:g,propagation:h,trace:i,SpanStatusCode:j,SpanKind:k,ROOT_CONTEXT:l}=d;class m extends Error{constructor(a,b){super(),this.bubble=a,this.result=b}}function n(a){return"object"==typeof a&&null!==a&&a instanceof m}let o=(a,b)=>{n(b)&&b.bubble?a.setAttribute("next.bubble",!0):(b&&(a.recordException(b),a.setAttribute("error.type",b.name)),a.setStatus({code:j.ERROR,message:null==b?void 0:b.message})),a.end()},p=new Map,q=d.createContextKey("next.rootSpanId"),r=0,s={set(a,b,c){a.push({key:b,value:c})}};class t{getTracerInstance(){return i.getTracer("next.js","0.0.1")}getContext(){return g}getTracePropagationData(){let a=g.active(),b=[];return h.inject(a,b,s),b}getActiveScopeSpan(){return i.getSpan(null==g?void 0:g.active())}withPropagatedContext(a,b,c){let d=g.active();if(i.getSpanContext(d))return b();let e=h.extract(d,a,c);return g.with(e,b)}trace(...a){var b;let[c,d,h]=a,{fn:j,options:k}="function"==typeof d?{fn:d,options:{}}:{fn:h,options:{...d}},m=k.spanName??c;if(!e.NextVanillaSpanAllowlist.includes(c)&&"1"!==process.env.NEXT_OTEL_VERBOSE||k.hideSpan)return j();let n=this.getSpanContext((null==k?void 0:k.parentSpan)??this.getActiveScopeSpan()),s=!1;n?(null==(b=i.getSpanContext(n))?void 0:b.isRemote)&&(s=!0):(n=(null==g?void 0:g.active())??l,s=!0);let t=r++;return k.attributes={"next.span_name":m,"next.span_type":c,...k.attributes},g.with(n.setValue(q,t),()=>this.getTracerInstance().startActiveSpan(m,k,a=>{let b="performance"in globalThis&&"measure"in performance?globalThis.performance.now():void 0,d=()=>{p.delete(t),b&&process.env.NEXT_OTEL_PERFORMANCE_PREFIX&&e.LogSpanAllowList.includes(c||"")&&performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(c.split(".").pop()||"").replace(/[A-Z]/g,a=>"-"+a.toLowerCase())}`,{start:b,end:performance.now()})};s&&p.set(t,new Map(Object.entries(k.attributes??{})));try{if(j.length>1)return j(a,b=>o(a,b));let b=j(a);if((0,f.isThenable)(b))return b.then(b=>(a.end(),b)).catch(b=>{throw o(a,b),b}).finally(d);return a.end(),d(),b}catch(b){throw o(a,b),d(),b}}))}wrap(...a){let b=this,[c,d,f]=3===a.length?a:[a[0],{},a[1]];return e.NextVanillaSpanAllowlist.includes(c)||"1"===process.env.NEXT_OTEL_VERBOSE?function(){let a=d;"function"==typeof a&&"function"==typeof f&&(a=a.apply(this,arguments));let e=arguments.length-1,h=arguments[e];if("function"!=typeof h)return b.trace(c,a,()=>f.apply(this,arguments));{let d=b.getContext().bind(g.active(),h);return b.trace(c,a,(a,b)=>(arguments[e]=function(a){return null==b||b(a),d.apply(this,arguments)},f.apply(this,arguments)))}}:f}startSpan(...a){let[b,c]=a,d=this.getSpanContext((null==c?void 0:c.parentSpan)??this.getActiveScopeSpan());return this.getTracerInstance().startSpan(b,c,d)}getSpanContext(a){return a?i.setSpan(g.active(),a):void 0}getRootSpanAttributes(){let a=g.active().getValue(q);return p.get(a)}setRootSpanAttribute(a,b){let c=g.active().getValue(q),d=p.get(c);d&&d.set(a,b)}}let u=(()=>{let a=new t;return()=>a})()},2418:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),Object.defineProperty(b,"HandleISRError",{enumerable:!0,get:function(){return e}});let d=c(9294).workAsyncStorage;function e(a){let{error:b}=a;if(d){let a=d.getStore();if((null==a?void 0:a.isRevalidate)||(null==a?void 0:a.isStaticGeneration))throw console.error(b),b}return null}("function"==typeof b.default||"object"==typeof b.default&&null!==b.default)&&void 0===b.default.__esModule&&(Object.defineProperty(b.default,"__esModule",{value:!0}),Object.assign(b.default,b),a.exports=b.default)},2435:(a,b,c)=>{"use strict";Object.defineProperty(b,"__esModule",{value:!0}),!function(a,b){for(var c in b)Object.defineProperty(a,c,{enumerable:!0,get:b[c]})}(b,{accumulateMetadata:function(){return I},accumulateViewport:function(){return J},resolveMetadata:function(){return K},resolveViewport:function(){return L}}),c(7925);let d=c(4515),e=c(9880),f=c(8512),g=c(7782),h=c(96),i=c(8783),j=c(1166),k=c(6613),l=c(3958),m=c(2324),n=c(8928),o=c(6896),p=function(a,b){if(a&&a.__esModule)return a;if(null===a||"object"!=typeof a&&"function"!=typeof a)return{default:a};var c=r(b);if(c&&c.has(a))return c.get(a);var d={__proto__:null},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var f in a)if("default"!==f&&Object.prototype.hasOwnProperty.call(a,f)){var g=e?Object.getOwnPropertyDescriptor(a,f):null;g&&(g.get||g.set)?Object.defineProperty(d,f,g):d[f]=a[f]}return d.default=a,c&&c.set(a,d),d}(c(310)),q=c(9963);function r(a){if("function"!=typeof WeakMap)return null;var b=new WeakMap,c=new WeakMap;return(r=function(a){return a?c:b})(a)}async function s(a,b,c,d,e,g,h){var i,j;if(!c)return b;let{icon:k,apple:l,openGraph:m,twitter:n,manifest:o}=c;if(k&&(g.icon=k),l&&(g.apple=l),n&&!(null==a||null==(i=a.twitter)?void 0:i.hasOwnProperty("images"))){let a=(0,f.resolveTwitter)({...b.twitter,images:n},b.metadataBase,{...d,isStaticMetadataRouteFile:!0},e.twitter);b.twitter=a}if(m&&!(null==a||null==(j=a.openGraph)?void 0:j.hasOwnProperty("images"))){let a=await (0,f.resolveOpenGraph)({...b.openGraph,images:m},b.metadataBase,h,{...d,isStaticMetadataRouteFile:!0},e.openGraph);b.openGraph=a}return o&&(b.manifest=o),b}async function t(a,b,{source:c,target:d,staticFilesMetadata:e,titleTemplates:i,metadataContext:j,buildState:m,leafSegmentStaticIcons:n}){let o=void 0!==(null==c?void 0:c.metadataBase)?c.metadataBase:d.metadataBase;for(let e in c)switch(e){case"title":d.title=(0,g.resolveTitle)(c.title,i.title);break;case"alternates":d.alternates=await (0,k.resolveAlternates)(c.alternates,o,b,j);break;case"openGraph":d.openGraph=await (0,f.resolveOpenGraph)(c.openGraph,o,b,j,i.openGraph);break;case"twitter":d.twitter=(0,f.resolveTwitter)(c.twitter,o,j,i.twitter);break;case"facebook":d.facebook=(0,k.resolveFacebook)(c.facebook);break;case"verification":d.verification=(0,k.resolveVerification)(c.verification);break;case"icons":d.icons=(0,l.resolveIcons)(c.icons);break;case"appleWebApp":d.appleWebApp=(0,k.resolveAppleWebApp)(c.appleWebApp);break;case"appLinks":d.appLinks=(0,k.resolveAppLinks)(c.appLinks);break;case"robots":d.robots=(0,k.resolveRobots)(c.robots);break;case"archives":case"assets":case"bookmarks":case"keywords":d[e]=(0,h.resolveAsArrayOrUndefined)(c[e]);break;case"authors":d[e]=(0,h.resolveAsArrayOrUndefined)(c.authors);break;case"itunes":d[e]=await (0,k.resolveItunes)(c.itunes,o,b,j);break;case"pagination":d.pagination=await (0,k.resolvePagination)(c.pagination,o,b,j);break;case"abstract":case"applicationName":case"description":case"generator":case"creator":case"publisher":case"category":case"classification":case"referrer":case"formatDetection":case"manifest":case"pinterest":d[e]=c[e]||null;break;case"other":d.other=Object.assign({},d.other,c.other);break;case"metadataBase":d.metadataBase=o;break;case"apple-touch-fullscreen":m.warnings.add(`Use appleWebApp instead
./frontend/.next/server/chunks/184.js:exports.id=184,exports.ids=[184],exports.modules={947:(a,b,c)=>{Promise.resolve().then(c.bind(c,1272)),Promise.resolve().then(c.bind(c,1172))},1135:()=>{},1172:(a,b,c)=>{"use strict";c.d(b,{AuthProvider:()=>e});var d=c(7954);(0,d.registerClientReference)(function(){throw Error("Attempted to call useAuth() from the server but useAuth is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/workspaces/ai-orchestrator-hub/frontend/src/contexts/AuthContext.tsx","useAuth");let e=(0,d.registerClientReference)(function(){throw Error("Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/workspaces/ai-orchestrator-hub/frontend/src/contexts/AuthContext.tsx","AuthProvider")},1272:(a,b,c)=>{"use strict";c.d(b,{ClientErrorBoundary:()=>d});let d=(0,c(7954).registerClientReference)(function(){throw Error("Attempted to call ClientErrorBoundary() from the server but ClientErrorBoundary is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.")},"/workspaces/ai-orchestrator-hub/frontend/src/components/ClientErrorBoundary.tsx","ClientErrorBoundary")},1472:(a,b,c)=>{"use strict";c.r(b),c.d(b,{default:()=>j,metadata:()=>i});var d=c(5338),e=c(3305),f=c.n(e);c(1135);var g=c(1272),h=c(1172);let i={title:"AI Orchestrator Hub",description:"A sophisticated multiagent system implementing hive/swarm intelligence with NLP self-learning capabilities."};function j({children:a}){return(0,d.jsx)("html",{lang:"en",children:(0,d.jsx)("body",{className:f().className,children:(0,d.jsx)(h.AuthProvider,{children:(0,d.jsx)(g.ClientErrorBoundary,{children:a})})})})}},2752:(a,b,c)=>{Promise.resolve().then(c.t.bind(c,4160,23)),Promise.resolve().then(c.t.bind(c,1603,23)),Promise.resolve().then(c.t.bind(c,8495,23)),Promise.resolve().then(c.t.bind(c,5170,23)),Promise.resolve().then(c.t.bind(c,7526,23)),Promise.resolve().then(c.t.bind(c,8922,23)),Promise.resolve().then(c.t.bind(c,9234,23)),Promise.resolve().then(c.t.bind(c,2263,23)),Promise.resolve().then(c.bind(c,2146))},3024:(a,b,c)=>{Promise.resolve().then(c.t.bind(c,1170,23)),Promise.resolve().then(c.t.bind(c,3597,23)),Promise.resolve().then(c.t.bind(c,6893,23)),Promise.resolve().then(c.t.bind(c,9748,23)),Promise.resolve().then(c.t.bind(c,6060,23)),Promise.resolve().then(c.t.bind(c,7184,23)),Promise.resolve().then(c.t.bind(c,9576,23)),Promise.resolve().then(c.t.bind(c,3041,23)),Promise.resolve().then(c.t.bind(c,1384,23))},3814:(a,b,c)=>{"use strict";c.d(b,{NZ:()=>i,v$:()=>h,vV:()=>g});class d{constructor(a={}){this.errorQueue=[],this.config={enableConsoleLogging:!0,enableRemoteReporting:!1,maxStoredErrors:100,batchSize:10,flushInterval:3e4,enableUserTracking:!1,enableSessionTracking:!0,...a},this.sessionId=this.generateSessionId(),this.config.enableRemoteReporting&&this.config.flushInterval>0&&this.startPeriodicFlush()}generateSessionId(){return`session_${Date.now()}_${Math.random().toString(36).substring(2,11)}`}generateErrorId(){return`error_${Date.now()}_${Math.random().toString(36).substring(2,11)}`}determineSeverity(a){let b=a.message.toLowerCase();return b.includes("network")||b.includes("fetch")||b.includes("connection")?"medium":b.includes("unauthorized")||b.includes("forbidden")||b.includes("auth")||b.includes("typeerror")||b.includes("referenceerror")||b.includes("syntaxerror")?"high":b.includes("rangeerror")||b.includes("urierror")?"medium":"low"}determineCategory(a,b){let c=a.message.toLowerCase();return b?.componentName||c.includes("component")||c.includes("render")?"ui":c.includes("network")||c.includes("fetch")||c.includes("connection")?"network":c.includes("api")||c.includes("http")||c.includes("request")?"api":"javascript"}logError(a,b,c,d){let e={id:this.generateErrorId(),timestamp:new Date().toISOString(),message:a.message,stack:a.stack,componentStack:c,userAgent:navigator.userAgent,url:window.location.href,sessionId:this.config.enableSessionTracking?this.sessionId:void 0,severity:this.determineSeverity(a),category:this.determineCategory(a,b),context:b,retryCount:d,resolved:!1};return this.errorQueue.push(e),this.config.enableConsoleLogging&&console.error("[ErrorLogger]",e),this.errorQueue.length>this.config.maxStoredErrors&&this.errorQueue.shift(),"critical"===e.severity&&this.flush(),e.id}logNetworkError(a,b,c,d,e){let f=Error(`Network request failed: ${b} ${a}${c?` (${c})`:""}`),g={...e,url:a,method:b,status:c,responseText:d?.substring(0,500)};return this.logError(f,g)}logAPIError(a,b,c,d,e){let f=Error(`API request failed: ${b} ${a} (${c})`),g={...e,endpoint:a,method:b,status:c,responseData:"object"==typeof d?JSON.stringify(d).substring(0,500):d};return this.logError(f,g)}markResolved(a,b){let c=this.errorQueue.find(b=>b.id===a);c&&(c.resolved=!0,c.resolution=b)}async flush(){if(0===this.errorQueue.length||!this.config.enableRemoteReporting)return;let a=this.errorQueue.splice(0,this.config.batchSize);try{if(this.config.remoteEndpoint){let b=await fetch(this.config.remoteEndpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({errors:a,sessionId:this.sessionId,timestamp:new Date().toISOString()})});b.ok||(console.warn("[ErrorLogger] Failed to send error reports:",b.status),this.errorQueue.unshift(...a))}}catch(b){console.warn("[ErrorLogger] Failed to flush error reports:",b),this.errorQueue.unshift(...a)}}startPeriodicFlush(){this.flushTimer=setInterval(()=>{this.flush()},this.config.flushInterval)}async forceFlush(){await this.flush()}getQueuedErrors(){return[...this.errorQueue]}getErrorStats(){let a={total:this.errorQueue.length,bySeverity:{low:0,medium:0,high:0,critical:0},byCategory:{javascript:0,network:0,api:0,ui:0,unknown:0},unresolved:0};return this.errorQueue.forEach(b=>{a.bySeverity[b.severity]++,a.byCategory[b.category]++,!b.resolved&&a.unresolved++}),a}clearQueue(){this.errorQueue=[]}destroy(){this.flushTimer&&clearInterval(this.flushTimer),this.clearQueue()}}let e=null;function f(a){return e||(e=new d(a)),e}function g(a,b,c,d){return f().logError(a,b,c,d)}function h(a,b,c,d,e){return f().logNetworkError(a,b,c,d,e)}function i(){window.addEventListener("unhandledrejection",a=>{g(Error(`Unhandled promise rejection: ${a.reason}`),{type:"unhandledrejection",reason:a.reason,promise:a.promise})}),window.addEventListener("error",a=>{g(a.error||Error(a.message),{type:"uncaughterror",filename:a.filename,lineno:a.lineno,colno:a.colno})});let a=console.error;console.error=(...b)=>{if(a.apply(console,b),b.length>0){let a=b.map(a=>"object"==typeof a?JSON.stringify(a):String(a)).join(" ");g(Error(`Console error: ${a}`),{type:"console_error",originalArgs:b})}}}},4342:(a,b,c)=>{"use strict";c.d(b,{A:()=>g,AuthProvider:()=>h});var d=c(1124),e=c(8301);let f=(0,e.createContext)(void 0),g=()=>{let a=(0,e.useContext)(f);if(void 0===a)throw Error("useAuth must be used within an AuthProvider");return a},h=({children:a})=>{let[b,c]=(0,e.useState)({user:null,token:null,refreshToken:null,isAuthenticated:!1,isLoading:!0});(0,e.useEffect)(()=>{(()=>{try{let a=localStorage.getItem("auth_token"),b=localStorage.getItem("refresh_token"),d=localStorage.getItem("user");if(a&&d){let e=JSON.parse(d);c({user:e,token:a,refreshToken:b,isAuthenticated:!0,isLoading:!1})}else c(a=>({...a,isLoading:!1}))}catch(a){console.error("Error initializing auth state:",a),localStorage.removeItem("auth_token"),localStorage.removeItem("refresh_token"),localStorage.removeItem("user"),c(a=>({...a,isLoading:!1}))}})()},[]);let g=async(a,b,d="Human")=>{try{let e=await fetch("/api/auth/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:a,password:b,client_type:d})});if(!e.ok){let a=await e.json();throw Error(a.error||"Login failed")}let f=await e.json();localStorage.setItem("auth_token",f.token),localStorage.setItem("refresh_token",f.refresh_token),localStorage.setItem("user",JSON.stringify(f.user)),c({user:f.user,token:f.token,refreshToken:f.refresh_token,isAuthenticated:!0,isLoading:!1})}catch(a){throw console.error("Login error:",a),a}},h=async()=>{try{b.token&&await fetch("/api/auth/logout",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${b.token}`},body:JSON.stringify({session_id:b.user?.id||"unknown"})})}catch(a){console.error("Logout API error:",a)}localStorage.removeItem("auth_token"),localStorage.removeItem("refresh_token"),localStorage.removeItem("user"),c({user:null,token:null,refreshToken:null,isAuthenticated:!1,isLoading:!1})},i=async()=>{if(!b.refreshToken)throw Error("No refresh token available");try{let a=await fetch("/api/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refresh_token:b.refreshToken})});if(!a.ok){let b=await a.json();throw Error(b.error||"Token refresh failed")}let d=await a.json();localStorage.setItem("auth_token",d.token),c(a=>({...a,token:d.token}))}catch(a){throw console.error("Token refresh error:",a),await h(),a}},j={...b,login:g,logout:h,refreshTokenFn:i,hasPermission:a=>b.user?.permissions.includes(a)||!1,hasRole:a=>b.user?.roles.includes(a)||!1};return(0,d.jsx)(f.Provider,{value:j,children:a})}},6921:(a,b,c)=>{"use strict";c.d(b,{tH:()=>j});var d=c(1124),e=c(8301),f=c(6945),g=c(8547),h=c(5345),i=c(8733);class j extends e.Component{constructor(a){super(a),this.retryTimeouts=[],this.reportError=(a,b)=>{console.error("Error Report:",{message:a.message,stack:a.stack,componentStack:b.componentStack,timestamp:new Date().toISOString(),userAgent:navigator.userAgent,url:window.location.href,retryCount:this.state.retryCount})},this.handleRetry=()=>{this.setState(a=>({hasError:!1,error:void 0,errorInfo:void 0,retryCount:a.retryCount+1}))},this.handleAutoRetry=()=>{let a=setTimeout(()=>{this.handleRetry()},2e3);this.retryTimeouts.push(a)},this.handleGoHome=()=>{window.location.href="/"},this.state={hasError:!1,retryCount:0}}static getDerivedStateFromError(a){return{hasError:!0,error:a}}componentDidCatch(a,b){console.error("ErrorBoundary caught an error:",a,b),this.props.onError?.(a,b),this.reportError(a,b),this.setState({error:a,errorInfo:b})}componentWillUnmount(){this.retryTimeouts.forEach(a=>clearTimeout(a))}render(){return this.state.hasError?this.props.fallback?this.props.fallback:(0,d.jsx)("div",{className:"min-h-screen bg-gray-50 flex items-center justify-center px-4",children:(0,d.jsxs)("div",{className:"max-w-md w-full bg-white rounded-lg shadow-lg p-6",children:[(0,d.jsx)("div",{className:"flex items-center justify-center mb-4",children:(0,d.jsx)("div",{className:"bg-red-100 rounded-full p-3",children:(0,d.jsx)(f.A,{className:"h-8 w-8 text-red-600"})})}),(0,d.jsx)("h1",{className:"text-xl font-semibold text-gray-900 text-center mb-2",children:"Something went wrong"}),(0,d.jsx)("p",{className:"text-gray-600 text-center mb-6",children:"We encountered an unexpected error. Please try refreshing the page or contact support if the problem persists."}),this.props.showDetails&&this.state.error&&(0,d.jsxs)("div",{className:"bg-gray-50 rounded-md p-4 mb-4",children:[(0,d.jsxs)("h3",{className:"text-sm font-medium text-gray-900 mb-2 flex items-center",children:[(0,d.jsx)(g.A,{className:"h-4 w-4 mr-2"}),"Error Details"]}),(0,d.jsxs)("details",{className:"text-xs text-gray-600",children:[(0,d.jsx)("summary",{className:"cursor-pointer hover:text-gray-900",children:"Click to show technical details"}),(0,d.jsxs)("pre",{className:"mt-2 whitespace-pre-wrap break-words",children:[this.state.error.message,this.state.error.stack&&`
./frontend/.next/server/webpack-runtime.js:(()=>{"use strict";var a={},b={};function c(d){var e=b[d];if(void 0!==e)return e.exports;var f=b[d]={exports:{}},g=!0;try{a[d](f,f.exports,c),g=!1}finally{g&&delete b[d]}return f.exports}c.m=a,c.n=a=>{var b=a&&a.__esModule?()=>a.default:()=>a;return c.d(b,{a:b}),b},(()=>{var a,b=Object.getPrototypeOf?a=>Object.getPrototypeOf(a):a=>a.__proto__;c.t=function(d,e){if(1&e&&(d=this(d)),8&e||"object"==typeof d&&d&&(4&e&&d.__esModule||16&e&&"function"==typeof d.then))return d;var f=Object.create(null);c.r(f);var g={};a=a||[null,b({}),b([]),b(b)];for(var h=2&e&&d;"object"==typeof h&&!~a.indexOf(h);h=b(h))Object.getOwnPropertyNames(h).forEach(a=>g[a]=()=>d[a]);return g.default=()=>d,c.d(f,g),f}})(),c.d=(a,b)=>{for(var d in b)c.o(b,d)&&!c.o(a,d)&&Object.defineProperty(a,d,{enumerable:!0,get:b[d]})},c.f={},c.e=a=>Promise.all(Object.keys(c.f).reduce((b,d)=>(c.f[d](a,b),b),[])),c.u=a=>""+a+".js",c.o=(a,b)=>Object.prototype.hasOwnProperty.call(a,b),c.r=a=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(a,"__esModule",{value:!0})},c.X=(a,b,d)=>{var e=b;d||(b=a,d=()=>c(c.s=e)),b.map(c.e,c);var f=d();return void 0===f?a:f},(()=>{var a={311:1},b=b=>{var d=b.modules,e=b.ids,f=b.runtime;for(var g in d)c.o(d,g)&&(c.m[g]=d[g]);f&&f(c);for(var h=0;h<e.length;h++)a[e[h]]=1};c.f.require=(d,e)=>{a[d]||(311!=d?b(require("./chunks/"+c.u(d))):a[d]=1)},module.exports=c,c.C=b})()})();
./frontend/.next/server/server-reference-manifest.js:self.__RSC_SERVER_MANIFEST="{\"node\":{},\"edge\":{},\"encryptionKey\":\"process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY\"}"
./frontend/.next/types/app/page.ts:  ? { [K in keyof T]: T[K] extends string ? string | string[] | undefined : never }
./frontend/.next/types/app/page.ts:// If T is unknown or any, it will be an empty {} type. Otherwise, it will be the same as Omit<T, keyof Base>.
./frontend/.next/types/app/page.ts:type OmitWithTag<T, K extends keyof any, _M> = Omit<T, K>
./frontend/.next/types/app/page.ts:type Diff<Base, T extends Base, Message extends string = ''> = 0 extends (1 & T) ? {} : OmitWithTag<T, keyof Base, Message>
./frontend/.next/types/app/page.ts:function checkFields<_ extends { [k in keyof any]: never }>() {}
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4",
./frontend/package-lock.json:        "js-tokens": "^4.0.0",
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:        "@csstools/css-tokenizer": "^3.0.4"
./frontend/package-lock.json:    "node_modules/@csstools/css-tokenizer": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@csstools/css-tokenizer/-/css-tokenizer-3.0.4.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.3"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "8.44.0",
./frontend/package-lock.json:    "node_modules/@typescript-eslint/visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.44.0.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^4.2.1"
./frontend/package-lock.json:    "node_modules/@typescript-eslint/visitor-keys/node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
./frontend/package-lock.json:        "js-tokens": "^9.0.1"
./frontend/package-lock.json:    "node_modules/ast-v8-to-istanbul/node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
./frontend/package-lock.json:        "path-key": "^3.1.0",
./frontend/package-lock.json:        "object-keys": "^1.1.1"
./frontend/package-lock.json:        "object-keys": "^1.1.1",
./frontend/package-lock.json:        "own-keys": "^1.0.1",
./frontend/package-lock.json:        "eslint-visitor-keys": "^4.2.1",
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "7.18.0"
./frontend/package-lock.json:        "@typescript-eslint/visitor-keys": "7.18.0",
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-7.18.0.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^3.4.3"
./frontend/package-lock.json:    "node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
./frontend/package-lock.json:    "node_modules/eslint/node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
./frontend/package-lock.json:        "eslint-visitor-keys": "^4.2.1"
./frontend/package-lock.json:    "node_modules/espree/node_modules/eslint-visitor-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
./frontend/package-lock.json:        "keyv": "^4.5.4"
./frontend/package-lock.json:    "node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
./frontend/package-lock.json:    "node_modules/keyv": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
./frontend/package-lock.json:        "js-tokens": "^3.0.0 || ^4.0.0"
./frontend/package-lock.json:    "node_modules/object-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
./frontend/package-lock.json:        "object-keys": "^1.1.1"
./frontend/package-lock.json:    "node_modules/own-keys": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/own-keys/-/own-keys-1.0.1.tgz",
./frontend/package-lock.json:        "object-keys": "^1.1.1",
./frontend/package-lock.json:    "node_modules/path-key": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
./frontend/package-lock.json:        "js-tokens": "^9.0.1"
./frontend/package-lock.json:    "node_modules/strip-literal/node_modules/js-tokens": {
./frontend/package-lock.json:      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz",
./frontend/package-lock.json:      "integrity": "sha512-nWJ91DjeOkej/TA8pXQ3myruKpKEYgqvpw9lz4OPHj/NWFNluYrjbz9j01CJ8yKQd2g4jFoOkINCTW2I5LEEyw==",
