# Multiagent Hive System - Developer Guide

## Project Overview

A sophisticated **hybrid neural multiagent hive system** implementing swarm intelligence with NLP self-learning capabilities. **CPU-native, GPU-optional - built for the GPU-poor.**

### Technology Stack
- **Backend**: Rust with Axum web framework, Tokio async runtime
- **Frontend**: TypeScript, React, Next.js 14, Tailwind CSS
- **Communication**: WebSocket for real-time updates, REST API for CRUD operations
- **Neural Processing**: Basic NLP (default) + optional ruv-FANN integration
- **State Management**: Zustand store with WebSocket integration

## Core Architecture

### Backend Structure (`backend/src/`)
- **`main.rs`** - Axum server entry point with WebSocket and REST endpoints
- **`hive.rs`** - Central HiveCoordinator managing agent swarms and metrics
- **`agent.rs`** - Agent implementations with types, capabilities, and behaviors
- **`task.rs`** - Task queue system with priority-based distribution
- **`communication.rs`** - WebSocket handlers for real-time coordination
- **`nlp.rs`** - Lightweight NLP processing with semantic analysis
- **`neural.rs`** - Hybrid neural architecture (basic + optional FANN)
- **`cpu_optimization.rs`** - SIMD vectorization and performance optimizations

### Frontend Structure (`frontend/src/`)
- **`app/page.tsx`** - Main application with tab navigation
- **`components/HiveDashboard.tsx`** - Primary monitoring interface
- **`components/SwarmVisualization.tsx`** - Real-time agent visualization
- **`components/MetricsPanel.tsx`** - Performance metrics display
- **`components/AgentManager.tsx`** - Agent creation and configuration
- **`components/TaskManager.tsx`** - Task creation and monitoring
- **`store/hiveStore.ts`** - Zustand store with WebSocket communication

### Examples & Testing (`backend/examples/`)
- **`neural_comparison.rs`** - Compare basic vs advanced neural processing
- **`advanced_neural_test.rs`** - Test advanced neural features
- **`lstm_demo.rs`** - LSTM network demonstrations

## Development Guidelines

### Code Standards
- Use descriptive variable names following Rust/TypeScript conventions
- Implement async/await patterns throughout for performance
- Follow DRY principles with modular architecture
- Write clean, readable code without unnecessary comments
- Use professional documentation style

### Architecture Patterns
- **Dependency Injection**: AppState pattern for shared resources
- **Actor Model**: Agents as independent entities with message passing
- **Event-Driven**: WebSocket-based real-time updates
- **Layered Architecture**: Clear separation between coordination, processing, and presentation

### Performance Optimizations
- **Concurrent Processing**: Tokio async runtime with DashMap for thread-safe storage
- **SIMD Vectorization**: CPU-optimized operations in `cpu_optimization.rs`
- **Memory Efficiency**: Quantized operations and cache-aware data structures
- **Real-time Updates**: 5-second WebSocket intervals for live metrics

## Feature Flags & Build Modes

### Cargo Features
```toml
[features]
default = ["basic-nlp"]
basic-nlp = []                    # Lightweight NLP processing
advanced-neural = ["ruv-fann"]    # FANN neural networks
gpu-acceleration = ["ruv-fann/gpu"] # GPU support (optional)
```

### Build Commands
```bash
# Basic mode (recommended for development)
cargo run

# Advanced neural features
cargo run --features advanced-neural

# Run examples
cargo run --features advanced-neural --example neural_comparison
cargo run --example advanced_neural_test
cargo run --example lstm_demo
```

### Frontend Development
```bash
cd frontend
npm install
npm run dev     # Development server on :3000
npm run build   # Production build
npm run lint    # ESLint checking
```

## Agent System

### Agent Types
- **Worker**: General task execution and basic coordination
- **Coordinator**: Swarm leadership and task distribution
- **Specialist(String)**: Domain-specific expertise
- **Learner**: Continuous learning and adaptation

### Agent States
- **Idle**: Available for task assignment
- **Working**: Actively executing tasks
- **Learning**: Processing new patterns/insights
- **Communicating**: Inter-agent coordination
- **Failed**: Error state requiring intervention

### Capabilities System
```rust
pub struct AgentCapability {
    pub name: String,
    pub proficiency: f64,      // 0.0 to 1.0
    pub learning_rate: f64,    // How quickly this improves
}
```

## Task Management

### Task Priority Levels
- **Low**: Background processing
- **Medium**: Standard operations
- **High**: Important business logic
- **Critical**: System-critical operations

### Task Status Flow
```
Pending → Assigned → InProgress → Completed
                              → Failed
                              → Cancelled
```

### Capability Matching
Tasks specify required capabilities, and the system automatically assigns agents with matching proficiencies.

## Communication System

### WebSocket Messages
- **`hive_status`**: Complete hive state and metrics
- **`agents_update`**: Agent list with current states
- **`metrics_update`**: Performance metrics updates
- **`agent_created`**: New agent creation notifications
- **`task_created`**: New task creation notifications

### REST API Endpoints
- **GET/POST `/api/agents`**: Agent management
- **GET/POST `/api/tasks`**: Task management  
- **GET `/api/hive/status`**: Current hive status

## Neural Processing

### Basic NLP (Default)
- Lightweight sentiment analysis
- Keyword extraction and pattern recognition
- Semantic vector operations
- Learning from agent interactions

### Advanced Neural (Optional)
- FANN neural networks for complex pattern recognition
- LSTM networks for time series forecasting
- Performance prediction and optimization
- Advanced swarm coordination algorithms

### CPU Optimization Features
- SIMD instruction detection (AVX2, AVX512, SSE4.1, NEON)
- Vectorized operations for matrix computations
- Quantized neural network operations
- Cache-aware data structures

## Data Structures

### Core Types
```rust
// Agent with capabilities and state
pub struct Agent {
    pub id: Uuid,
    pub agent_type: AgentType,
    pub state: AgentState,
    pub capabilities: Vec<AgentCapability>,
    pub position: (f64, f64),
    pub energy: f64,
    // ... additional fields
}

// Task with requirements and status
pub struct Task {
    pub id: Uuid,
    pub description: String,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub required_capabilities: Vec<TaskRequiredCapability>,
    // ... additional fields
}
```

### Metrics & Monitoring
```rust
pub struct SwarmMetrics {
    pub total_agents: usize,
    pub active_agents: usize,
    pub completed_tasks: usize,
    pub failed_tasks: usize,
    pub average_performance: f64,
    pub swarm_cohesion: f64,
    pub learning_progress: f64,
}
```

## Development Workflow

### Quick Start
1. **Backend**: `cd backend && cargo run`
2. **Frontend**: `cd frontend && npm install && npm run dev`
3. **Access**: Frontend at `http://localhost:3000`, Backend at `http://localhost:3001`

### Testing Neural Features
```bash
# Compare basic vs advanced processing
cargo run --features advanced-neural --example neural_comparison

# Test advanced neural capabilities
cargo run --features advanced-neural --example advanced_neural_test

# LSTM demonstration
cargo run --features advanced-neural --example lstm_demo
```

### Debugging WebSocket Communication
- Use browser dev tools to monitor WebSocket messages
- Check backend logs for connection status and errors
- Verify message format matches expected schema in `hiveStore.ts`

## Best Practices

### Performance Considerations
- Use `DashMap` for concurrent agent storage
- Implement proper error handling with `anyhow::Result`
- Leverage Rust's ownership system for memory safety
- Use TypeScript strict mode for frontend type safety

### Code Organization
- Keep components focused on single responsibilities
- Use Zustand for centralized state management
- Implement proper error boundaries in React components
- Follow Rust module organization patterns

### Resource Management
- Monitor agent energy levels and performance metrics
- Implement proper cleanup for WebSocket connections
- Use feature flags to control resource-intensive operations
- Consider memory usage when scaling agent populations

## Deployment Notes

### Production Considerations
- Set appropriate CORS policies for production domains
- Configure proper logging levels for production environments
- Consider load balancing for multiple hive instances
- Monitor WebSocket connection limits and performance

### Hardware Requirements
- **Minimum**: 2GB RAM, 2 CPU cores (basic NLP mode)
- **Recommended**: 4GB RAM, 4 CPU cores (advanced neural features)
- **Optimal**: 8GB+ RAM, 8+ CPU cores with SIMD support

### Environment Variables
- Configure backend port (default: 3001)
- Set WebSocket connection limits
- Configure neural processing parameters
- Set logging levels and output destinations