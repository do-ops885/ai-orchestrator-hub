# Multiagent Hive System - Developer Guide

## Project Overview

A sophisticated **hybrid neural multiagent hive system** implementing swarm intelligence with NLP self-learning capabilities. **CPU-native, GPU-optional - built for the GPU-poor.**

### Technology Stack
- **Backend**: Rust with Axum web framework, Tokio async runtime
- **Frontend**: TypeScript, React, Next.js 15, Tailwind CSS
- **Communication**: WebSocket for real-time updates, REST API for CRUD operations
- **Neural Processing**: Basic NLP (default) + optional ruv-FANN integration
- **State Management**: Zustand store with WebSocket integration
- **MCP Integration**: Model Context Protocol server for external tool integration

## Core Architecture

### Backend Structure (`backend/src/`)
- **`main.rs`** - Axum server entry point with WebSocket and REST endpoints
- **`core/hive.rs`** - Central HiveCoordinator managing agent swarms and metrics
- **`agents/agent.rs`** - Agent implementations with types, capabilities, and behaviors
- **`tasks/task.rs`** - Task queue system with priority-based distribution
- **`communication/`** - WebSocket handlers and MCP server implementation
- **`neural/`** - NLP processing and hybrid neural architecture
- **`infrastructure/`** - Metrics, caching, resource management, telemetry
- **`utils/`** - Configuration, error handling, validation utilities
- **`bin/mcp_server.rs`** - Standalone MCP server binary

### Frontend Structure (`frontend/src/`)
- **`app/page.tsx`** - Main application with tab navigation
- **`components/HiveDashboard.tsx`** - Primary monitoring interface
- **`components/SwarmVisualization.tsx`** - Real-time agent visualization
- **`components/MetricsPanel.tsx`** - Performance metrics display
- **`components/NeuralMetrics.tsx`** - Neural processing metrics
- **`components/ResourceMonitor.tsx`** - System resource monitoring
- **`components/AgentManager.tsx`** - Agent creation and configuration
- **`components/TaskManager.tsx`** - Task creation and monitoring
- **`store/hiveStore.ts`** - Zustand store with WebSocket communication

### Examples & Testing (`backend/examples/`)
- **`neural_comparison.rs`** - Compare basic vs advanced neural processing
- **`advanced_neural_test.rs`** - Test advanced neural features
- **`lstm_demo.rs`** - LSTM network demonstrations

## Development Guidelines

### Code Standards
- **Rust**: Follow Clippy rules with comprehensive linting (see `clippy.toml`)
- **TypeScript**: Strict type checking with ESLint flat config
- **Async/Await**: Use throughout for performance and consistency
- **Error Handling**: Use `anyhow::Result` for Rust, proper error boundaries for React
- **Documentation**: Write clear, professional documentation without unnecessary comments

### Architecture Patterns
- **Modular Design**: Clean separation of concerns across modules
- **Dependency Injection**: AppState pattern for shared resources
- **Actor Model**: Agents as independent entities with message passing
- **Event-Driven**: WebSocket-based real-time updates
- **Trait-Based**: Extensible MCP tools via `MCPToolHandler` trait

### Linting & Code Quality

#### Backend (Rust)
- **Clippy**: Comprehensive rules with performance focus (see `backend/clippy.toml`)
- **Rustfmt**: Consistent formatting with 100-char line width (see `backend/rustfmt.toml`)
- **Strict Lints**: Deny `unwrap_used`, `panic`, `unreachable_code`
- **Performance**: Deny `clone_on_ref_ptr`, `rc_buffer`, `rc_mutex`
- **CI/CD**: GitHub Actions with `RUSTFLAGS="-Dwarnings"` for zero-warning builds

#### Frontend (TypeScript)
- **ESLint**: Modern flat config with TypeScript-aware rules (see `frontend/eslint.config.js`)
- **React**: Hooks and refresh rules for development
- **Style**: Single quotes, no semicolons, Unix line endings
- **Type Safety**: Strict boolean expressions, consistent type definitions
- **CI/CD**: TypeScript compilation checks and ESLint with max warnings = 0

### Performance Optimizations
- **Concurrent Processing**: Tokio async runtime with DashMap for thread-safe storage
- **SIMD Vectorization**: CPU-optimized operations in `cpu_optimization.rs`
- **Memory Efficiency**: Quantized operations and cache-aware data structures
- **Real-time Updates**: Efficient WebSocket communication with 5-second intervals

## Feature Flags & Build Modes

### Cargo Features
```toml
[features]
default = ["basic-nlp"]
basic-nlp = []                    # Lightweight NLP processing
advanced-neural = ["ruv-fann"]    # FANN neural networks
gpu-acceleration = ["ruv-fann/gpu"] # GPU support (optional)
```

### Build Commands
```bash
# Basic mode (recommended for development)
cargo run

# Advanced neural features
cargo run --features advanced-neural

# MCP server
cargo run --bin mcp_server

# Run examples
cargo run --features advanced-neural --example neural_comparison
cargo run --example advanced_neural_test
cargo run --example lstm_demo
```

### Frontend Development
```bash
cd frontend
npm install
npm run dev        # Development server on :3000
npm run build      # Production build
npm run lint       # ESLint checking
npm run lint:fix   # Auto-fix linting issues
npm run lint:check # Zero-warning check for CI
```

## Agent System

### Agent Types
- **Worker**: General task execution and basic coordination
- **Coordinator**: Swarm leadership and task distribution
- **Specialist(String)**: Domain-specific expertise
- **Learner**: Continuous learning and adaptation

### Agent States
- **Idle**: Available for task assignment
- **Working**: Actively executing tasks
- **Learning**: Processing new patterns/insights
- **Communicating**: Inter-agent coordination
- **Failed**: Error state requiring intervention

### Capabilities System
```rust
pub struct AgentCapability {
    pub name: String,
    pub proficiency: f64,      // 0.0 to 1.0
    pub learning_rate: f64,    // How quickly this improves
}
```

## Task Management

### Task Priority Levels
- **Low**: Background processing
- **Medium**: Standard operations
- **High**: Important business logic
- **Critical**: System-critical operations

### Task Status Flow
```
Pending ‚Üí Assigned ‚Üí InProgress ‚Üí Completed
                              ‚Üí Failed
                              ‚Üí Cancelled
```

### Capability Matching
Tasks specify required capabilities, and the system automatically assigns agents with matching proficiencies.

## Communication System

### WebSocket Messages
- **`hive_status`**: Complete hive state and metrics
- **`agents_update`**: Agent list with current states
- **`metrics_update`**: Performance metrics updates
- **`agent_created`**: New agent creation notifications
- **`task_created`**: New task creation notifications

### REST API Endpoints
- **GET/POST `/api/agents`**: Agent management
- **GET/POST `/api/tasks`**: Task management  
- **GET `/api/hive/status`**: Current hive status

### MCP Integration
- **Tools**: `create_swarm_agent`, `assign_swarm_task`, `get_swarm_status`, `analyze_with_nlp`, `coordinate_agents`
- **Resources**: `hive://status` for live system access
- **Protocol**: Full MCP 1.0 compliance with JSON-RPC 2.0

## Neural Processing

### Basic NLP (Default)
- Lightweight sentiment analysis
- Keyword extraction and pattern recognition
- Semantic vector operations
- Learning from agent interactions

### Advanced Neural (Optional)
- FANN neural networks for complex pattern recognition
- LSTM networks for time series forecasting
- Performance prediction and optimization
- Advanced swarm coordination algorithms

### CPU Optimization Features
- SIMD instruction detection (AVX2, AVX512, SSE4.1, NEON)
- Vectorized operations for matrix computations
- Quantized neural network operations
- Cache-aware data structures

## Data Structures

### Core Types
```rust
// Agent with capabilities and state
pub struct Agent {
    pub id: Uuid,
    pub agent_type: AgentType,
    pub state: AgentState,
    pub capabilities: Vec<AgentCapability>,
    pub position: (f64, f64),
    pub energy: f64,
    // ... additional fields
}

// Task with requirements and status
pub struct Task {
    pub id: Uuid,
    pub description: String,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub required_capabilities: Vec<TaskRequiredCapability>,
    // ... additional fields
}
```

### Frontend Types (TypeScript)
```typescript
interface Agent {
  id: string;
  name: string;
  type: string;
  state: string;
  capabilities: Array<{
    name: string;
    proficiency: number;
    learning_rate: number;
  }>;
  position: [number, number];
  energy: number;
  experience_count: number;
  social_connections: number;
}

interface HiveMetrics {
  total_agents: number;
  active_agents: number;
  completed_tasks: number;
  failed_tasks: number;
  average_performance: number;
  swarm_cohesion: number;
  learning_progress: number;
}
```

## Development Workflow

### Quick Start
1. **Backend**: `cd backend && cargo run`
2. **Frontend**: `cd frontend && npm install && npm run dev`
3. **MCP Server**: `cd backend && cargo run --bin mcp_server`
4. **Access**: Frontend at `http://localhost:3000`, Backend at `http://localhost:3001`

### Testing Neural Features
```bash
# Compare basic vs advanced processing
cargo run --features advanced-neural --example neural_comparison

# Test advanced neural capabilities
cargo run --features advanced-neural --example advanced_neural_test

# LSTM demonstration
cargo run --features advanced-neural --example lstm_demo
```

### CI/CD Pipeline
- **Linting**: Automated Clippy and ESLint checks with zero-warning policy
- **Formatting**: Rustfmt and Prettier validation
- **Testing**: Cargo test with all features + frontend build verification
- **Documentation**: Cargo doc generation for API documentation

### Debugging & Monitoring
- **WebSocket**: Use browser dev tools to monitor real-time messages
- **Backend Logs**: Check Rust tracing output for detailed system information
- **Frontend State**: Inspect Zustand store state in React DevTools
- **MCP Integration**: Test tools via any MCP-compatible client

## Best Practices

### Performance Considerations
- Use `DashMap` for concurrent agent storage
- Implement proper error handling with `anyhow::Result`
- Leverage Rust's ownership system for memory safety
- Use TypeScript strict mode for frontend type safety
- Follow clippy performance lints (no `clone_on_ref_ptr`, etc.)

### Code Organization
- **Modules**: Follow the established module structure in `lib.rs`
- **Components**: Keep React components focused on single responsibilities
- **State**: Use Zustand for centralized state management
- **Traits**: Implement extensible patterns via trait-based design
- **Testing**: Write comprehensive tests for critical functionality

### üö® **CRITICAL: Enhancement vs New File Guidelines**

**‚úÖ DO: Enhance Existing Files**
- When adding features to existing functionality, **ALWAYS enhance the existing file**
- Example: Adding advanced features to metrics ‚Üí enhance existing `metrics` module
- Example: Adding new capabilities to core functionality ‚Üí enhance existing core files
- Example: Adding enhanced processing ‚Üí enhance existing processor modules

**‚ùå DON'T: Create "Advanced" or Duplicate Files**
- Never create files with prefixes like `advanced_`, `enhanced_`, `new_`, `improved_`
- Never duplicate existing functionality in separate files
- This creates confusion, maintenance overhead, and architectural debt

**‚úÖ WHEN to Create New Files:**
- **Completely new functionality** that doesn't exist yet
- **New subsystems** that complement existing ones
- **Utility modules** that support existing functionality
- **Cross-cutting concerns** (logging, monitoring, security)

**üîç Before Creating Any New File, Ask:**
1. "Does this functionality already exist in another file?"
2. "Can I enhance an existing file instead?"
3. "Is this truly a new subsystem or just an enhancement?"
4. "Will this create confusion about which file to use?"

**üìù Naming Convention for New Files:**
- Use descriptive, specific names that clearly indicate purpose
- Avoid generic prefixes: ~~`advanced_`, `enhanced_`, `new_`, `improved_`~~
- Make the functionality clear from the filename
- Follow project naming conventions

### Resource Management
- Monitor agent energy levels and performance metrics
- Implement proper cleanup for WebSocket connections
- Use feature flags to control resource-intensive operations
- Consider memory usage when scaling agent populations
- Leverage infrastructure modules for caching and resource management

## Configuration Files

### Backend Configuration
- **`Cargo.toml`**: Dependencies, features, and lint configuration
- **`clippy.toml`**: Comprehensive Clippy rules with performance focus
- **`rustfmt.toml`**: Code formatting standards (100-char width, Unix line endings)

### Frontend Configuration
- **`package.json`**: Dependencies and scripts for Next.js 15 + TypeScript
- **`eslint.config.js`**: Modern flat config with TypeScript and React rules
- **`tailwind.config.js`**: Tailwind CSS configuration
- **`next.config.js`**: Next.js configuration (minimal setup)
- **`tsconfig.json`**: TypeScript compiler configuration

### CI/CD Configuration
- **`.github/workflows/lint.yml`**: Automated linting, formatting, and testing

## Deployment Notes

### Production Considerations
- Set appropriate CORS policies for production domains
- Configure proper logging levels for production environments
- Consider load balancing for multiple hive instances
- Monitor WebSocket connection limits and performance
- Use MCP server for external integrations

### Hardware Requirements
- **Minimum**: 2GB RAM, 2 CPU cores (basic NLP mode)
- **Recommended**: 4GB RAM, 4 CPU cores (advanced neural features)
- **Optimal**: 8GB+ RAM, 8+ CPU cores with SIMD support

### Environment Variables
- Configure backend port (default: 3001)
- Set WebSocket connection limits
- Configure neural processing parameters
- Set logging levels and output destinations
- Configure MCP server settings for external clients

## Key Dependencies

### Backend (Rust)
- **Core**: `tokio`, `axum`, `serde`, `uuid`, `chrono`, `anyhow`
- **Async**: `async-trait`, `futures`, `futures-util`
- **Concurrency**: `dashmap` for thread-safe collections
- **Math/AI**: `nalgebra`, `petgraph`, optional `ruv-fann`
- **Networking**: `tower`, `tower-http`, `tokio-tungstenite`

### Frontend (TypeScript)
- **Core**: `next` (15.x), `react` (18.x), `typescript` (5.x)
- **State**: `zustand` for state management
- **UI**: `tailwindcss`, `lucide-react`, `recharts`
- **WebSocket**: `ws` for real-time communication
- **AI Integration**: `@ai-sdk/openai`, `@ai-sdk/anthropic`, `ai`