# Multiagent Hive System - Developer Guide

## Project Overview

A sophisticated **hybrid neural multiagent hive system** implementing swarm intelligence with NLP self-learning capabilities. **CPU-native, GPU-optional - built for the GPU-poor.**

### Technology Stack
- **Backend**: Rust with Axum web framework, Tokio async runtime
- **Frontend**: TypeScript, React, Next.js 14, Tailwind CSS
- **Communication**: WebSocket for real-time updates, REST API for CRUD operations
- **Neural Processing**: Basic NLP (default) + optional ruv-FANN integration
- **State Management**: Zustand store with WebSocket integration
- **MCP Integration**: Model Context Protocol server for external tool integration

## Core Architecture

### Backend Structure (`backend/src/`)
- **`main.rs`** - Axum server entry point with WebSocket and REST endpoints
- **`core/hive.rs`** - Central HiveCoordinator managing agent swarms and metrics
- **`agents/agent.rs`** - Agent implementations with types, capabilities, and behaviors
- **`tasks/task.rs`** - Task queue system with priority-based distribution
- **`communication/`** - WebSocket handlers and MCP server implementation
- **`neural/`** - NLP processing and hybrid neural architecture
- **`infrastructure/`** - Metrics, caching, resource management, telemetry
- **`utils/`** - Configuration, error handling, validation utilities
- **`bin/mcp_server.rs`** - Standalone MCP server binary

### Frontend Structure (`frontend/src/`)
- **`app/page.tsx`** - Main application with tab navigation
- **`components/HiveDashboard.tsx`** - Primary monitoring interface
- **`components/SwarmVisualization.tsx`** - Real-time agent visualization
- **`components/MetricsPanel.tsx`** - Performance metrics display
- **`components/NeuralMetrics.tsx`** - Neural processing metrics
- **`components/ResourceMonitor.tsx`** - System resource monitoring
- **`components/AgentManager.tsx`** - Agent creation and configuration
- **`components/TaskManager.tsx`** - Task creation and monitoring
- **`store/hiveStore.ts`** - Zustand store with WebSocket communication

### Examples & Testing (`backend/examples/`)
- **`neural_comparison.rs`** - Compare basic vs advanced neural processing
- **`advanced_neural_test.rs`** - Test advanced neural features
- **`lstm_demo.rs`** - LSTM network demonstrations

## Development Guidelines

### Code Standards
- **Rust**: Follow Clippy rules with comprehensive linting (see `clippy.toml`)
- **TypeScript**: Strict type checking with ESLint flat config
- **Async/Await**: Use throughout for performance and consistency
- **Error Handling**: Use `anyhow::Result` for Rust, proper error boundaries for React
- **Documentation**: Write clear, professional documentation without unnecessary comments

### Architecture Patterns
- **Modular Design**: Clean separation of concerns across modules
- **Dependency Injection**: AppState pattern for shared resources
- **Actor Model**: Agents as independent entities with message passing
- **Event-Driven**: WebSocket-based real-time updates
- **Trait-Based**: Extensible MCP tools via `MCPToolHandler` trait

### Linting & Code Quality

#### Backend (Rust)
- **Clippy**: Comprehensive rules with performance focus
- **Rustfmt**: Consistent formatting with 100-char line width
- **Strict Lints**: Deny `unwrap_used`, `panic`, `unreachable_code`
- **Performance**: Deny `clone_on_ref_ptr`, `rc_buffer`, `rc_mutex`

#### Frontend (TypeScript)
- **ESLint**: Modern flat config with TypeScript-aware rules
- **React**: Hooks and refresh rules for development
- **Style**: Single quotes, no semicolons, Unix line endings
- **Type Safety**: Strict boolean expressions, consistent type definitions

### Performance Optimizations
- **Concurrent Processing**: Tokio async runtime with DashMap for thread-safe storage
- **SIMD Vectorization**: CPU-optimized operations in `cpu_optimization.rs`
- **Memory Efficiency**: Quantized operations and cache-aware data structures
- **Real-time Updates**: Efficient WebSocket communication with 5-second intervals

## Feature Flags & Build Modes

### Cargo Features
```toml
[features]
default = ["basic-nlp"]
basic-nlp = []                    # Lightweight NLP processing
advanced-neural = ["ruv-fann"]    # FANN neural networks
gpu-acceleration = ["ruv-fann/gpu"] # GPU support (optional)
```

### Build Commands
```bash
# Basic mode (recommended for development)
cargo run

# Advanced neural features
cargo run --features advanced-neural

# MCP server
cargo run --bin mcp_server

# Run examples
cargo run --features advanced-neural --example neural_comparison
cargo run --example advanced_neural_test
cargo run --example lstm_demo
```

### Frontend Development
```bash
cd frontend
npm install
npm run dev        # Development server on :3000
npm run build      # Production build
npm run lint       # ESLint checking
npm run lint:fix   # Auto-fix linting issues
```

## Agent System

### Agent Types
- **Worker**: General task execution and basic coordination
- **Coordinator**: Swarm leadership and task distribution
- **Specialist(String)**: Domain-specific expertise
- **Learner**: Continuous learning and adaptation

### Agent States
- **Idle**: Available for task assignment
- **Working**: Actively executing tasks
- **Learning**: Processing new patterns/insights
- **Communicating**: Inter-agent coordination
- **Failed**: Error state requiring intervention

### Capabilities System
```rust
pub struct AgentCapability {
    pub name: String,
    pub proficiency: f64,      // 0.0 to 1.0
    pub learning_rate: f64,    // How quickly this improves
}
```

## Task Management

### Task Priority Levels
- **Low**: Background processing
- **Medium**: Standard operations
- **High**: Important business logic
- **Critical**: System-critical operations

### Task Status Flow
```
Pending → Assigned → InProgress → Completed
                              → Failed
                              → Cancelled
```

### Capability Matching
Tasks specify required capabilities, and the system automatically assigns agents with matching proficiencies.

## Communication System

### WebSocket Messages
- **`hive_status`**: Complete hive state and metrics
- **`agents_update`**: Agent list with current states
- **`metrics_update`**: Performance metrics updates
- **`agent_created`**: New agent creation notifications
- **`task_created`**: New task creation notifications

### REST API Endpoints
- **GET/POST `/api/agents`**: Agent management
- **GET/POST `/api/tasks`**: Task management  
- **GET `/api/hive/status`**: Current hive status

### MCP Integration
- **Tools**: `create_swarm_agent`, `assign_swarm_task`, `get_swarm_status`, `analyze_with_nlp`, `coordinate_agents`
- **Resources**: `hive://status` for live system access
- **Protocol**: Full MCP 1.0 compliance with JSON-RPC 2.0

## Neural Processing

### Basic NLP (Default)
- Lightweight sentiment analysis
- Keyword extraction and pattern recognition
- Semantic vector operations
- Learning from agent interactions

### Advanced Neural (Optional)
- FANN neural networks for complex pattern recognition
- LSTM networks for time series forecasting
- Performance prediction and optimization
- Advanced swarm coordination algorithms

### CPU Optimization Features
- SIMD instruction detection (AVX2, AVX512, SSE4.1, NEON)
- Vectorized operations for matrix computations
- Quantized neural network operations
- Cache-aware data structures

## Data Structures

### Core Types
```rust
// Agent with capabilities and state
pub struct Agent {
    pub id: Uuid,
    pub agent_type: AgentType,
    pub state: AgentState,
    pub capabilities: Vec<AgentCapability>,
    pub position: (f64, f64),
    pub energy: f64,
    // ... additional fields
}

// Task with requirements and status
pub struct Task {
    pub id: Uuid,
    pub description: String,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub required_capabilities: Vec<TaskRequiredCapability>,
    // ... additional fields
}
```

### Metrics & Monitoring
```rust
pub struct SwarmMetrics {
    pub total_agents: usize,
    pub active_agents: usize,
    pub completed_tasks: usize,
    pub failed_tasks: usize,
    pub average_performance: f64,
    pub swarm_cohesion: f64,
    pub learning_progress: f64,
}
```

## Development Workflow

### Quick Start
1. **Backend**: `cd backend && cargo run`
2. **Frontend**: `cd frontend && npm install && npm run dev`
3. **MCP Server**: `cd backend && cargo run --bin mcp_server`
4. **Access**: Frontend at `http://localhost:3000`, Backend at `http://localhost:3001`

### Testing Neural Features
```bash
# Compare basic vs advanced processing
cargo run --features advanced-neural --example neural_comparison

# Test advanced neural capabilities
cargo run --features advanced-neural --example advanced_neural_test

# LSTM demonstration
cargo run --features advanced-neural --example lstm_demo
```

### Debugging & Monitoring
- **WebSocket**: Use browser dev tools to monitor real-time messages
- **Backend Logs**: Check Rust tracing output for detailed system information
- **Frontend State**: Inspect Zustand store state in React DevTools
- **MCP Integration**: Test tools via any MCP-compatible client

## Best Practices

### Performance Considerations
- Use `DashMap` for concurrent agent storage
- Implement proper error handling with `anyhow::Result`
- Leverage Rust's ownership system for memory safety
- Use TypeScript strict mode for frontend type safety
- Follow clippy performance lints (no `clone_on_ref_ptr`, etc.)

### Code Organization
- **Modules**: Follow the established module structure in `lib.rs`
- **Components**: Keep React components focused on single responsibilities
- **State**: Use Zustand for centralized state management
- **Traits**: Implement extensible patterns via trait-based design
- **Testing**: Write comprehensive tests for critical functionality

### Resource Management
- Monitor agent energy levels and performance metrics
- Implement proper cleanup for WebSocket connections
- Use feature flags to control resource-intensive operations
- Consider memory usage when scaling agent populations
- Leverage infrastructure modules for caching and resource management

## Deployment Notes

### Production Considerations
- Set appropriate CORS policies for production domains
- Configure proper logging levels for production environments
- Consider load balancing for multiple hive instances
- Monitor WebSocket connection limits and performance
- Use MCP server for external integrations

### Hardware Requirements
- **Minimum**: 2GB RAM, 2 CPU cores (basic NLP mode)
- **Recommended**: 4GB RAM, 4 CPU cores (advanced neural features)
- **Optimal**: 8GB+ RAM, 8+ CPU cores with SIMD support

### Environment Variables
- Configure backend port (default: 3001)
- Set WebSocket connection limits
- Configure neural processing parameters
- Set logging levels and output destinations
- Configure MCP server settings for external clients