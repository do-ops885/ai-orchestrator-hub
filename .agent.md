# Multiagent Hive System - Developer Guide

## Project Overview

A sophisticated **hybrid neural multiagent hive system** implementing swarm intelligence with NLP self-learning capabilities. **CPU-native, GPU-optional - built for the GPU-poor.**

### Technology Stack
- **Backend**: Rust with Axum web framework, Tokio async runtime
- **Frontend**: TypeScript, React, Next.js 15, Tailwind CSS
- **Communication**: WebSocket for real-time updates, REST API for CRUD operations
- **Neural Processing**: Basic NLP (default) + optional ruv-FANN integration
- **State Management**: Zustand store with WebSocket integration
- **MCP Integration**: Model Context Protocol server for external tool integration

## Core Architecture

### Backend Structure (`backend/src/`)
- **`main.rs`** - Axum server entry point with WebSocket and REST endpoints
- **`core/hive.rs`** - Central HiveCoordinator managing agent swarms and metrics
- **`agents/agent.rs`** - Agent implementations with types, capabilities, and behaviors
- **`agents/memory.rs`** - Agent memory and learning systems
- **`agents/optimized_agent.rs`** - Performance-optimized agent implementations
- **`agents/recovery.rs`** - Agent recovery and error handling
- **`agents/simple_verification.rs`** - Simple verification system for lightweight task validation
- **`tasks/task.rs`** - Task queue system with priority-based distribution
- **`communication/`** - WebSocket handlers and MCP server implementation
- **`neural/`** - NLP processing and hybrid neural architecture
- **`infrastructure/`** - Metrics, caching, resource management, telemetry
- **`utils/`** - Configuration, error handling, validation utilities
- **`bin/mcp_server.rs`** - Standalone MCP server binary

### Frontend Structure (`frontend/src/`)
- **`app/page.tsx`** - Main application with tab navigation
- **`components/HiveDashboard.tsx`** - Primary monitoring interface
- **`components/SwarmVisualization.tsx`** - Real-time agent visualization
- **`components/MetricsPanel.tsx`** - Performance metrics display
- **`components/NeuralMetrics.tsx`** - Neural processing metrics
- **`components/ResourceMonitor.tsx`** - System resource monitoring
- **`components/AgentManager.tsx`** - Agent creation and configuration
- **`components/TaskManager.tsx`** - Task creation and monitoring
- **`store/hiveStore.ts`** - Zustand store with WebSocket communication

### Examples & Testing (`backend/examples/`)
- **`neural_comparison.rs`** - Compare basic vs advanced neural processing
- **`advanced_neural_test.rs`** - Test advanced neural features
- **`lstm_demo.rs`** - LSTM network demonstrations
- **`pair_programming_demo.rs`** - Pair programming verification demonstrations
- **`simple_verification_demo.rs`** - Simple verification system examples
- **`adaptive_verification_demo.rs`** - Adaptive verification system demonstrations

## Development Guidelines

ALWAYS read the codebase before any changes.

### Code Standards
- **Rust**: Follow Clippy rules with comprehensive linting (see `clippy.toml`)
- **TypeScript**: Strict type checking with ESLint flat config
- **Async/Await**: Use throughout for performance and consistency
- **Error Handling**: Use `anyhow::Result` for Rust, proper error boundaries for React
- **Documentation**: Write clear, professional documentation without unnecessary comments

### Architecture Patterns
- **Modular Design**: Clean separation of concerns across modules
- **Dependency Injection**: AppState pattern for shared resources
- **Actor Model**: Agents as independent entities with message passing
- **Event-Driven**: WebSocket-based real-time updates
- **Trait-Based**: Extensible MCP tools via `MCPToolHandler` trait

### Linting & Code Quality

#### Backend (Rust)
- **Clippy**: Comprehensive rules with performance focus (see `backend/clippy.toml`)
- **Rustfmt**: Consistent formatting with 100-char line width (see `backend/rustfmt.toml`)
- **Strict Lints**: Deny `unwrap_used`, `panic`, `unreachable_code`
- **Performance**: Deny `clone_on_ref_ptr`, `rc_buffer`, `rc_mutex`
- **CI/CD**: GitHub Actions with `RUSTFLAGS="-Dwarnings"` for zero-warning builds

#### Frontend (TypeScript)
- **ESLint**: Modern flat config with TypeScript-aware rules (see `frontend/eslint.config.js`)
- **React**: Hooks and refresh rules for development
- **Style**: Single quotes, no semicolons, Unix line endings
- **Type Safety**: Strict boolean expressions, consistent type definitions
- **CI/CD**: TypeScript compilation checks and ESLint with max warnings = 0

### Frontend Development Patterns

#### React Component Architecture
- **Client Components**: All components use `'use client'` directive for Next.js 15 app router
- **Functional Components**: Exclusively use function components with hooks
- **Props Interfaces**: Define TypeScript interfaces for all component props
- **State Management**: Use `useState` for local state, Zustand store for global state
- **Effects**: Use `useEffect` for side effects, API calls, and cleanup

#### Component Structure Standards
```tsx
'use client'

import { useState, useEffect } from 'react'
import { useHiveStore } from '@/store/hiveStore'
import { IconComponent } from 'lucide-react'

interface ComponentProps {
  data: DataType;
  onAction?: (value: string) => void;
}

export function ComponentName({ data, onAction }: ComponentProps) {
  const [localState, setLocalState] = useState<StateType>(initialValue)
  const { globalState, globalAction } = useHiveStore()

  useEffect(() => {
    // Side effects and cleanup
    return () => cleanup()
  }, [dependencies])

  const handleAction = () => {
    // Event handlers
  }

  return (
    <div className="tailwind-classes">
      {/* Component JSX */}
    </div>
  )
}
```

#### TypeScript Conventions
- **Interface Definitions**: Use `interface` over `type` for object shapes
- **Null Safety**: Explicit null checks with `=== null` and `!== null`
- **Optional Chaining**: Use `?.` for safe property access
- **Type Guards**: Implement proper type checking for dynamic data
- **Generic Types**: Use generics for reusable component patterns

#### State Management Patterns
- **Zustand Store**: Centralized state with WebSocket integration
- **Local State**: Component-specific state with `useState`
- **Derived State**: Compute values from existing state rather than storing duplicates
- **State Updates**: Use functional updates for complex state changes
- **Cleanup**: Proper cleanup in `useEffect` return functions

#### Styling Conventions
- **Tailwind CSS**: Utility-first styling with consistent spacing
- **Responsive Design**: Mobile-first approach with `sm:`, `md:`, `lg:` breakpoints
- **Color System**: Consistent color palette (blue, green, purple, yellow, red)
- **Component Variants**: Use conditional classes for state-based styling
- **Layout Patterns**: Grid and flexbox layouts with consistent spacing

#### API Integration Patterns
- **WebSocket**: Real-time updates via Zustand store integration
- **REST API**: Fetch API for CRUD operations with proper error handling
- **Error Handling**: Try-catch blocks with console.error for debugging
- **Loading States**: Show loading indicators during async operations
- **Data Validation**: Type checking for API responses

#### Performance Optimizations
- **Conditional Rendering**: Use logical operators for conditional JSX
- **List Optimization**: Proper `key` props for dynamic lists
- **Effect Dependencies**: Minimal dependency arrays in `useEffect`
- **State Batching**: React 18 automatic batching for state updates
- **Component Splitting**: Separate concerns into focused components

#### UI Component Patterns

##### Layout Components
- **Dashboard Layout**: Tab-based navigation with header and main content area
- **Card Components**: Consistent white background with shadow and rounded corners
- **Grid Layouts**: Responsive grids using `grid-cols-1 md:grid-cols-2 lg:grid-cols-3`
- **Spacing**: Consistent spacing with `space-y-6`, `gap-4`, `p-4`, `px-4 py-5 sm:p-6`

##### Interactive Elements
- **Buttons**: Primary (blue), secondary (gray border), and danger (red) variants
- **Forms**: Controlled inputs with validation and proper labeling
- **Modals/Forms**: Slide-in forms with backdrop and proper focus management
- **Icons**: Lucide React icons with consistent sizing (`w-5 h-5`, `w-4 h-4`)

##### Data Visualization
- **Canvas Rendering**: Custom canvas components for real-time agent visualization
- **Metrics Cards**: Color-coded metric displays with icons and descriptions
- **Status Indicators**: Color-coded badges and dots for states and types
- **Progress Indicators**: Energy rings, progress bars, and percentage displays

##### State Representation
- **Loading States**: Skeleton screens and loading messages
- **Empty States**: Helpful empty state messages with icons and CTAs
- **Error States**: User-friendly error messages with retry options
- **Connection Status**: Real-time connection indicators in header

##### Accessibility Patterns
- **Semantic HTML**: Proper use of headings, lists, and form elements
- **Focus Management**: Keyboard navigation and focus indicators
- **Color Contrast**: Sufficient contrast ratios for text and backgrounds
- **Screen Reader Support**: Proper labeling and ARIA attributes

##### Real-time Updates
- **WebSocket Integration**: Seamless real-time data updates without page refresh
- **Optimistic Updates**: Immediate UI feedback for user actions
- **Data Synchronization**: Consistent state between components
- **Connection Handling**: Graceful handling of connection loss and reconnection

### Performance Optimizations
- **Concurrent Processing**: Tokio async runtime with DashMap for thread-safe storage
- **SIMD Vectorization**: CPU-optimized operations in `cpu_optimization.rs`
- **Memory Efficiency**: Quantized operations and cache-aware data structures
- **Real-time Updates**: Efficient WebSocket communication with 5-second intervals

## Feature Flags & Build Modes

### Cargo Features
```toml
[features]
default = ["basic-nlp"]
basic-nlp = []                    # Lightweight NLP processing
advanced-neural = ["ruv-fann"]    # FANN neural networks
gpu-acceleration = ["ruv-fann/gpu"] # GPU support (optional)
```

### Build Commands
```bash
# Basic mode (recommended for development)
cargo run

# Advanced neural features
cargo run --features advanced-neural

# MCP server
cargo run --bin mcp_server

# Run examples
cargo run --features advanced-neural --example neural_comparison
cargo run --example advanced_neural_test
cargo run --example lstm_demo
```

### Frontend Development
```bash
cd frontend
npm install
npm run dev        # Development server on :3000
npm run build      # Production build
npm run lint       # ESLint checking
npm run lint:fix   # Auto-fix linting issues
npm run lint:check # Zero-warning check for CI
```

#### Frontend Development Workflow
- **Hot Reload**: Next.js 15 with fast refresh for instant development feedback
- **TypeScript Checking**: Real-time type checking with `npx tsc --noEmit`
- **Path Aliases**: Use `@/` for clean imports from `src/` directory
- **Component Development**: Build components in isolation with proper props interfaces
- **State Testing**: Test Zustand store actions and state updates manually via UI

#### Common Development Tasks
```bash
# Start development with backend connection
npm run dev  # Frontend on :3000, connects to backend on :3001

# Type checking during development
npx tsc --noEmit --watch

# Lint specific files
npx eslint src/components/ComponentName.tsx

# Build and test production bundle
npm run build && npm start
```

#### Frontend File Organization
- **Components**: Single-purpose components in `src/components/`
- **Store**: Zustand store with WebSocket integration in `src/store/`
- **App Router**: Next.js 15 app directory structure in `src/app/`
- **Types**: TypeScript interfaces co-located with components
- **Styles**: Global styles in `src/app/globals.css`, Tailwind for components

## Agent System

### Agent Types
- **Worker**: General task execution and basic coordination
- **Coordinator**: Swarm leadership and task distribution
- **Specialist(String)**: Domain-specific expertise
- **Learner**: Continuous learning and adaptation

### Agent States
- **Idle**: Available for task assignment
- **Working**: Actively executing tasks
- **Learning**: Processing new patterns/insights
- **Communicating**: Inter-agent coordination
- **Failed**: Error state requiring intervention

### Capabilities System
```rust
pub struct AgentCapability {
    pub name: String,
    pub proficiency: f64,      // 0.0 to 1.0
    pub learning_rate: f64,    // How quickly this improves
}
```

## Task Management

### Task Priority Levels
- **Low**: Background processing
- **Medium**: Standard operations
- **High**: Important business logic
- **Critical**: System-critical operations

### Task Status Flow
```
Pending → Assigned → InProgress → Completed
                              → Failed
                              → Cancelled
```

### Capability Matching
Tasks specify required capabilities, and the system automatically assigns agents with matching proficiencies.

## Communication System

### WebSocket Messages
- **`hive_status`**: Complete hive state and metrics
- **`agents_update`**: Agent list with current states
- **`metrics_update`**: Performance metrics updates
- **`agent_created`**: New agent creation notifications
- **`task_created`**: New task creation notifications

### REST API Endpoints
- **GET/POST `/api/agents`**: Agent management
- **GET/POST `/api/tasks`**: Task management  
- **GET `/api/hive/status`**: Current hive status

### MCP Integration
- **Tools**: `create_swarm_agent`, `assign_swarm_task`, `get_swarm_status`, `analyze_with_nlp`, `coordinate_agents`
- **Resources**: `hive://status` for live system access
- **Protocol**: Full MCP 1.0 compliance with JSON-RPC 2.0

## Neural Processing

### Basic NLP (Default)
- Lightweight sentiment analysis
- Keyword extraction and pattern recognition
- Semantic vector operations
- Learning from agent interactions

### Advanced Neural (Optional)
- FANN neural networks for complex pattern recognition
- LSTM networks for time series forecasting
- Performance prediction and optimization
- Advanced swarm coordination algorithms

### CPU Optimization Features
- SIMD instruction detection (AVX2, AVX512, SSE4.1, NEON)
- Vectorized operations for matrix computations
- Quantized neural network operations
- Cache-aware data structures

## Data Structures

### Core Types
```rust
// Agent with capabilities and state
pub struct Agent {
    pub id: Uuid,
    pub agent_type: AgentType,
    pub state: AgentState,
    pub capabilities: Vec<AgentCapability>,
    pub position: (f64, f64),
    pub energy: f64,
    // ... additional fields
}

// Task with requirements and status
pub struct Task {
    pub id: Uuid,
    pub description: String,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub required_capabilities: Vec<TaskRequiredCapability>,
    // ... additional fields
}
```

### Frontend Types (TypeScript)
```typescript
interface Agent {
  id: string;
  name: string;
  type: string;
  state: string;
  capabilities: Array<{
    name: string;
    proficiency: number;
    learning_rate: number;
  }>;
  position: [number, number];
  energy: number;
  experience_count: number;
  social_connections: number;
}

interface HiveMetrics {
  total_agents: number;
  active_agents: number;
  completed_tasks: number;
  failed_tasks: number;
  average_performance: number;
  swarm_cohesion: number;
  learning_progress: number;
}
```

## Development Workflow

### Quick Start
1. **Backend**: `cd backend && cargo run`
2. **Frontend**: `cd frontend && npm install && npm run dev`
3. **MCP Server**: `cd backend && cargo run --bin mcp_server`
4. **Access**: Frontend at `http://localhost:3000`, Backend at `http://localhost:3001`

### Important Documentation
- **API Reference**: See `docs/API.md` for complete REST API and WebSocket documentation
- **Demo Script**: See `DEMO_SCRIPT.md` for guided demonstration scenarios
- **Contributing**: See `CONTRIBUTING.md` for contribution guidelines and code review process
- **Quick Start**: See `QUICK_START_GUIDE.md` for detailed setup instructions

### Testing Neural Features
```bash
# Compare basic vs advanced processing
cargo run --features advanced-neural --example neural_comparison

# Test advanced neural capabilities
cargo run --features advanced-neural --example advanced_neural_test

# LSTM demonstration
cargo run --features advanced-neural --example lstm_demo
```

### CI/CD Pipeline
- **Linting**: Automated Clippy and ESLint checks with zero-warning policy
- **Formatting**: Rustfmt and Prettier validation
- **Testing**: Cargo test with all features + frontend build verification
- **Documentation**: Cargo doc generation for API documentation

### Debugging & Monitoring
- **WebSocket**: Use browser dev tools to monitor real-time messages
- **Backend Logs**: Check Rust tracing output for detailed system information
- **Frontend State**: Inspect Zustand store state in React DevTools
- **MCP Integration**: Test tools via any MCP-compatible client

## Best Practices

### Performance Considerations
- Use `DashMap` for concurrent agent storage
- Implement proper error handling with `anyhow::Result`
- Leverage Rust's ownership system for memory safety
- Use TypeScript strict mode for frontend type safety
- Follow clippy performance lints (no `clone_on_ref_ptr`, etc.)

### Code Organization
- **Modules**: Follow the established module structure in `lib.rs`
- **Components**: Keep React components focused on single responsibilities
- **State**: Use Zustand for centralized state management
- **Traits**: Implement extensible patterns via trait-based design
- **Testing**: Write comprehensive tests for critical functionality

### 🚨 **CRITICAL: Enhancement vs New File Guidelines**

**❌ DON'T: Create Duplicate Files**
- Never duplicate existing functionality in separate files
- This creates confusion, maintenance overhead, and architectural debt

**✅ WHEN to Create New Files:**
- **Completely new functionality** that doesn't exist yet
- **New subsystems** that complement existing ones
- **Utility modules** that support existing functionality
- **Cross-cutting concerns** (logging, monitoring, security)

**🔍 Before Creating Any New File, Ask:**
1. "Does this functionality already exist in another file?"
2. "Can I enhance an existing file instead?"
3. "Is this truly a new subsystem or just an enhancement?"
4. "Will this create confusion about which file to use?"

**📝 Naming Convention for New Files:**
- Use descriptive, specific names that clearly indicate purpose
- Avoid generic prefixes: ~~`advanced_`, `enhanced_`, `new_`, `improved_`~~
- Make the functionality clear from the filename
- Follow project naming conventions

### Resource Management
- Monitor agent energy levels and performance metrics
- Implement proper cleanup for WebSocket connections
- Use feature flags to control resource-intensive operations
- Consider memory usage when scaling agent populations
- Leverage infrastructure modules for caching and resource management

## Configuration Files

### Backend Configuration
- **`Cargo.toml`**: Dependencies, features, and lint configuration
- **`clippy.toml`**: Comprehensive Clippy rules with performance focus
- **`rustfmt.toml`**: Code formatting standards (100-char width, Unix line endings)

### Frontend Configuration
- **`package.json`**: Dependencies and scripts for Next.js 15 + TypeScript
- **`eslint.config.js`**: Modern flat config with TypeScript and React rules
- **`tailwind.config.js`**: Tailwind CSS configuration
- **`next.config.js`**: Next.js configuration (minimal setup)
- **`tsconfig.json`**: TypeScript compiler configuration

### CI/CD Configuration
- **`.github/workflows/lint.yml`**: Automated linting, formatting, and testing
  - Frontend ESLint with zero-warning policy (`npm run lint:check`)
  - Backend Clippy with comprehensive rules and `RUSTFLAGS="-Dwarnings"`
  - TypeScript compilation checks (`npx tsc --noEmit`)
  - Rustfmt formatting validation
  - Integration tests with all features enabled
  - Cargo documentation generation

## Deployment Notes

### Production Considerations
- Set appropriate CORS policies for production domains
- Configure proper logging levels for production environments
- Consider load balancing for multiple hive instances
- Monitor WebSocket connection limits and performance
- Use MCP server for external integrations

### Hardware Requirements
- **Minimum**: 2GB RAM, 2 CPU cores (basic NLP mode)
- **Recommended**: 4GB RAM, 4 CPU cores (advanced neural features)
- **Optimal**: 8GB+ RAM, 8+ CPU cores with SIMD support

### Environment Variables
- Configure backend port (default: 3001)
- Set WebSocket connection limits
- Configure neural processing parameters
- Set logging levels and output destinations
- Configure MCP server settings for external clients

## Key Dependencies

### Backend (Rust)
- **Core**: `tokio`, `axum`, `serde`, `uuid`, `chrono`, `anyhow`
- **Async**: `async-trait`, `futures`, `futures-util`
- **Concurrency**: `dashmap` for thread-safe collections
- **Math/AI**: `nalgebra`, `petgraph`, optional `ruv-fann`
- **Networking**: `tower`, `tower-http`, `tokio-tungstenite`

### Frontend (TypeScript)
- **Core**: `next` (15.x), `react` (18.x), `typescript` (5.x)
- **State**: `zustand` for state management
- **UI**: `tailwindcss`, `lucide-react`, `recharts`
- **WebSocket**: `ws` for real-time communication
- **AI Integration**: `@ai-sdk/openai`, `@ai-sdk/anthropic`, `ai`