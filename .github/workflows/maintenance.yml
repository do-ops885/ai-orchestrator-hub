name: Maintenance

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      maintenance_type:
        description: 'Type of maintenance to run'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - dependencies
          - cache
          - security
          - performance

concurrency:
  group: maintenance
  cancel-in-progress: false

env:
  LOG_LEVEL: INFO
  LOG_FORMAT: json
  CORRELATION_ID: ${{ github.run_id }}-${{ github.run_attempt }}

jobs:
  # Maintenance planning and setup
  maintenance-setup:
    name: Maintenance Setup
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      maintenance-plan: ${{ steps.plan.outputs.plan }}
      correlation-id: ${{ env.CORRELATION_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize structured logging
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Maintenance workflow started" \
            '{"maintenance_type": "${{ github.event.inputs.maintenance_type || 'full' }}"}'

      - name: Create maintenance plan
        id: plan
        run: |
          source log_helper.sh

          maintenance_type="${{ github.event.inputs.maintenance_type || 'full' }}"

          case $maintenance_type in
            "dependencies")
              plan='{"dependencies": true, "cache": false, "security": false, "performance": false}'
              ;;
            "cache")
              plan='{"dependencies": false, "cache": true, "security": false, "performance": false}'
              ;;
            "security")
              plan='{"dependencies": false, "cache": false, "security": true, "performance": false}'
              ;;
            "performance")
              plan='{"dependencies": false, "cache": false, "security": false, "performance": true}'
              ;;
            *)
              plan='{"dependencies": true, "cache": true, "security": true, "performance": true}'
              ;;
          esac

          echo "plan=$plan" >> $GITHUB_OUTPUT
          log_structured "INFO" "Maintenance plan created" "{\"plan\": $plan}"

  # Enhanced dependency updates with automated PR creation
  dependency-updates:
    name: Dependency Updates
    runs-on: ubuntu-latest
    needs: maintenance-setup
    if: fromJson(needs.maintenance-setup.outputs.maintenance-plan).dependencies
    timeout-minutes: 45

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize logging
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }

          retry_with_backoff() {
            local max_attempts=3
            local delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if eval "$1"; then
                return 0
              else
                local exit_code=$?
                if [ $attempt -eq $max_attempts ]; then
                  return $exit_code
                fi
                sleep $delay
                delay=$((delay * 2))
                attempt=$((attempt + 1))
              fi
            done
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Dependency updates job started"

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install dependency update tools
        run: |
          source log_helper.sh
          log_structured "INFO" "Installing dependency update tools"

          # Install cargo-update for Rust dependencies
          retry_with_backoff "cargo install cargo-update"

          # Install npm-check-updates for Node.js dependencies
          retry_with_backoff "npm install -g npm-check-updates"

      - name: Check Rust dependencies with impact analysis
        run: |
          source log_helper.sh
          log_structured "INFO" "Checking Rust dependencies"

          cd backend

          # Get current dependency versions
          cargo tree --format "{p} {f}" > current_deps.txt

          # Check for outdated dependencies
          cargo outdated --format json > outdated_deps.json || echo '[]' > outdated_deps.json

          # Analyze impact of updates
          outdated_count=$(jq length outdated_deps.json)
          log_structured "INFO" "Rust dependency analysis completed" \
            "{\"outdated_count\": $outdated_count}"

          if [ $outdated_count -gt 0 ]; then
            log_structured "INFO" "Found outdated Rust dependencies" \
              "{\"dependencies\": $(cat outdated_deps.json)}"
          fi

      - name: Check Node.js dependencies with impact analysis
        run: |
          source log_helper.sh
          log_structured "INFO" "Checking Node.js dependencies"

          cd frontend

          # Check for outdated dependencies
          ncu --jsonAll > outdated_npm.json || echo '{}' > outdated_npm.json

          # Analyze security vulnerabilities
          npm audit --json > security_audit.json || echo '{}' > security_audit.json

          # Count updates needed
          outdated_count=$(jq 'keys | length' outdated_npm.json)
          vulnerabilities=$(jq '.metadata.vulnerabilities.total // 0' security_audit.json)

          log_structured "INFO" "Node.js dependency analysis completed" \
            "{\"outdated_count\": $outdated_count, \"vulnerabilities\": $vulnerabilities}"

      - name: Create dependency update branch
        run: |
          source log_helper.sh

          # Check if updates are needed
          rust_updates=$(jq length backend/outdated_deps.json)
          npm_updates=$(jq 'keys | length' frontend/outdated_npm.json)

          if [ $rust_updates -gt 0 ] || [ $npm_updates -gt 0 ]; then
            branch_name="maintenance/dependency-updates-$(date +%Y%m%d)"

            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            git checkout -b $branch_name

            log_structured "INFO" "Created dependency update branch" \
              "{\"branch\": \"$branch_name\", \"rust_updates\": $rust_updates, \"npm_updates\": $npm_updates}"

            echo "BRANCH_NAME=$branch_name" >> $GITHUB_ENV
            echo "HAS_UPDATES=true" >> $GITHUB_ENV
          else
            log_structured "INFO" "No dependency updates needed"
            echo "HAS_UPDATES=false" >> $GITHUB_ENV
          fi

      - name: Update Rust dependencies
        if: env.HAS_UPDATES == 'true'
        run: |
          source log_helper.sh
          log_structured "INFO" "Updating Rust dependencies"

          cd backend

          # Update patch versions only (safer)
          cargo update

          # Test that updates don't break anything
          if cargo check --all-features; then
            log_structured "INFO" "Rust dependency updates successful"
            git add Cargo.lock
          else
            log_structured "ERROR" "Rust dependency updates failed tests"
            git checkout Cargo.lock
          fi

      - name: Update Node.js dependencies
        if: env.HAS_UPDATES == 'true'
        run: |
          source log_helper.sh
          log_structured "INFO" "Updating Node.js dependencies"

          cd frontend

          # Update patch and minor versions only
          ncu --target minor --upgrade

          # Install updated dependencies
          npm install

          # Test that updates don't break anything
          if npm run build && npm test; then
            log_structured "INFO" "Node.js dependency updates successful"
            git add package.json package-lock.json
          else
            log_structured "ERROR" "Node.js dependency updates failed tests"
            git checkout package.json package-lock.json
          fi

      - name: Commit and create PR
        if: env.HAS_UPDATES == 'true'
        run: |
          source log_helper.sh

          if git diff --staged --quiet; then
            log_structured "INFO" "No changes to commit"
            exit 0
          fi

          # Create commit
          git commit -m "chore: update dependencies

          - Updated Rust dependencies to latest patch versions
          - Updated Node.js dependencies to latest minor versions
          - All tests passing after updates

          Automated maintenance update on $(date -u +%Y-%m-%d)"

          # Push branch
          git push origin $BRANCH_NAME

          # Create PR using GitHub CLI
          gh pr create \
            --title "🔧 Automated Dependency Updates - $(date +%Y-%m-%d)" \
            --body "## Automated Dependency Updates

          This PR contains automated dependency updates performed by the maintenance workflow.

          ### Changes
          - ✅ Rust dependencies updated to latest patch versions
          - ✅ Node.js dependencies updated to latest minor versions
          - ✅ All tests passing

          ### Safety
          - Only patch and minor version updates included
          - All builds and tests verified before PR creation
          - No breaking changes expected

          ### Review Notes
          Please review the dependency changes and merge if everything looks good.

          Correlation ID: $CORRELATION_ID" \
            --label "maintenance,dependencies,automated" \
            --assignee "@me"

          log_structured "INFO" "Dependency update PR created" \
            "{\"branch\": \"$BRANCH_NAME\", \"correlation_id\": \"$CORRELATION_ID\"}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup dependency updates
        if: always()
        run: |
          source log_helper.sh
          log_structured "INFO" "Dependency updates job completed" \
            '{"status": "${{ job.status }}", "has_updates": "${{ env.HAS_UPDATES }}"}'
          rm -f log_helper.sh

  # Enhanced cache maintenance with intelligent cleanup
  cache-maintenance:
    name: Cache Maintenance
    runs-on: ubuntu-latest
    needs: maintenance-setup
    if: fromJson(needs.maintenance-setup.outputs.maintenance-plan).cache
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Initialize cache maintenance logging
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Cache maintenance job started"

      - name: Analyze cache usage
        run: |
          source log_helper.sh
          log_structured "INFO" "Analyzing cache usage patterns"

          # Get cache statistics using GitHub API
          cache_stats=$(gh api repos/${{ github.repository }}/actions/caches --jq '.actions_caches[] | {key: .key, size_in_bytes: .size_in_bytes, last_accessed_at: .last_accessed_at}')

          echo "$cache_stats" > cache_analysis.json

          total_caches=$(echo "$cache_stats" | jq -s length)
          total_size=$(echo "$cache_stats" | jq -s 'map(.size_in_bytes) | add // 0')

          log_structured "INFO" "Cache analysis completed" \
            "{\"total_caches\": $total_caches, \"total_size_bytes\": $total_size}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean old caches
        run: |
          source log_helper.sh
          log_structured "INFO" "Cleaning old caches"

          # Delete caches older than 7 days
          cutoff_date=$(date -d '7 days ago' -u +%Y-%m-%dT%H:%M:%SZ)

          deleted_count=0
          while IFS= read -r cache_id; do
            if [ -n "$cache_id" ]; then
              gh api --method DELETE repos/${{ github.repository }}/actions/caches/$cache_id
              deleted_count=$((deleted_count + 1))
              log_structured "DEBUG" "Deleted cache" "{\"cache_id\": \"$cache_id\"}"
            fi
          done < <(gh api repos/${{ github.repository }}/actions/caches --jq ".actions_caches[] | select(.last_accessed_at < \"$cutoff_date\") | .id")

          log_structured "INFO" "Cache cleanup completed" \
            "{\"deleted_count\": $deleted_count, \"cutoff_date\": \"$cutoff_date\"}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Optimize cache keys
        run: |
          source log_helper.sh
          log_structured "INFO" "Optimizing cache key strategies"

          # Analyze cache hit rates and suggest optimizations
          # This would typically involve analyzing workflow logs

          log_structured "INFO" "Cache optimization analysis completed"

  # Enhanced security monitoring with automated remediation
  security-monitoring:
    name: Security Monitoring
    runs-on: ubuntu-latest
    needs: maintenance-setup
    if: fromJson(needs.maintenance-setup.outputs.maintenance-plan).security
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Initialize security monitoring
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Security monitoring job started"

      - name: Setup security tools
        run: |
          source log_helper.sh
          log_structured "INFO" "Setting up security tools"

          # Install security scanning tools
          cargo install cargo-audit
          npm install -g audit-ci

      - name: Comprehensive security audit
        run: |
          source log_helper.sh
          log_structured "INFO" "Running comprehensive security audit"

          # Rust security audit
          cd backend
          cargo audit --json > ../rust_security_audit.json || echo '{"vulnerabilities": []}' > ../rust_security_audit.json

          rust_vulns=$(jq '.vulnerabilities | length' ../rust_security_audit.json)
          log_structured "INFO" "Rust security audit completed" "{\"vulnerabilities\": $rust_vulns}"

          # Node.js security audit
          cd ../frontend
          npm audit --json > ../npm_security_audit.json || echo '{"vulnerabilities": {}}' > ../npm_security_audit.json

          npm_vulns=$(jq '.metadata.vulnerabilities.total // 0' ../npm_security_audit.json)
          log_structured "INFO" "Node.js security audit completed" "{\"vulnerabilities\": $npm_vulns}"

      - name: Risk assessment and prioritization
        run: |
          source log_helper.sh
          log_structured "INFO" "Performing risk assessment"

          # Analyze vulnerability severity and impact
          high_risk_rust=$(jq '[.vulnerabilities[] | select(.advisory.severity == "high" or .advisory.severity == "critical")] | length' rust_security_audit.json)
          high_risk_npm=$(jq '.metadata.vulnerabilities.high + .metadata.vulnerabilities.critical' npm_security_audit.json)

          total_high_risk=$((high_risk_rust + high_risk_npm))

          log_structured "INFO" "Risk assessment completed" \
            "{\"high_risk_total\": $total_high_risk, \"rust_high_risk\": $high_risk_rust, \"npm_high_risk\": $high_risk_npm}"

          # Create security report
          cat > security_report.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "correlation_id": "$CORRELATION_ID",
            "rust_vulnerabilities": $rust_vulns,
            "npm_vulnerabilities": $npm_vulns,
            "high_risk_total": $total_high_risk,
            "requires_immediate_attention": $([ $total_high_risk -gt 0 ] && echo true || echo false)
          }
          EOF

      - name: Automated remediation
        run: |
          source log_helper.sh

          if [ -f security_report.json ] && [ $(jq '.requires_immediate_attention' security_report.json) = "true" ]; then
            log_structured "WARN" "High-risk vulnerabilities detected, attempting automated remediation"

            # Create security fix branch
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            branch_name="security/automated-fixes-$(date +%Y%m%d)"
            git checkout -b $branch_name

            # Attempt automated fixes
            cd frontend
            npm audit fix --force || true

            cd ../backend
            # For Rust, we'd typically need manual intervention, but we can update Cargo.lock
            cargo update

            # Check if fixes were applied
            if ! git diff --quiet; then
              git add .
              git commit -m "security: automated vulnerability fixes

              - Applied automated security fixes
              - Updated dependencies to address vulnerabilities

              Automated security maintenance on $(date -u +%Y-%m-%d)
              Correlation ID: $CORRELATION_ID"

              git push origin $branch_name

              # Create urgent PR
              gh pr create \
                --title "🚨 URGENT: Automated Security Fixes - $(date +%Y-%m-%d)" \
                --body "## 🚨 Urgent Security Fixes

              This PR contains automated fixes for high-risk security vulnerabilities.

              ### Security Issues Addressed
              - High-risk vulnerabilities detected in dependencies
              - Automated fixes applied where possible

              ### Action Required
              - **URGENT**: Please review and merge immediately
              - Manual review may be needed for complex vulnerabilities

              ### Details
              - Correlation ID: $CORRELATION_ID
              - Generated by automated security monitoring

              See security report for full details." \
                --label "security,urgent,automated" \
                --assignee "@me"

              log_structured "WARN" "Urgent security PR created" \
                "{\"branch\": \"$branch_name\", \"high_risk_count\": $(jq '.high_risk_total' security_report.json)}"
            fi
          else
            log_structured "INFO" "No immediate security action required"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports
          path: |
            security_report.json
            rust_security_audit.json
            npm_security_audit.json
          retention-days: 90

  # Enhanced performance monitoring with trend analysis
  performance-monitoring:
    name: Performance Monitoring
    runs-on: ubuntu-latest
    needs: maintenance-setup
    if: fromJson(needs.maintenance-setup.outputs.maintenance-plan).performance
    timeout-minutes: 40

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Initialize performance monitoring
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Performance monitoring job started"

      - name: Setup performance tools
        run: |
          source log_helper.sh
          log_structured "INFO" "Setting up performance monitoring tools"

          # Setup Rust
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source ~/.cargo/env

          # Setup Node.js
          curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
          sudo apt-get install -y nodejs

          # Install performance tools
          cargo install cargo-criterion || true
          npm install -g clinic

      - name: Run performance benchmarks
        run: |
          source log_helper.sh
          log_structured "INFO" "Running performance benchmarks"

          # Rust benchmarks
          cd backend
          if [ -d "benches" ]; then
            cargo bench --bench criterion_benchmark -- --output-format json > ../rust_benchmarks.json || echo '{}' > ../rust_benchmarks.json
            log_structured "INFO" "Rust benchmarks completed"
          fi

          # Frontend performance tests
          cd ../frontend
          npm install

          # Build performance
          start_time=$(date +%s%3N)
          npm run build
          end_time=$(date +%s%3N)
          build_time=$((end_time - start_time))

          echo "{\"build_time_ms\": $build_time}" > ../frontend_performance.json
          log_structured "INFO" "Frontend performance tests completed" "{\"build_time_ms\": $build_time}"

      - name: Performance trend analysis
        run: |
          source log_helper.sh
          log_structured "INFO" "Analyzing performance trends"

          # Download previous performance data
          mkdir -p performance_history

          # Get performance data from previous runs (simplified)
          current_date=$(date +%Y-%m-%d)

          # Create performance report
          cat > performance_report.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "correlation_id": "$CORRELATION_ID",
            "date": "$current_date",
            "rust_benchmarks": $(cat rust_benchmarks.json),
            "frontend_performance": $(cat frontend_performance.json)
          }
          EOF

          log_structured "INFO" "Performance analysis completed"

      - name: Performance regression detection
        run: |
          source log_helper.sh
          log_structured "INFO" "Detecting performance regressions"

          # Simple regression detection (in a real scenario, you'd compare with historical data)
          frontend_build_time=$(jq '.build_time_ms' frontend_performance.json)

          # Set threshold (e.g., 30 seconds = 30000ms)
          threshold=30000

          if [ $frontend_build_time -gt $threshold ]; then
            log_structured "WARN" "Performance regression detected" \
              "{\"metric\": \"frontend_build_time\", \"value\": $frontend_build_time, \"threshold\": $threshold}"

            # Create performance issue
            gh issue create \
              --title "⚠️ Performance Regression Detected - $(date +%Y-%m-%d)" \
              --body "## Performance Regression Alert

              A performance regression has been detected in the build process.

              ### Details
              - **Metric**: Frontend build time
              - **Current**: ${frontend_build_time}ms
              - **Threshold**: ${threshold}ms
              - **Correlation ID**: $CORRELATION_ID

              ### Action Required
              Please investigate the cause of the performance degradation.

              ### Performance Report
              See attached performance report for detailed metrics." \
              --label "performance,regression,maintenance"
          else
            log_structured "INFO" "No performance regressions detected"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload performance reports
        uses: actions/upload-artifact@v4
        with:
          name: performance-reports
          path: |
            performance_report.json
            rust_benchmarks.json
            frontend_performance.json
          retention-days: 90

  # Maintenance summary and reporting
  maintenance-summary:
    name: Maintenance Summary
    runs-on: ubuntu-latest
    needs: [maintenance-setup, dependency-updates, cache-maintenance, security-monitoring, performance-monitoring]
    if: always()
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Initialize summary logging
        run: |
          cat > log_helper.sh << 'EOF'
          #!/bin/bash
          log_structured() {
            local level="$1"
            local message="$2"
            local extra="${3:-{}}"

            jq -n \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)" \
              --arg level "$level" \
              --arg message "$message" \
              --arg workflow "$GITHUB_WORKFLOW" \
              --arg job "$GITHUB_JOB" \
              --arg run_id "$GITHUB_RUN_ID" \
              --arg correlation_id "$CORRELATION_ID" \
              --arg extra "$extra" \
              '{
                timestamp: $timestamp,
                level: $level,
                message: $message,
                workflow: $workflow,
                job: $job,
                run_id: $run_id,
                correlation_id: $correlation_id,
                context: $extra
              }'
          }
          EOF
          chmod +x log_helper.sh
          source log_helper.sh
          log_structured "INFO" "Maintenance summary job started"

      - name: Download maintenance reports
        uses: actions/download-artifact@v5
        with:
          pattern: "*-reports"
          merge-multiple: true
        continue-on-error: true

      - name: Generate comprehensive maintenance report
        run: |
          source log_helper.sh
          log_structured "INFO" "Generating comprehensive maintenance report"

          # Create comprehensive summary
          cat > maintenance_summary.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)",
            "correlation_id": "$CORRELATION_ID",
            "workflow_run_id": "$GITHUB_RUN_ID",
            "maintenance_plan": ${{ needs.maintenance-setup.outputs.maintenance-plan }},
            "job_results": {
              "dependency_updates": "${{ needs.dependency-updates.result }}",
              "cache_maintenance": "${{ needs.cache-maintenance.result }}",
              "security_monitoring": "${{ needs.security-monitoring.result }}",
              "performance_monitoring": "${{ needs.performance-monitoring.result }}"
            },
            "reports_generated": {
              "security_report": $([ -f "security_report.json" ] && echo "true" || echo "false"),
              "performance_report": $([ -f "performance_report.json" ] && echo "true" || echo "false")
            }
          }
          EOF

          log_structured "INFO" "Maintenance summary generated" \
            "$(cat maintenance_summary.json)"

      - name: Create maintenance issue if needed
        run: |
          source log_helper.sh

          # Check if any critical issues were found
          critical_issues=false

          if [ -f "security_report.json" ]; then
            requires_attention=$(jq -r '.requires_immediate_attention' security_report.json)
            if [ "$requires_attention" = "true" ]; then
              critical_issues=true
            fi
          fi

          # Check job failures
          failed_jobs=""
          if [ "${{ needs.dependency-updates.result }}" = "failure" ]; then
            failed_jobs="$failed_jobs dependency-updates"
          fi
          if [ "${{ needs.cache-maintenance.result }}" = "failure" ]; then
            failed_jobs="$failed_jobs cache-maintenance"
          fi
          if [ "${{ needs.security-monitoring.result }}" = "failure" ]; then
            failed_jobs="$failed_jobs security-monitoring"
          fi
          if [ "${{ needs.performance-monitoring.result }}" = "failure" ]; then
            failed_jobs="$failed_jobs performance-monitoring"
          fi

          if [ "$critical_issues" = "true" ] || [ -n "$failed_jobs" ]; then
            log_structured "WARN" "Creating maintenance issue due to critical findings"

            gh issue create \
              --title "🔧 Maintenance Report - Issues Detected - $(date +%Y-%m-%d)" \
              --body "## Maintenance Report - $(date +%Y-%m-%d)

              The automated maintenance workflow has detected issues that require attention.

              ### Critical Issues
              - Security vulnerabilities requiring immediate attention: $critical_issues
              - Failed maintenance jobs: $failed_jobs

              ### Details
              - **Correlation ID**: $CORRELATION_ID
              - **Workflow Run**: $GITHUB_RUN_ID

              ### Action Required
              Please review the maintenance reports and address any critical issues.

              ### Reports
              - Security Report: $([ -f 'security_report.json' ] && echo 'Available' || echo 'Not generated')
              - Performance Report: $([ -f 'performance_report.json' ] && echo 'Available' || echo 'Not generated')

              See workflow artifacts for detailed reports." \
              --label "maintenance,attention-required"
          else
            log_structured "INFO" "No critical maintenance issues detected"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload maintenance summary
        uses: actions/upload-artifact@v4
        with:
          name: maintenance-summary
          path: maintenance_summary.json
          retention-days: 90

      - name: Cleanup and final status
        if: always()
        run: |
          source log_helper.sh

          # Determine overall maintenance status
          overall_status="success"
          if [ "${{ needs.dependency-updates.result }}" = "failure" ] || \
             [ "${{ needs.cache-maintenance.result }}" = "failure" ] || \
             [ "${{ needs.security-monitoring.result }}" = "failure" ] || \
             [ "${{ needs.performance-monitoring.result }}" = "failure" ]; then
            overall_status="failure"
          fi

          log_structured "INFO" "Maintenance workflow completed" \
            "{\"overall_status\": \"$overall_status\", \"correlation_id\": \"$CORRELATION_ID\"}"

          if [ "$overall_status" = "failure" ]; then
            exit 1
          fi
